{
  "version": 3,
  "file": "build.js",
  "sources": [
    "lib/jquery.js",
    "lib/Ractive.js",
    "lib/underscore.js",
    "lib/backbone.js",
    "lib/backbone.adaptor.js",
    "models/movie.js",
    "collections/movieCollection.js",
    "mock/movieData.js",
    "lib/text.js",
    "lib/rv.js",
    "templates/movies!rv",
    "views/moviesView.js",
    "templates/shows!rv",
    "views/showsView.js",
    "router.js",
    "app.js",
    "lib/holder.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5nRA,AD6nRA;AC5nRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC35SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClwCA,ADmwCA;AClwCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACziDA,AD0iDA;ACziDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzGA;AACA;AACA;AACA;AACA;AACA;ACLA,ADMA;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3CA,AD4CA;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjYA,ADkYA;ACjYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpCA;AACA,ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvBA,ADwBA;ACvBA,ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvBA,ADwBA;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACXA,ADYA;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "\n/*!\r\n * jQuery JavaScript Library v2.0.3\r\n * http://jquery.com/\r\n *\r\n * Includes Sizzle.js\r\n * http://sizzlejs.com/\r\n *\r\n * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors\r\n * Released under the MIT license\r\n * http://jquery.org/license\r\n *\r\n * Date: 2013-07-03T13:30Z\r\n */\r\n(function( window, undefined ) {\r\n\r\n// Can't do this because several apps including ASP.NET trace\r\n// the stack via arguments.caller.callee and Firefox dies if\r\n// you try to trace through \"use strict\" call chains. (#13335)\r\n// Support: Firefox 18+\r\n//\"use strict\";\r\nvar\r\n\t// A central reference to the root jQuery(document)\r\n\trootjQuery,\r\n\r\n\t// The deferred used on DOM ready\r\n\treadyList,\r\n\r\n\t// Support: IE9\r\n\t// For `typeof xmlNode.method` instead of `xmlNode.method !== undefined`\r\n\tcore_strundefined = typeof undefined,\r\n\r\n\t// Use the correct document accordingly with window argument (sandbox)\r\n\tlocation = window.location,\r\n\tdocument = window.document,\r\n\tdocElem = document.documentElement,\r\n\r\n\t// Map over jQuery in case of overwrite\r\n\t_jQuery = window.jQuery,\r\n\r\n\t// Map over the $ in case of overwrite\r\n\t_$ = window.$,\r\n\r\n\t// [[Class]] -> type pairs\r\n\tclass2type = {},\r\n\r\n\t// List of deleted data cache ids, so we can reuse them\r\n\tcore_deletedIds = [],\r\n\r\n\tcore_version = \"2.0.3\",\r\n\r\n\t// Save a reference to some core methods\r\n\tcore_concat = core_deletedIds.concat,\r\n\tcore_push = core_deletedIds.push,\r\n\tcore_slice = core_deletedIds.slice,\r\n\tcore_indexOf = core_deletedIds.indexOf,\r\n\tcore_toString = class2type.toString,\r\n\tcore_hasOwn = class2type.hasOwnProperty,\r\n\tcore_trim = core_version.trim,\r\n\r\n\t// Define a local copy of jQuery\r\n\tjQuery = function( selector, context ) {\r\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\r\n\t\treturn new jQuery.fn.init( selector, context, rootjQuery );\r\n\t},\r\n\r\n\t// Used for matching numbers\r\n\tcore_pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\r\n\r\n\t// Used for splitting on whitespace\r\n\tcore_rnotwhite = /\\S+/g,\r\n\r\n\t// A simple way to check for HTML strings\r\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\r\n\t// Strict HTML recognition (#11290: must start with <)\r\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\r\n\r\n\t// Match a standalone tag\r\n\trsingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\r\n\r\n\t// Matches dashed string for camelizing\r\n\trmsPrefix = /^-ms-/,\r\n\trdashAlpha = /-([\\da-z])/gi,\r\n\r\n\t// Used by jQuery.camelCase as callback to replace()\r\n\tfcamelCase = function( all, letter ) {\r\n\t\treturn letter.toUpperCase();\r\n\t},\r\n\r\n\t// The ready event handler and self cleanup method\r\n\tcompleted = function() {\r\n\t\tdocument.removeEventListener( \"DOMContentLoaded\", completed, false );\r\n\t\twindow.removeEventListener( \"load\", completed, false );\r\n\t\tjQuery.ready();\r\n\t};\r\n\r\njQuery.fn = jQuery.prototype = {\r\n\t// The current version of jQuery being used\r\n\tjquery: core_version,\r\n\r\n\tconstructor: jQuery,\r\n\tinit: function( selector, context, rootjQuery ) {\r\n\t\tvar match, elem;\r\n\r\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\r\n\t\tif ( !selector ) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\t// Handle HTML strings\r\n\t\tif ( typeof selector === \"string\" ) {\r\n\t\t\tif ( selector.charAt(0) === \"<\" && selector.charAt( selector.length - 1 ) === \">\" && selector.length >= 3 ) {\r\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\r\n\t\t\t\tmatch = [ null, selector, null ];\r\n\r\n\t\t\t} else {\r\n\t\t\t\tmatch = rquickExpr.exec( selector );\r\n\t\t\t}\r\n\r\n\t\t\t// Match html or make sure no context is specified for #id\r\n\t\t\tif ( match && (match[1] || !context) ) {\r\n\r\n\t\t\t\t// HANDLE: $(html) -> $(array)\r\n\t\t\t\tif ( match[1] ) {\r\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\r\n\r\n\t\t\t\t\t// scripts is true for back-compat\r\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\r\n\t\t\t\t\t\tmatch[1],\r\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\r\n\t\t\t\t\t\ttrue\r\n\t\t\t\t\t) );\r\n\r\n\t\t\t\t\t// HANDLE: $(html, props)\r\n\t\t\t\t\tif ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\r\n\t\t\t\t\t\tfor ( match in context ) {\r\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\r\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\r\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\r\n\r\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn this;\r\n\r\n\t\t\t\t// HANDLE: $(#id)\r\n\t\t\t\t} else {\r\n\t\t\t\t\telem = document.getElementById( match[2] );\r\n\r\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\r\n\t\t\t\t\t// nodes that are no longer in the document #6963\r\n\t\t\t\t\tif ( elem && elem.parentNode ) {\r\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\r\n\t\t\t\t\t\tthis.length = 1;\r\n\t\t\t\t\t\tthis[0] = elem;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.context = document;\r\n\t\t\t\t\tthis.selector = selector;\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t}\r\n\r\n\t\t\t// HANDLE: $(expr, $(...))\r\n\t\t\t} else if ( !context || context.jquery ) {\r\n\t\t\t\treturn ( context || rootjQuery ).find( selector );\r\n\r\n\t\t\t// HANDLE: $(expr, context)\r\n\t\t\t// (which is just equivalent to: $(context).find(expr)\r\n\t\t\t} else {\r\n\t\t\t\treturn this.constructor( context ).find( selector );\r\n\t\t\t}\r\n\r\n\t\t// HANDLE: $(DOMElement)\r\n\t\t} else if ( selector.nodeType ) {\r\n\t\t\tthis.context = this[0] = selector;\r\n\t\t\tthis.length = 1;\r\n\t\t\treturn this;\r\n\r\n\t\t// HANDLE: $(function)\r\n\t\t// Shortcut for document ready\r\n\t\t} else if ( jQuery.isFunction( selector ) ) {\r\n\t\t\treturn rootjQuery.ready( selector );\r\n\t\t}\r\n\r\n\t\tif ( selector.selector !== undefined ) {\r\n\t\t\tthis.selector = selector.selector;\r\n\t\t\tthis.context = selector.context;\r\n\t\t}\r\n\r\n\t\treturn jQuery.makeArray( selector, this );\r\n\t},\r\n\r\n\t// Start with an empty selector\r\n\tselector: \"\",\r\n\r\n\t// The default length of a jQuery object is 0\r\n\tlength: 0,\r\n\r\n\ttoArray: function() {\r\n\t\treturn core_slice.call( this );\r\n\t},\r\n\r\n\t// Get the Nth element in the matched element set OR\r\n\t// Get the whole matched element set as a clean array\r\n\tget: function( num ) {\r\n\t\treturn num == null ?\r\n\r\n\t\t\t// Return a 'clean' array\r\n\t\t\tthis.toArray() :\r\n\r\n\t\t\t// Return just the object\r\n\t\t\t( num < 0 ? this[ this.length + num ] : this[ num ] );\r\n\t},\r\n\r\n\t// Take an array of elements and push it onto the stack\r\n\t// (returning the new matched element set)\r\n\tpushStack: function( elems ) {\r\n\r\n\t\t// Build a new jQuery matched element set\r\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\r\n\r\n\t\t// Add the old object onto the stack (as a reference)\r\n\t\tret.prevObject = this;\r\n\t\tret.context = this.context;\r\n\r\n\t\t// Return the newly-formed element set\r\n\t\treturn ret;\r\n\t},\r\n\r\n\t// Execute a callback for every element in the matched set.\r\n\t// (You can seed the arguments with an array of args, but this is\r\n\t// only used internally.)\r\n\teach: function( callback, args ) {\r\n\t\treturn jQuery.each( this, callback, args );\r\n\t},\r\n\r\n\tready: function( fn ) {\r\n\t\t// Add the callback\r\n\t\tjQuery.ready.promise().done( fn );\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tslice: function() {\r\n\t\treturn this.pushStack( core_slice.apply( this, arguments ) );\r\n\t},\r\n\r\n\tfirst: function() {\r\n\t\treturn this.eq( 0 );\r\n\t},\r\n\r\n\tlast: function() {\r\n\t\treturn this.eq( -1 );\r\n\t},\r\n\r\n\teq: function( i ) {\r\n\t\tvar len = this.length,\r\n\t\t\tj = +i + ( i < 0 ? len : 0 );\r\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\r\n\t},\r\n\r\n\tmap: function( callback ) {\r\n\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\r\n\t\t\treturn callback.call( elem, i, elem );\r\n\t\t}));\r\n\t},\r\n\r\n\tend: function() {\r\n\t\treturn this.prevObject || this.constructor(null);\r\n\t},\r\n\r\n\t// For internal use only.\r\n\t// Behaves like an Array's method, not like a jQuery method.\r\n\tpush: core_push,\r\n\tsort: [].sort,\r\n\tsplice: [].splice\r\n};\r\n\r\n// Give the init function the jQuery prototype for later instantiation\r\njQuery.fn.init.prototype = jQuery.fn;\r\n\r\njQuery.extend = jQuery.fn.extend = function() {\r\n\tvar options, name, src, copy, copyIsArray, clone,\r\n\t\ttarget = arguments[0] || {},\r\n\t\ti = 1,\r\n\t\tlength = arguments.length,\r\n\t\tdeep = false;\r\n\r\n\t// Handle a deep copy situation\r\n\tif ( typeof target === \"boolean\" ) {\r\n\t\tdeep = target;\r\n\t\ttarget = arguments[1] || {};\r\n\t\t// skip the boolean and the target\r\n\t\ti = 2;\r\n\t}\r\n\r\n\t// Handle case when target is a string or something (possible in deep copy)\r\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\r\n\t\ttarget = {};\r\n\t}\r\n\r\n\t// extend jQuery itself if only one argument is passed\r\n\tif ( length === i ) {\r\n\t\ttarget = this;\r\n\t\t--i;\r\n\t}\r\n\r\n\tfor ( ; i < length; i++ ) {\r\n\t\t// Only deal with non-null/undefined values\r\n\t\tif ( (options = arguments[ i ]) != null ) {\r\n\t\t\t// Extend the base object\r\n\t\t\tfor ( name in options ) {\r\n\t\t\t\tsrc = target[ name ];\r\n\t\t\t\tcopy = options[ name ];\r\n\r\n\t\t\t\t// Prevent never-ending loop\r\n\t\t\t\tif ( target === copy ) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Recurse if we're merging plain objects or arrays\r\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\r\n\t\t\t\t\tif ( copyIsArray ) {\r\n\t\t\t\t\t\tcopyIsArray = false;\r\n\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\r\n\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Never move original objects, clone them\r\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\r\n\r\n\t\t\t\t// Don't bring in undefined values\r\n\t\t\t\t} else if ( copy !== undefined ) {\r\n\t\t\t\t\ttarget[ name ] = copy;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Return the modified object\r\n\treturn target;\r\n};\r\n\r\njQuery.extend({\r\n\t// Unique for each copy of jQuery on the page\r\n\texpando: \"jQuery\" + ( core_version + Math.random() ).replace( /\\D/g, \"\" ),\r\n\r\n\tnoConflict: function( deep ) {\r\n\t\tif ( window.$ === jQuery ) {\r\n\t\t\twindow.$ = _$;\r\n\t\t}\r\n\r\n\t\tif ( deep && window.jQuery === jQuery ) {\r\n\t\t\twindow.jQuery = _jQuery;\r\n\t\t}\r\n\r\n\t\treturn jQuery;\r\n\t},\r\n\r\n\t// Is the DOM ready to be used? Set to true once it occurs.\r\n\tisReady: false,\r\n\r\n\t// A counter to track how many items to wait for before\r\n\t// the ready event fires. See #6781\r\n\treadyWait: 1,\r\n\r\n\t// Hold (or release) the ready event\r\n\tholdReady: function( hold ) {\r\n\t\tif ( hold ) {\r\n\t\t\tjQuery.readyWait++;\r\n\t\t} else {\r\n\t\t\tjQuery.ready( true );\r\n\t\t}\r\n\t},\r\n\r\n\t// Handle when the DOM is ready\r\n\tready: function( wait ) {\r\n\r\n\t\t// Abort if there are pending holds or we're already ready\r\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Remember that the DOM is ready\r\n\t\tjQuery.isReady = true;\r\n\r\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\r\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// If there are functions bound, to execute\r\n\t\treadyList.resolveWith( document, [ jQuery ] );\r\n\r\n\t\t// Trigger any bound ready events\r\n\t\tif ( jQuery.fn.trigger ) {\r\n\t\t\tjQuery( document ).trigger(\"ready\").off(\"ready\");\r\n\t\t}\r\n\t},\r\n\r\n\t// See test/unit/core.js for details concerning isFunction.\r\n\t// Since version 1.3, DOM methods and functions like alert\r\n\t// aren't supported. They return false on IE (#2968).\r\n\tisFunction: function( obj ) {\r\n\t\treturn jQuery.type(obj) === \"function\";\r\n\t},\r\n\r\n\tisArray: Array.isArray,\r\n\r\n\tisWindow: function( obj ) {\r\n\t\treturn obj != null && obj === obj.window;\r\n\t},\r\n\r\n\tisNumeric: function( obj ) {\r\n\t\treturn !isNaN( parseFloat(obj) ) && isFinite( obj );\r\n\t},\r\n\r\n\ttype: function( obj ) {\r\n\t\tif ( obj == null ) {\r\n\t\t\treturn String( obj );\r\n\t\t}\r\n\t\t// Support: Safari <= 5.1 (functionish RegExp)\r\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\r\n\t\t\tclass2type[ core_toString.call(obj) ] || \"object\" :\r\n\t\t\ttypeof obj;\r\n\t},\r\n\r\n\tisPlainObject: function( obj ) {\r\n\t\t// Not plain objects:\r\n\t\t// - Any object or value whose internal [[Class]] property is not \"[object Object]\"\r\n\t\t// - DOM nodes\r\n\t\t// - window\r\n\t\tif ( jQuery.type( obj ) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Support: Firefox <20\r\n\t\t// The try/catch suppresses exceptions thrown when attempting to access\r\n\t\t// the \"constructor\" property of certain host objects, ie. |window.location|\r\n\t\t// https://bugzilla.mozilla.org/show_bug.cgi?id=814622\r\n\t\ttry {\r\n\t\t\tif ( obj.constructor &&\r\n\t\t\t\t\t!core_hasOwn.call( obj.constructor.prototype, \"isPrototypeOf\" ) ) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t} catch ( e ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// If the function hasn't returned already, we're confident that\r\n\t\t// |obj| is a plain object, created by {} or constructed with new Object\r\n\t\treturn true;\r\n\t},\r\n\r\n\tisEmptyObject: function( obj ) {\r\n\t\tvar name;\r\n\t\tfor ( name in obj ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t},\r\n\r\n\terror: function( msg ) {\r\n\t\tthrow new Error( msg );\r\n\t},\r\n\r\n\t// data: string of html\r\n\t// context (optional): If specified, the fragment will be created in this context, defaults to document\r\n\t// keepScripts (optional): If true, will include scripts passed in the html string\r\n\tparseHTML: function( data, context, keepScripts ) {\r\n\t\tif ( !data || typeof data !== \"string\" ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif ( typeof context === \"boolean\" ) {\r\n\t\t\tkeepScripts = context;\r\n\t\t\tcontext = false;\r\n\t\t}\r\n\t\tcontext = context || document;\r\n\r\n\t\tvar parsed = rsingleTag.exec( data ),\r\n\t\t\tscripts = !keepScripts && [];\r\n\r\n\t\t// Single tag\r\n\t\tif ( parsed ) {\r\n\t\t\treturn [ context.createElement( parsed[1] ) ];\r\n\t\t}\r\n\r\n\t\tparsed = jQuery.buildFragment( [ data ], context, scripts );\r\n\r\n\t\tif ( scripts ) {\r\n\t\t\tjQuery( scripts ).remove();\r\n\t\t}\r\n\r\n\t\treturn jQuery.merge( [], parsed.childNodes );\r\n\t},\r\n\r\n\tparseJSON: JSON.parse,\r\n\r\n\t// Cross-browser xml parsing\r\n\tparseXML: function( data ) {\r\n\t\tvar xml, tmp;\r\n\t\tif ( !data || typeof data !== \"string\" ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// Support: IE9\r\n\t\ttry {\r\n\t\t\ttmp = new DOMParser();\r\n\t\t\txml = tmp.parseFromString( data , \"text/xml\" );\r\n\t\t} catch ( e ) {\r\n\t\t\txml = undefined;\r\n\t\t}\r\n\r\n\t\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\r\n\t\t\tjQuery.error( \"Invalid XML: \" + data );\r\n\t\t}\r\n\t\treturn xml;\r\n\t},\r\n\r\n\tnoop: function() {},\r\n\r\n\t// Evaluates a script in a global context\r\n\tglobalEval: function( code ) {\r\n\t\tvar script,\r\n\t\t\t\tindirect = eval;\r\n\r\n\t\tcode = jQuery.trim( code );\r\n\r\n\t\tif ( code ) {\r\n\t\t\t// If the code includes a valid, prologue position\r\n\t\t\t// strict mode pragma, execute code by injecting a\r\n\t\t\t// script tag into the document.\r\n\t\t\tif ( code.indexOf(\"use strict\") === 1 ) {\r\n\t\t\t\tscript = document.createElement(\"script\");\r\n\t\t\t\tscript.text = code;\r\n\t\t\t\tdocument.head.appendChild( script ).parentNode.removeChild( script );\r\n\t\t\t} else {\r\n\t\t\t// Otherwise, avoid the DOM node creation, insertion\r\n\t\t\t// and removal by using an indirect global eval\r\n\t\t\t\tindirect( code );\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// Convert dashed to camelCase; used by the css and data modules\r\n\t// Microsoft forgot to hump their vendor prefix (#9572)\r\n\tcamelCase: function( string ) {\r\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\r\n\t},\r\n\r\n\tnodeName: function( elem, name ) {\r\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\r\n\t},\r\n\r\n\t// args is for internal usage only\r\n\teach: function( obj, callback, args ) {\r\n\t\tvar value,\r\n\t\t\ti = 0,\r\n\t\t\tlength = obj.length,\r\n\t\t\tisArray = isArraylike( obj );\r\n\r\n\t\tif ( args ) {\r\n\t\t\tif ( isArray ) {\r\n\t\t\t\tfor ( ; i < length; i++ ) {\r\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\r\n\r\n\t\t\t\t\tif ( value === false ) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor ( i in obj ) {\r\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\r\n\r\n\t\t\t\t\tif ( value === false ) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t// A special, fast, case for the most common use of each\r\n\t\t} else {\r\n\t\t\tif ( isArray ) {\r\n\t\t\t\tfor ( ; i < length; i++ ) {\r\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\r\n\r\n\t\t\t\t\tif ( value === false ) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor ( i in obj ) {\r\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\r\n\r\n\t\t\t\t\tif ( value === false ) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn obj;\r\n\t},\r\n\r\n\ttrim: function( text ) {\r\n\t\treturn text == null ? \"\" : core_trim.call( text );\r\n\t},\r\n\r\n\t// results is for internal usage only\r\n\tmakeArray: function( arr, results ) {\r\n\t\tvar ret = results || [];\r\n\r\n\t\tif ( arr != null ) {\r\n\t\t\tif ( isArraylike( Object(arr) ) ) {\r\n\t\t\t\tjQuery.merge( ret,\r\n\t\t\t\t\ttypeof arr === \"string\" ?\r\n\t\t\t\t\t[ arr ] : arr\r\n\t\t\t\t);\r\n\t\t\t} else {\r\n\t\t\t\tcore_push.call( ret, arr );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t},\r\n\r\n\tinArray: function( elem, arr, i ) {\r\n\t\treturn arr == null ? -1 : core_indexOf.call( arr, elem, i );\r\n\t},\r\n\r\n\tmerge: function( first, second ) {\r\n\t\tvar l = second.length,\r\n\t\t\ti = first.length,\r\n\t\t\tj = 0;\r\n\r\n\t\tif ( typeof l === \"number\" ) {\r\n\t\t\tfor ( ; j < l; j++ ) {\r\n\t\t\t\tfirst[ i++ ] = second[ j ];\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\twhile ( second[j] !== undefined ) {\r\n\t\t\t\tfirst[ i++ ] = second[ j++ ];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfirst.length = i;\r\n\r\n\t\treturn first;\r\n\t},\r\n\r\n\tgrep: function( elems, callback, inv ) {\r\n\t\tvar retVal,\r\n\t\t\tret = [],\r\n\t\t\ti = 0,\r\n\t\t\tlength = elems.length;\r\n\t\tinv = !!inv;\r\n\r\n\t\t// Go through the array, only saving the items\r\n\t\t// that pass the validator function\r\n\t\tfor ( ; i < length; i++ ) {\r\n\t\t\tretVal = !!callback( elems[ i ], i );\r\n\t\t\tif ( inv !== retVal ) {\r\n\t\t\t\tret.push( elems[ i ] );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t},\r\n\r\n\t// arg is for internal usage only\r\n\tmap: function( elems, callback, arg ) {\r\n\t\tvar value,\r\n\t\t\ti = 0,\r\n\t\t\tlength = elems.length,\r\n\t\t\tisArray = isArraylike( elems ),\r\n\t\t\tret = [];\r\n\r\n\t\t// Go through the array, translating each of the items to their\r\n\t\tif ( isArray ) {\r\n\t\t\tfor ( ; i < length; i++ ) {\r\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\r\n\r\n\t\t\t\tif ( value != null ) {\r\n\t\t\t\t\tret[ ret.length ] = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t// Go through every key on the object,\r\n\t\t} else {\r\n\t\t\tfor ( i in elems ) {\r\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\r\n\r\n\t\t\t\tif ( value != null ) {\r\n\t\t\t\t\tret[ ret.length ] = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Flatten any nested arrays\r\n\t\treturn core_concat.apply( [], ret );\r\n\t},\r\n\r\n\t// A global GUID counter for objects\r\n\tguid: 1,\r\n\r\n\t// Bind a function to a context, optionally partially applying any\r\n\t// arguments.\r\n\tproxy: function( fn, context ) {\r\n\t\tvar tmp, args, proxy;\r\n\r\n\t\tif ( typeof context === \"string\" ) {\r\n\t\t\ttmp = fn[ context ];\r\n\t\t\tcontext = fn;\r\n\t\t\tfn = tmp;\r\n\t\t}\r\n\r\n\t\t// Quick check to determine if target is callable, in the spec\r\n\t\t// this throws a TypeError, but we will just return undefined.\r\n\t\tif ( !jQuery.isFunction( fn ) ) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\t// Simulated bind\r\n\t\targs = core_slice.call( arguments, 2 );\r\n\t\tproxy = function() {\r\n\t\t\treturn fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );\r\n\t\t};\r\n\r\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\r\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\r\n\r\n\t\treturn proxy;\r\n\t},\r\n\r\n\t// Multifunctional method to get and set values of a collection\r\n\t// The value/s can optionally be executed if it's a function\r\n\taccess: function( elems, fn, key, value, chainable, emptyGet, raw ) {\r\n\t\tvar i = 0,\r\n\t\t\tlength = elems.length,\r\n\t\t\tbulk = key == null;\r\n\r\n\t\t// Sets many values\r\n\t\tif ( jQuery.type( key ) === \"object\" ) {\r\n\t\t\tchainable = true;\r\n\t\t\tfor ( i in key ) {\r\n\t\t\t\tjQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\r\n\t\t\t}\r\n\r\n\t\t// Sets one value\r\n\t\t} else if ( value !== undefined ) {\r\n\t\t\tchainable = true;\r\n\r\n\t\t\tif ( !jQuery.isFunction( value ) ) {\r\n\t\t\t\traw = true;\r\n\t\t\t}\r\n\r\n\t\t\tif ( bulk ) {\r\n\t\t\t\t// Bulk operations run against the entire set\r\n\t\t\t\tif ( raw ) {\r\n\t\t\t\t\tfn.call( elems, value );\r\n\t\t\t\t\tfn = null;\r\n\r\n\t\t\t\t// ...except when executing function values\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbulk = fn;\r\n\t\t\t\t\tfn = function( elem, key, value ) {\r\n\t\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( fn ) {\r\n\t\t\t\tfor ( ; i < length; i++ ) {\r\n\t\t\t\t\tfn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn chainable ?\r\n\t\t\telems :\r\n\r\n\t\t\t// Gets\r\n\t\t\tbulk ?\r\n\t\t\t\tfn.call( elems ) :\r\n\t\t\t\tlength ? fn( elems[0], key ) : emptyGet;\r\n\t},\r\n\r\n\tnow: Date.now,\r\n\r\n\t// A method for quickly swapping in/out CSS properties to get correct calculations.\r\n\t// Note: this method belongs to the css module but it's needed here for the support module.\r\n\t// If support gets modularized, this method should be moved back to the css module.\r\n\tswap: function( elem, options, callback, args ) {\r\n\t\tvar ret, name,\r\n\t\t\told = {};\r\n\r\n\t\t// Remember the old values, and insert the new ones\r\n\t\tfor ( name in options ) {\r\n\t\t\told[ name ] = elem.style[ name ];\r\n\t\t\telem.style[ name ] = options[ name ];\r\n\t\t}\r\n\r\n\t\tret = callback.apply( elem, args || [] );\r\n\r\n\t\t// Revert the old values\r\n\t\tfor ( name in options ) {\r\n\t\t\telem.style[ name ] = old[ name ];\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t}\r\n});\r\n\r\njQuery.ready.promise = function( obj ) {\r\n\tif ( !readyList ) {\r\n\r\n\t\treadyList = jQuery.Deferred();\r\n\r\n\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\r\n\t\t// we once tried to use readyState \"interactive\" here, but it caused issues like the one\r\n\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\r\n\t\tif ( document.readyState === \"complete\" ) {\r\n\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\r\n\t\t\tsetTimeout( jQuery.ready );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Use the handy event callback\r\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed, false );\r\n\r\n\t\t\t// A fallback to window.onload, that will always work\r\n\t\t\twindow.addEventListener( \"load\", completed, false );\r\n\t\t}\r\n\t}\r\n\treturn readyList.promise( obj );\r\n};\r\n\r\n// Populate the class2type map\r\njQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\r\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\r\n});\r\n\r\nfunction isArraylike( obj ) {\r\n\tvar length = obj.length,\r\n\t\ttype = jQuery.type( obj );\r\n\r\n\tif ( jQuery.isWindow( obj ) ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif ( obj.nodeType === 1 && length ) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn type === \"array\" || type !== \"function\" &&\r\n\t\t( length === 0 ||\r\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj );\r\n}\r\n\r\n// All jQuery objects should point back to these\r\nrootjQuery = jQuery(document);\r\n/*!\r\n * Sizzle CSS Selector Engine v1.9.4-pre\r\n * http://sizzlejs.com/\r\n *\r\n * Copyright 2013 jQuery Foundation, Inc. and other contributors\r\n * Released under the MIT license\r\n * http://jquery.org/license\r\n *\r\n * Date: 2013-06-03\r\n */\r\n(function( window, undefined ) {\r\n\r\nvar i,\r\n\tsupport,\r\n\tcachedruns,\r\n\tExpr,\r\n\tgetText,\r\n\tisXML,\r\n\tcompile,\r\n\toutermostContext,\r\n\tsortInput,\r\n\r\n\t// Local document vars\r\n\tsetDocument,\r\n\tdocument,\r\n\tdocElem,\r\n\tdocumentIsHTML,\r\n\trbuggyQSA,\r\n\trbuggyMatches,\r\n\tmatches,\r\n\tcontains,\r\n\r\n\t// Instance-specific data\r\n\texpando = \"sizzle\" + -(new Date()),\r\n\tpreferredDoc = window.document,\r\n\tdirruns = 0,\r\n\tdone = 0,\r\n\tclassCache = createCache(),\r\n\ttokenCache = createCache(),\r\n\tcompilerCache = createCache(),\r\n\thasDuplicate = false,\r\n\tsortOrder = function( a, b ) {\r\n\t\tif ( a === b ) {\r\n\t\t\thasDuplicate = true;\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\treturn 0;\r\n\t},\r\n\r\n\t// General-purpose constants\r\n\tstrundefined = typeof undefined,\r\n\tMAX_NEGATIVE = 1 << 31,\r\n\r\n\t// Instance methods\r\n\thasOwn = ({}).hasOwnProperty,\r\n\tarr = [],\r\n\tpop = arr.pop,\r\n\tpush_native = arr.push,\r\n\tpush = arr.push,\r\n\tslice = arr.slice,\r\n\t// Use a stripped-down indexOf if we can't use a native one\r\n\tindexOf = arr.indexOf || function( elem ) {\r\n\t\tvar i = 0,\r\n\t\t\tlen = this.length;\r\n\t\tfor ( ; i < len; i++ ) {\r\n\t\t\tif ( this[i] === elem ) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t},\r\n\r\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\r\n\r\n\t// Regular expressions\r\n\r\n\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\r\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\r\n\t// http://www.w3.org/TR/css3-syntax/#characters\r\n\tcharacterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\r\n\r\n\t// Loosely modeled on CSS identifier characters\r\n\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\r\n\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\r\n\tidentifier = characterEncoding.replace( \"w\", \"w#\" ),\r\n\r\n\t// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors\r\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")\" + whitespace +\r\n\t\t\"*(?:([*^$|!~]?=)\" + whitespace + \"*(?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(\" + identifier + \")|)|)\" + whitespace + \"*\\\\]\",\r\n\r\n\t// Prefer arguments quoted,\r\n\t//   then not containing pseudos/brackets,\r\n\t//   then attribute selectors/non-parenthetical expressions,\r\n\t//   then anything else\r\n\t// These preferences are here to reduce the number of selectors\r\n\t//   needing tokenize in the PSEUDO preFilter\r\n\tpseudos = \":(\" + characterEncoding + \")(?:\\\\(((['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes.replace( 3, 8 ) + \")*)|.*)\\\\)|)\",\r\n\r\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\r\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\r\n\r\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\r\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\r\n\r\n\trsibling = new RegExp( whitespace + \"*[+~]\" ),\r\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*)\" + whitespace + \"*\\\\]\", \"g\" ),\r\n\r\n\trpseudo = new RegExp( pseudos ),\r\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\r\n\r\n\tmatchExpr = {\r\n\t\t\"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\r\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\r\n\t\t\"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\r\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\r\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\r\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\r\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\r\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\r\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\r\n\t\t// For use in libraries implementing .is()\r\n\t\t// We use this for POS matching in `select`\r\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\r\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\r\n\t},\r\n\r\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\r\n\r\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\r\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\r\n\r\n\trinputs = /^(?:input|select|textarea|button)$/i,\r\n\trheader = /^h\\d$/i,\r\n\r\n\trescape = /'|\\\\/g,\r\n\r\n\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\r\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\r\n\tfunescape = function( _, escaped, escapedWhitespace ) {\r\n\t\tvar high = \"0x\" + escaped - 0x10000;\r\n\t\t// NaN means non-codepoint\r\n\t\t// Support: Firefox\r\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\r\n\t\treturn high !== high || escapedWhitespace ?\r\n\t\t\tescaped :\r\n\t\t\t// BMP codepoint\r\n\t\t\thigh < 0 ?\r\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\r\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\r\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\r\n\t};\r\n\r\n// Optimize for push.apply( _, NodeList )\r\ntry {\r\n\tpush.apply(\r\n\t\t(arr = slice.call( preferredDoc.childNodes )),\r\n\t\tpreferredDoc.childNodes\r\n\t);\r\n\t// Support: Android<4.0\r\n\t// Detect silently failing push.apply\r\n\tarr[ preferredDoc.childNodes.length ].nodeType;\r\n} catch ( e ) {\r\n\tpush = { apply: arr.length ?\r\n\r\n\t\t// Leverage slice if possible\r\n\t\tfunction( target, els ) {\r\n\t\t\tpush_native.apply( target, slice.call(els) );\r\n\t\t} :\r\n\r\n\t\t// Support: IE<9\r\n\t\t// Otherwise append directly\r\n\t\tfunction( target, els ) {\r\n\t\t\tvar j = target.length,\r\n\t\t\t\ti = 0;\r\n\t\t\t// Can't trust NodeList.length\r\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\r\n\t\t\ttarget.length = j - 1;\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction Sizzle( selector, context, results, seed ) {\r\n\tvar match, elem, m, nodeType,\r\n\t\t// QSA vars\r\n\t\ti, groups, old, nid, newContext, newSelector;\r\n\r\n\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\r\n\t\tsetDocument( context );\r\n\t}\r\n\r\n\tcontext = context || document;\r\n\tresults = results || [];\r\n\r\n\tif ( !selector || typeof selector !== \"string\" ) {\r\n\t\treturn results;\r\n\t}\r\n\r\n\tif ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {\r\n\t\treturn [];\r\n\t}\r\n\r\n\tif ( documentIsHTML && !seed ) {\r\n\r\n\t\t// Shortcuts\r\n\t\tif ( (match = rquickExpr.exec( selector )) ) {\r\n\t\t\t// Speed-up: Sizzle(\"#ID\")\r\n\t\t\tif ( (m = match[1]) ) {\r\n\t\t\t\tif ( nodeType === 9 ) {\r\n\t\t\t\t\telem = context.getElementById( m );\r\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\r\n\t\t\t\t\t// nodes that are no longer in the document #6963\r\n\t\t\t\t\tif ( elem && elem.parentNode ) {\r\n\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\r\n\t\t\t\t\t\t// by name instead of ID\r\n\t\t\t\t\t\tif ( elem.id === m ) {\r\n\t\t\t\t\t\t\tresults.push( elem );\r\n\t\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Context is not a document\r\n\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\r\n\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\r\n\t\t\t\t\t\tresults.push( elem );\r\n\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t// Speed-up: Sizzle(\"TAG\")\r\n\t\t\t} else if ( match[2] ) {\r\n\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\r\n\t\t\t\treturn results;\r\n\r\n\t\t\t// Speed-up: Sizzle(\".CLASS\")\r\n\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {\r\n\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\r\n\t\t\t\treturn results;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// QSA path\r\n\t\tif ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\r\n\t\t\tnid = old = expando;\r\n\t\t\tnewContext = context;\r\n\t\t\tnewSelector = nodeType === 9 && selector;\r\n\r\n\t\t\t// qSA works strangely on Element-rooted queries\r\n\t\t\t// We can work around this by specifying an extra ID on the root\r\n\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\r\n\t\t\t// IE 8 doesn't work on object elements\r\n\t\t\tif ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\r\n\t\t\t\tgroups = tokenize( selector );\r\n\r\n\t\t\t\tif ( (old = context.getAttribute(\"id\")) ) {\r\n\t\t\t\t\tnid = old.replace( rescape, \"\\\\$&\" );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcontext.setAttribute( \"id\", nid );\r\n\t\t\t\t}\r\n\t\t\t\tnid = \"[id='\" + nid + \"'] \";\r\n\r\n\t\t\t\ti = groups.length;\r\n\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\tgroups[i] = nid + toSelector( groups[i] );\r\n\t\t\t\t}\r\n\t\t\t\tnewContext = rsibling.test( selector ) && context.parentNode || context;\r\n\t\t\t\tnewSelector = groups.join(\",\");\r\n\t\t\t}\r\n\r\n\t\t\tif ( newSelector ) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tpush.apply( results,\r\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn results;\r\n\t\t\t\t} catch(qsaError) {\r\n\t\t\t\t} finally {\r\n\t\t\t\t\tif ( !old ) {\r\n\t\t\t\t\t\tcontext.removeAttribute(\"id\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// All others\r\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\r\n}\r\n\r\n/**\r\n * Create key-value caches of limited size\r\n * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\r\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\r\n *\tdeleting the oldest entry\r\n */\r\nfunction createCache() {\r\n\tvar keys = [];\r\n\r\n\tfunction cache( key, value ) {\r\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\r\n\t\tif ( keys.push( key += \" \" ) > Expr.cacheLength ) {\r\n\t\t\t// Only keep the most recent entries\r\n\t\t\tdelete cache[ keys.shift() ];\r\n\t\t}\r\n\t\treturn (cache[ key ] = value);\r\n\t}\r\n\treturn cache;\r\n}\r\n\r\n/**\r\n * Mark a function for special use by Sizzle\r\n * @param {Function} fn The function to mark\r\n */\r\nfunction markFunction( fn ) {\r\n\tfn[ expando ] = true;\r\n\treturn fn;\r\n}\r\n\r\n/**\r\n * Support testing using an element\r\n * @param {Function} fn Passed the created div and expects a boolean result\r\n */\r\nfunction assert( fn ) {\r\n\tvar div = document.createElement(\"div\");\r\n\r\n\ttry {\r\n\t\treturn !!fn( div );\r\n\t} catch (e) {\r\n\t\treturn false;\r\n\t} finally {\r\n\t\t// Remove from its parent by default\r\n\t\tif ( div.parentNode ) {\r\n\t\t\tdiv.parentNode.removeChild( div );\r\n\t\t}\r\n\t\t// release memory in IE\r\n\t\tdiv = null;\r\n\t}\r\n}\r\n\r\n/**\r\n * Adds the same handler for all of the specified attrs\r\n * @param {String} attrs Pipe-separated list of attributes\r\n * @param {Function} handler The method that will be applied\r\n */\r\nfunction addHandle( attrs, handler ) {\r\n\tvar arr = attrs.split(\"|\"),\r\n\t\ti = attrs.length;\r\n\r\n\twhile ( i-- ) {\r\n\t\tExpr.attrHandle[ arr[i] ] = handler;\r\n\t}\r\n}\r\n\r\n/**\r\n * Checks document order of two siblings\r\n * @param {Element} a\r\n * @param {Element} b\r\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\r\n */\r\nfunction siblingCheck( a, b ) {\r\n\tvar cur = b && a,\r\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\r\n\t\t\t( ~b.sourceIndex || MAX_NEGATIVE ) -\r\n\t\t\t( ~a.sourceIndex || MAX_NEGATIVE );\r\n\r\n\t// Use IE sourceIndex if available on both nodes\r\n\tif ( diff ) {\r\n\t\treturn diff;\r\n\t}\r\n\r\n\t// Check if b follows a\r\n\tif ( cur ) {\r\n\t\twhile ( (cur = cur.nextSibling) ) {\r\n\t\t\tif ( cur === b ) {\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn a ? 1 : -1;\r\n}\r\n\r\n/**\r\n * Returns a function to use in pseudos for input types\r\n * @param {String} type\r\n */\r\nfunction createInputPseudo( type ) {\r\n\treturn function( elem ) {\r\n\t\tvar name = elem.nodeName.toLowerCase();\r\n\t\treturn name === \"input\" && elem.type === type;\r\n\t};\r\n}\r\n\r\n/**\r\n * Returns a function to use in pseudos for buttons\r\n * @param {String} type\r\n */\r\nfunction createButtonPseudo( type ) {\r\n\treturn function( elem ) {\r\n\t\tvar name = elem.nodeName.toLowerCase();\r\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\r\n\t};\r\n}\r\n\r\n/**\r\n * Returns a function to use in pseudos for positionals\r\n * @param {Function} fn\r\n */\r\nfunction createPositionalPseudo( fn ) {\r\n\treturn markFunction(function( argument ) {\r\n\t\targument = +argument;\r\n\t\treturn markFunction(function( seed, matches ) {\r\n\t\t\tvar j,\r\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\r\n\t\t\t\ti = matchIndexes.length;\r\n\r\n\t\t\t// Match elements found at the specified indexes\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\r\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t});\r\n}\r\n\r\n/**\r\n * Detect xml\r\n * @param {Element|Object} elem An element or a document\r\n */\r\nisXML = Sizzle.isXML = function( elem ) {\r\n\t// documentElement is verified for cases where it doesn't yet exist\r\n\t// (such as loading iframes in IE - #4833)\r\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\r\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\r\n};\r\n\r\n// Expose support vars for convenience\r\nsupport = Sizzle.support = {};\r\n\r\n/**\r\n * Sets document-related variables once based on the current document\r\n * @param {Element|Object} [doc] An element or document object to use to set the document\r\n * @returns {Object} Returns the current document\r\n */\r\nsetDocument = Sizzle.setDocument = function( node ) {\r\n\tvar doc = node ? node.ownerDocument || node : preferredDoc,\r\n\t\tparent = doc.defaultView;\r\n\r\n\t// If no document and documentElement is available, return\r\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\r\n\t\treturn document;\r\n\t}\r\n\r\n\t// Set our document\r\n\tdocument = doc;\r\n\tdocElem = doc.documentElement;\r\n\r\n\t// Support tests\r\n\tdocumentIsHTML = !isXML( doc );\r\n\r\n\t// Support: IE>8\r\n\t// If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\r\n\t// IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\r\n\t// IE6-8 do not support the defaultView property so parent will be undefined\r\n\tif ( parent && parent.attachEvent && parent !== parent.top ) {\r\n\t\tparent.attachEvent( \"onbeforeunload\", function() {\r\n\t\t\tsetDocument();\r\n\t\t});\r\n\t}\r\n\r\n\t/* Attributes\r\n\t---------------------------------------------------------------------- */\r\n\r\n\t// Support: IE<8\r\n\t// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)\r\n\tsupport.attributes = assert(function( div ) {\r\n\t\tdiv.className = \"i\";\r\n\t\treturn !div.getAttribute(\"className\");\r\n\t});\r\n\r\n\t/* getElement(s)By*\r\n\t---------------------------------------------------------------------- */\r\n\r\n\t// Check if getElementsByTagName(\"*\") returns only elements\r\n\tsupport.getElementsByTagName = assert(function( div ) {\r\n\t\tdiv.appendChild( doc.createComment(\"\") );\r\n\t\treturn !div.getElementsByTagName(\"*\").length;\r\n\t});\r\n\r\n\t// Check if getElementsByClassName can be trusted\r\n\tsupport.getElementsByClassName = assert(function( div ) {\r\n\t\tdiv.innerHTML = \"<div class='a'></div><div class='a i'></div>\";\r\n\r\n\t\t// Support: Safari<4\r\n\t\t// Catch class over-caching\r\n\t\tdiv.firstChild.className = \"i\";\r\n\t\t// Support: Opera<10\r\n\t\t// Catch gEBCN failure to find non-leading classes\r\n\t\treturn div.getElementsByClassName(\"i\").length === 2;\r\n\t});\r\n\r\n\t// Support: IE<10\r\n\t// Check if getElementById returns elements by name\r\n\t// The broken getElementById methods don't pick up programatically-set names,\r\n\t// so use a roundabout getElementsByName test\r\n\tsupport.getById = assert(function( div ) {\r\n\t\tdocElem.appendChild( div ).id = expando;\r\n\t\treturn !doc.getElementsByName || !doc.getElementsByName( expando ).length;\r\n\t});\r\n\r\n\t// ID find and filter\r\n\tif ( support.getById ) {\r\n\t\tExpr.find[\"ID\"] = function( id, context ) {\r\n\t\t\tif ( typeof context.getElementById !== strundefined && documentIsHTML ) {\r\n\t\t\t\tvar m = context.getElementById( id );\r\n\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\r\n\t\t\t\t// nodes that are no longer in the document #6963\r\n\t\t\t\treturn m && m.parentNode ? [m] : [];\r\n\t\t\t}\r\n\t\t};\r\n\t\tExpr.filter[\"ID\"] = function( id ) {\r\n\t\t\tvar attrId = id.replace( runescape, funescape );\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\r\n\t\t\t};\r\n\t\t};\r\n\t} else {\r\n\t\t// Support: IE6/7\r\n\t\t// getElementById is not reliable as a find shortcut\r\n\t\tdelete Expr.find[\"ID\"];\r\n\r\n\t\tExpr.filter[\"ID\"] =  function( id ) {\r\n\t\t\tvar attrId = id.replace( runescape, funescape );\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\tvar node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode(\"id\");\r\n\t\t\t\treturn node && node.value === attrId;\r\n\t\t\t};\r\n\t\t};\r\n\t}\r\n\r\n\t// Tag\r\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\r\n\t\tfunction( tag, context ) {\r\n\t\t\tif ( typeof context.getElementsByTagName !== strundefined ) {\r\n\t\t\t\treturn context.getElementsByTagName( tag );\r\n\t\t\t}\r\n\t\t} :\r\n\t\tfunction( tag, context ) {\r\n\t\t\tvar elem,\r\n\t\t\t\ttmp = [],\r\n\t\t\t\ti = 0,\r\n\t\t\t\tresults = context.getElementsByTagName( tag );\r\n\r\n\t\t\t// Filter out possible comments\r\n\t\t\tif ( tag === \"*\" ) {\r\n\t\t\t\twhile ( (elem = results[i++]) ) {\r\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\r\n\t\t\t\t\t\ttmp.push( elem );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn tmp;\r\n\t\t\t}\r\n\t\t\treturn results;\r\n\t\t};\r\n\r\n\t// Class\r\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\r\n\t\tif ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {\r\n\t\t\treturn context.getElementsByClassName( className );\r\n\t\t}\r\n\t};\r\n\r\n\t/* QSA/matchesSelector\r\n\t---------------------------------------------------------------------- */\r\n\r\n\t// QSA and matchesSelector support\r\n\r\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\r\n\trbuggyMatches = [];\r\n\r\n\t// qSa(:focus) reports false when true (Chrome 21)\r\n\t// We allow this because of a bug in IE8/9 that throws an error\r\n\t// whenever `document.activeElement` is accessed on an iframe\r\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\r\n\t// See http://bugs.jquery.com/ticket/13378\r\n\trbuggyQSA = [];\r\n\r\n\tif ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\r\n\t\t// Build QSA regex\r\n\t\t// Regex strategy adopted from Diego Perini\r\n\t\tassert(function( div ) {\r\n\t\t\t// Select is set to empty string on purpose\r\n\t\t\t// This is to test IE's treatment of not explicitly\r\n\t\t\t// setting a boolean content attribute,\r\n\t\t\t// since its presence should be enough\r\n\t\t\t// http://bugs.jquery.com/ticket/12359\r\n\t\t\tdiv.innerHTML = \"<select><option selected=''></option></select>\";\r\n\r\n\t\t\t// Support: IE8\r\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\r\n\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\r\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\r\n\t\t\t}\r\n\r\n\t\t\t// Webkit/Opera - :checked should return selected option elements\r\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\r\n\t\t\t// IE8 throws error here and will not see later tests\r\n\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\r\n\t\t\t\trbuggyQSA.push(\":checked\");\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tassert(function( div ) {\r\n\r\n\t\t\t// Support: Opera 10-12/IE8\r\n\t\t\t// ^= $= *= and empty values\r\n\t\t\t// Should not select anything\r\n\t\t\t// Support: Windows 8 Native Apps\r\n\t\t\t// The type attribute is restricted during .innerHTML assignment\r\n\t\t\tvar input = doc.createElement(\"input\");\r\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\r\n\t\t\tdiv.appendChild( input ).setAttribute( \"t\", \"\" );\r\n\r\n\t\t\tif ( div.querySelectorAll(\"[t^='']\").length ) {\r\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\r\n\t\t\t}\r\n\r\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\r\n\t\t\t// IE8 throws error here and will not see later tests\r\n\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\r\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\r\n\t\t\t}\r\n\r\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\r\n\t\t\tdiv.querySelectorAll(\"*,:x\");\r\n\t\t\trbuggyQSA.push(\",.*:\");\r\n\t\t});\r\n\t}\r\n\r\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||\r\n\t\tdocElem.mozMatchesSelector ||\r\n\t\tdocElem.oMatchesSelector ||\r\n\t\tdocElem.msMatchesSelector) )) ) {\r\n\r\n\t\tassert(function( div ) {\r\n\t\t\t// Check to see if it's possible to do matchesSelector\r\n\t\t\t// on a disconnected node (IE 9)\r\n\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\r\n\r\n\t\t\t// This should fail with an exception\r\n\t\t\t// Gecko does not error, returns false instead\r\n\t\t\tmatches.call( div, \"[s!='']:x\" );\r\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\r\n\t\t});\r\n\t}\r\n\r\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\r\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\r\n\r\n\t/* Contains\r\n\t---------------------------------------------------------------------- */\r\n\r\n\t// Element contains another\r\n\t// Purposefully does not implement inclusive descendent\r\n\t// As in, an element does not contain itself\r\n\tcontains = rnative.test( docElem.contains ) || docElem.compareDocumentPosition ?\r\n\t\tfunction( a, b ) {\r\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\r\n\t\t\t\tbup = b && b.parentNode;\r\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\r\n\t\t\t\tadown.contains ?\r\n\t\t\t\t\tadown.contains( bup ) :\r\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\r\n\t\t\t));\r\n\t\t} :\r\n\t\tfunction( a, b ) {\r\n\t\t\tif ( b ) {\r\n\t\t\t\twhile ( (b = b.parentNode) ) {\r\n\t\t\t\t\tif ( b === a ) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t};\r\n\r\n\t/* Sorting\r\n\t---------------------------------------------------------------------- */\r\n\r\n\t// Document order sorting\r\n\tsortOrder = docElem.compareDocumentPosition ?\r\n\tfunction( a, b ) {\r\n\r\n\t\t// Flag for duplicate removal\r\n\t\tif ( a === b ) {\r\n\t\t\thasDuplicate = true;\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tvar compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition( b );\r\n\r\n\t\tif ( compare ) {\r\n\t\t\t// Disconnected nodes\r\n\t\t\tif ( compare & 1 ||\r\n\t\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\r\n\r\n\t\t\t\t// Choose the first element that is related to our preferred document\r\n\t\t\t\tif ( a === doc || contains(preferredDoc, a) ) {\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\t}\r\n\t\t\t\tif ( b === doc || contains(preferredDoc, b) ) {\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Maintain original order\r\n\t\t\t\treturn sortInput ?\r\n\t\t\t\t\t( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\r\n\t\t\t\t\t0;\r\n\t\t\t}\r\n\r\n\t\t\treturn compare & 4 ? -1 : 1;\r\n\t\t}\r\n\r\n\t\t// Not directly comparable, sort on existence of method\r\n\t\treturn a.compareDocumentPosition ? -1 : 1;\r\n\t} :\r\n\tfunction( a, b ) {\r\n\t\tvar cur,\r\n\t\t\ti = 0,\r\n\t\t\taup = a.parentNode,\r\n\t\t\tbup = b.parentNode,\r\n\t\t\tap = [ a ],\r\n\t\t\tbp = [ b ];\r\n\r\n\t\t// Exit early if the nodes are identical\r\n\t\tif ( a === b ) {\r\n\t\t\thasDuplicate = true;\r\n\t\t\treturn 0;\r\n\r\n\t\t// Parentless nodes are either documents or disconnected\r\n\t\t} else if ( !aup || !bup ) {\r\n\t\t\treturn a === doc ? -1 :\r\n\t\t\t\tb === doc ? 1 :\r\n\t\t\t\taup ? -1 :\r\n\t\t\t\tbup ? 1 :\r\n\t\t\t\tsortInput ?\r\n\t\t\t\t( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\r\n\t\t\t\t0;\r\n\r\n\t\t// If the nodes are siblings, we can do a quick check\r\n\t\t} else if ( aup === bup ) {\r\n\t\t\treturn siblingCheck( a, b );\r\n\t\t}\r\n\r\n\t\t// Otherwise we need full lists of their ancestors for comparison\r\n\t\tcur = a;\r\n\t\twhile ( (cur = cur.parentNode) ) {\r\n\t\t\tap.unshift( cur );\r\n\t\t}\r\n\t\tcur = b;\r\n\t\twhile ( (cur = cur.parentNode) ) {\r\n\t\t\tbp.unshift( cur );\r\n\t\t}\r\n\r\n\t\t// Walk down the tree looking for a discrepancy\r\n\t\twhile ( ap[i] === bp[i] ) {\r\n\t\t\ti++;\r\n\t\t}\r\n\r\n\t\treturn i ?\r\n\t\t\t// Do a sibling check if the nodes have a common ancestor\r\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\r\n\r\n\t\t\t// Otherwise nodes in our document sort first\r\n\t\t\tap[i] === preferredDoc ? -1 :\r\n\t\t\tbp[i] === preferredDoc ? 1 :\r\n\t\t\t0;\r\n\t};\r\n\r\n\treturn doc;\r\n};\r\n\r\nSizzle.matches = function( expr, elements ) {\r\n\treturn Sizzle( expr, null, null, elements );\r\n};\r\n\r\nSizzle.matchesSelector = function( elem, expr ) {\r\n\t// Set document vars if needed\r\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\r\n\t\tsetDocument( elem );\r\n\t}\r\n\r\n\t// Make sure that attribute selectors are quoted\r\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\r\n\r\n\tif ( support.matchesSelector && documentIsHTML &&\r\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\r\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\r\n\r\n\t\ttry {\r\n\t\t\tvar ret = matches.call( elem, expr );\r\n\r\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\r\n\t\t\tif ( ret || support.disconnectedMatch ||\r\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\r\n\t\t\t\t\t// fragment in IE 9\r\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\r\n\t\t\t\treturn ret;\r\n\t\t\t}\r\n\t\t} catch(e) {}\r\n\t}\r\n\r\n\treturn Sizzle( expr, document, null, [elem] ).length > 0;\r\n};\r\n\r\nSizzle.contains = function( context, elem ) {\r\n\t// Set document vars if needed\r\n\tif ( ( context.ownerDocument || context ) !== document ) {\r\n\t\tsetDocument( context );\r\n\t}\r\n\treturn contains( context, elem );\r\n};\r\n\r\nSizzle.attr = function( elem, name ) {\r\n\t// Set document vars if needed\r\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\r\n\t\tsetDocument( elem );\r\n\t}\r\n\r\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\r\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\r\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\r\n\t\t\tfn( elem, name, !documentIsHTML ) :\r\n\t\t\tundefined;\r\n\r\n\treturn val === undefined ?\r\n\t\tsupport.attributes || !documentIsHTML ?\r\n\t\t\telem.getAttribute( name ) :\r\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\r\n\t\t\t\tval.value :\r\n\t\t\t\tnull :\r\n\t\tval;\r\n};\r\n\r\nSizzle.error = function( msg ) {\r\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\r\n};\r\n\r\n/**\r\n * Document sorting and removing duplicates\r\n * @param {ArrayLike} results\r\n */\r\nSizzle.uniqueSort = function( results ) {\r\n\tvar elem,\r\n\t\tduplicates = [],\r\n\t\tj = 0,\r\n\t\ti = 0;\r\n\r\n\t// Unless we *know* we can detect duplicates, assume their presence\r\n\thasDuplicate = !support.detectDuplicates;\r\n\tsortInput = !support.sortStable && results.slice( 0 );\r\n\tresults.sort( sortOrder );\r\n\r\n\tif ( hasDuplicate ) {\r\n\t\twhile ( (elem = results[i++]) ) {\r\n\t\t\tif ( elem === results[ i ] ) {\r\n\t\t\t\tj = duplicates.push( i );\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile ( j-- ) {\r\n\t\t\tresults.splice( duplicates[ j ], 1 );\r\n\t\t}\r\n\t}\r\n\r\n\treturn results;\r\n};\r\n\r\n/**\r\n * Utility function for retrieving the text value of an array of DOM nodes\r\n * @param {Array|Element} elem\r\n */\r\ngetText = Sizzle.getText = function( elem ) {\r\n\tvar node,\r\n\t\tret = \"\",\r\n\t\ti = 0,\r\n\t\tnodeType = elem.nodeType;\r\n\r\n\tif ( !nodeType ) {\r\n\t\t// If no nodeType, this is expected to be an array\r\n\t\tfor ( ; (node = elem[i]); i++ ) {\r\n\t\t\t// Do not traverse comment nodes\r\n\t\t\tret += getText( node );\r\n\t\t}\r\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\r\n\t\t// Use textContent for elements\r\n\t\t// innerText usage removed for consistency of new lines (see #11153)\r\n\t\tif ( typeof elem.textContent === \"string\" ) {\r\n\t\t\treturn elem.textContent;\r\n\t\t} else {\r\n\t\t\t// Traverse its children\r\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\r\n\t\t\t\tret += getText( elem );\r\n\t\t\t}\r\n\t\t}\r\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\r\n\t\treturn elem.nodeValue;\r\n\t}\r\n\t// Do not include comment or processing instruction nodes\r\n\r\n\treturn ret;\r\n};\r\n\r\nExpr = Sizzle.selectors = {\r\n\r\n\t// Can be adjusted by the user\r\n\tcacheLength: 50,\r\n\r\n\tcreatePseudo: markFunction,\r\n\r\n\tmatch: matchExpr,\r\n\r\n\tattrHandle: {},\r\n\r\n\tfind: {},\r\n\r\n\trelative: {\r\n\t\t\">\": { dir: \"parentNode\", first: true },\r\n\t\t\" \": { dir: \"parentNode\" },\r\n\t\t\"+\": { dir: \"previousSibling\", first: true },\r\n\t\t\"~\": { dir: \"previousSibling\" }\r\n\t},\r\n\r\n\tpreFilter: {\r\n\t\t\"ATTR\": function( match ) {\r\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\r\n\r\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\r\n\t\t\tmatch[3] = ( match[4] || match[5] || \"\" ).replace( runescape, funescape );\r\n\r\n\t\t\tif ( match[2] === \"~=\" ) {\r\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\r\n\t\t\t}\r\n\r\n\t\t\treturn match.slice( 0, 4 );\r\n\t\t},\r\n\r\n\t\t\"CHILD\": function( match ) {\r\n\t\t\t/* matches from matchExpr[\"CHILD\"]\r\n\t\t\t\t1 type (only|nth|...)\r\n\t\t\t\t2 what (child|of-type)\r\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\r\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\r\n\t\t\t\t5 sign of xn-component\r\n\t\t\t\t6 x of xn-component\r\n\t\t\t\t7 sign of y-component\r\n\t\t\t\t8 y of y-component\r\n\t\t\t*/\r\n\t\t\tmatch[1] = match[1].toLowerCase();\r\n\r\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\r\n\t\t\t\t// nth-* requires argument\r\n\t\t\t\tif ( !match[3] ) {\r\n\t\t\t\t\tSizzle.error( match[0] );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\r\n\t\t\t\t// remember that false/true cast respectively to 0/1\r\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\r\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\r\n\r\n\t\t\t// other types prohibit arguments\r\n\t\t\t} else if ( match[3] ) {\r\n\t\t\t\tSizzle.error( match[0] );\r\n\t\t\t}\r\n\r\n\t\t\treturn match;\r\n\t\t},\r\n\r\n\t\t\"PSEUDO\": function( match ) {\r\n\t\t\tvar excess,\r\n\t\t\t\tunquoted = !match[5] && match[2];\r\n\r\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\t// Accept quoted arguments as-is\r\n\t\t\tif ( match[3] && match[4] !== undefined ) {\r\n\t\t\t\tmatch[2] = match[4];\r\n\r\n\t\t\t// Strip excess characters from unquoted arguments\r\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\r\n\t\t\t\t// Get excess from tokenize (recursively)\r\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\r\n\t\t\t\t// advance to the next closing parenthesis\r\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\r\n\r\n\t\t\t\t// excess is a negative index\r\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\r\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\r\n\t\t\t}\r\n\r\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\r\n\t\t\treturn match.slice( 0, 3 );\r\n\t\t}\r\n\t},\r\n\r\n\tfilter: {\r\n\r\n\t\t\"TAG\": function( nodeNameSelector ) {\r\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\r\n\t\t\treturn nodeNameSelector === \"*\" ?\r\n\t\t\t\tfunction() { return true; } :\r\n\t\t\t\tfunction( elem ) {\r\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\r\n\t\t\t\t};\r\n\t\t},\r\n\r\n\t\t\"CLASS\": function( className ) {\r\n\t\t\tvar pattern = classCache[ className + \" \" ];\r\n\r\n\t\t\treturn pattern ||\r\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\r\n\t\t\t\tclassCache( className, function( elem ) {\r\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute(\"class\") || \"\" );\r\n\t\t\t\t});\r\n\t\t},\r\n\r\n\t\t\"ATTR\": function( name, operator, check ) {\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\tvar result = Sizzle.attr( elem, name );\r\n\r\n\t\t\t\tif ( result == null ) {\r\n\t\t\t\t\treturn operator === \"!=\";\r\n\t\t\t\t}\r\n\t\t\t\tif ( !operator ) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tresult += \"\";\r\n\r\n\t\t\t\treturn operator === \"=\" ? result === check :\r\n\t\t\t\t\toperator === \"!=\" ? result !== check :\r\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\r\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\r\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\r\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result + \" \" ).indexOf( check ) > -1 :\r\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\r\n\t\t\t\t\tfalse;\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\r\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\r\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\r\n\t\t\t\tofType = what === \"of-type\";\r\n\r\n\t\t\treturn first === 1 && last === 0 ?\r\n\r\n\t\t\t\t// Shortcut for :nth-*(n)\r\n\t\t\t\tfunction( elem ) {\r\n\t\t\t\t\treturn !!elem.parentNode;\r\n\t\t\t\t} :\r\n\r\n\t\t\t\tfunction( elem, context, xml ) {\r\n\t\t\t\t\tvar cache, outerCache, node, diff, nodeIndex, start,\r\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\r\n\t\t\t\t\t\tparent = elem.parentNode,\r\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\r\n\t\t\t\t\t\tuseCache = !xml && !ofType;\r\n\r\n\t\t\t\t\tif ( parent ) {\r\n\r\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\r\n\t\t\t\t\t\tif ( simple ) {\r\n\t\t\t\t\t\t\twhile ( dir ) {\r\n\t\t\t\t\t\t\t\tnode = elem;\r\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\r\n\t\t\t\t\t\t\t\t\tif ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\r\n\t\t\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\r\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\r\n\r\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\r\n\t\t\t\t\t\tif ( forward && useCache ) {\r\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\r\n\t\t\t\t\t\t\touterCache = parent[ expando ] || (parent[ expando ] = {});\r\n\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\r\n\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\r\n\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\r\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\r\n\r\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\r\n\r\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\r\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\r\n\r\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\r\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\r\n\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Use previously-cached element index if available\r\n\t\t\t\t\t\t} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\r\n\t\t\t\t\t\t\tdiff = cache[1];\r\n\r\n\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\r\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\r\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\r\n\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\r\n\t\t\t\t\t\t\t\t\tif ( useCache ) {\r\n\t\t\t\t\t\t\t\t\t\t(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tif ( node === elem ) {\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\r\n\t\t\t\t\t\tdiff -= last;\r\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t},\r\n\r\n\t\t\"PSEUDO\": function( pseudo, argument ) {\r\n\t\t\t// pseudo-class names are case-insensitive\r\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\r\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\r\n\t\t\t// Remember that setFilters inherits from pseudos\r\n\t\t\tvar args,\r\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\r\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\r\n\r\n\t\t\t// The user may use createPseudo to indicate that\r\n\t\t\t// arguments are needed to create the filter function\r\n\t\t\t// just as Sizzle does\r\n\t\t\tif ( fn[ expando ] ) {\r\n\t\t\t\treturn fn( argument );\r\n\t\t\t}\r\n\r\n\t\t\t// But maintain support for old signatures\r\n\t\t\tif ( fn.length > 1 ) {\r\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\r\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\r\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\r\n\t\t\t\t\t\tvar idx,\r\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\r\n\t\t\t\t\t\t\ti = matched.length;\r\n\t\t\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\t\t\tidx = indexOf.call( seed, matched[i] );\r\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}) :\r\n\t\t\t\t\tfunction( elem ) {\r\n\t\t\t\t\t\treturn fn( elem, 0, args );\r\n\t\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\treturn fn;\r\n\t\t}\r\n\t},\r\n\r\n\tpseudos: {\r\n\t\t// Potentially complex pseudos\r\n\t\t\"not\": markFunction(function( selector ) {\r\n\t\t\t// Trim the selector passed to compile\r\n\t\t\t// to avoid treating leading and trailing\r\n\t\t\t// spaces as combinators\r\n\t\t\tvar input = [],\r\n\t\t\t\tresults = [],\r\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\r\n\r\n\t\t\treturn matcher[ expando ] ?\r\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\r\n\t\t\t\t\tvar elem,\r\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\r\n\t\t\t\t\t\ti = seed.length;\r\n\r\n\t\t\t\t\t// Match elements unmatched by `matcher`\r\n\t\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\r\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}) :\r\n\t\t\t\tfunction( elem, context, xml ) {\r\n\t\t\t\t\tinput[0] = elem;\r\n\t\t\t\t\tmatcher( input, null, xml, results );\r\n\t\t\t\t\treturn !results.pop();\r\n\t\t\t\t};\r\n\t\t}),\r\n\r\n\t\t\"has\": markFunction(function( selector ) {\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\r\n\t\t\t};\r\n\t\t}),\r\n\r\n\t\t\"contains\": markFunction(function( text ) {\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\r\n\t\t\t};\r\n\t\t}),\r\n\r\n\t\t// \"Whether an element is represented by a :lang() selector\r\n\t\t// is based solely on the element's language value\r\n\t\t// being equal to the identifier C,\r\n\t\t// or beginning with the identifier C immediately followed by \"-\".\r\n\t\t// The matching of C against the element's language value is performed case-insensitively.\r\n\t\t// The identifier C does not have to be a valid language name.\"\r\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\r\n\t\t\"lang\": markFunction( function( lang ) {\r\n\t\t\t// lang value must be a valid identifier\r\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\r\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\r\n\t\t\t}\r\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\tvar elemLang;\r\n\t\t\t\tdo {\r\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\r\n\t\t\t\t\t\telem.lang :\r\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\r\n\r\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\r\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\r\n\t\t\t\treturn false;\r\n\t\t\t};\r\n\t\t}),\r\n\r\n\t\t// Miscellaneous\r\n\t\t\"target\": function( elem ) {\r\n\t\t\tvar hash = window.location && window.location.hash;\r\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\r\n\t\t},\r\n\r\n\t\t\"root\": function( elem ) {\r\n\t\t\treturn elem === docElem;\r\n\t\t},\r\n\r\n\t\t\"focus\": function( elem ) {\r\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\r\n\t\t},\r\n\r\n\t\t// Boolean properties\r\n\t\t\"enabled\": function( elem ) {\r\n\t\t\treturn elem.disabled === false;\r\n\t\t},\r\n\r\n\t\t\"disabled\": function( elem ) {\r\n\t\t\treturn elem.disabled === true;\r\n\t\t},\r\n\r\n\t\t\"checked\": function( elem ) {\r\n\t\t\t// In CSS3, :checked should return both checked and selected elements\r\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\r\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\r\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\r\n\t\t},\r\n\r\n\t\t\"selected\": function( elem ) {\r\n\t\t\t// Accessing this property makes selected-by-default\r\n\t\t\t// options in Safari work properly\r\n\t\t\tif ( elem.parentNode ) {\r\n\t\t\t\telem.parentNode.selectedIndex;\r\n\t\t\t}\r\n\r\n\t\t\treturn elem.selected === true;\r\n\t\t},\r\n\r\n\t\t// Contents\r\n\t\t\"empty\": function( elem ) {\r\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\r\n\t\t\t// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),\r\n\t\t\t//   not comment, processing instructions, or others\r\n\t\t\t// Thanks to Diego Perini for the nodeName shortcut\r\n\t\t\t//   Greater than \"@\" means alpha characters (specifically not starting with \"#\" or \"?\")\r\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\r\n\t\t\t\tif ( elem.nodeName > \"@\" || elem.nodeType === 3 || elem.nodeType === 4 ) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t\"parent\": function( elem ) {\r\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\r\n\t\t},\r\n\r\n\t\t// Element/input types\r\n\t\t\"header\": function( elem ) {\r\n\t\t\treturn rheader.test( elem.nodeName );\r\n\t\t},\r\n\r\n\t\t\"input\": function( elem ) {\r\n\t\t\treturn rinputs.test( elem.nodeName );\r\n\t\t},\r\n\r\n\t\t\"button\": function( elem ) {\r\n\t\t\tvar name = elem.nodeName.toLowerCase();\r\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\r\n\t\t},\r\n\r\n\t\t\"text\": function( elem ) {\r\n\t\t\tvar attr;\r\n\t\t\t// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)\r\n\t\t\t// use getAttribute instead to test this case\r\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\r\n\t\t\t\telem.type === \"text\" &&\r\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === elem.type );\r\n\t\t},\r\n\r\n\t\t// Position-in-collection\r\n\t\t\"first\": createPositionalPseudo(function() {\r\n\t\t\treturn [ 0 ];\r\n\t\t}),\r\n\r\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\r\n\t\t\treturn [ length - 1 ];\r\n\t\t}),\r\n\r\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\r\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\r\n\t\t}),\r\n\r\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\r\n\t\t\tvar i = 0;\r\n\t\t\tfor ( ; i < length; i += 2 ) {\r\n\t\t\t\tmatchIndexes.push( i );\r\n\t\t\t}\r\n\t\t\treturn matchIndexes;\r\n\t\t}),\r\n\r\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\r\n\t\t\tvar i = 1;\r\n\t\t\tfor ( ; i < length; i += 2 ) {\r\n\t\t\t\tmatchIndexes.push( i );\r\n\t\t\t}\r\n\t\t\treturn matchIndexes;\r\n\t\t}),\r\n\r\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\r\n\t\t\tvar i = argument < 0 ? argument + length : argument;\r\n\t\t\tfor ( ; --i >= 0; ) {\r\n\t\t\t\tmatchIndexes.push( i );\r\n\t\t\t}\r\n\t\t\treturn matchIndexes;\r\n\t\t}),\r\n\r\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\r\n\t\t\tvar i = argument < 0 ? argument + length : argument;\r\n\t\t\tfor ( ; ++i < length; ) {\r\n\t\t\t\tmatchIndexes.push( i );\r\n\t\t\t}\r\n\t\t\treturn matchIndexes;\r\n\t\t})\r\n\t}\r\n};\r\n\r\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\r\n\r\n// Add button/input type pseudos\r\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\r\n\tExpr.pseudos[ i ] = createInputPseudo( i );\r\n}\r\nfor ( i in { submit: true, reset: true } ) {\r\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\r\n}\r\n\r\n// Easy API for creating new setFilters\r\nfunction setFilters() {}\r\nsetFilters.prototype = Expr.filters = Expr.pseudos;\r\nExpr.setFilters = new setFilters();\r\n\r\nfunction tokenize( selector, parseOnly ) {\r\n\tvar matched, match, tokens, type,\r\n\t\tsoFar, groups, preFilters,\r\n\t\tcached = tokenCache[ selector + \" \" ];\r\n\r\n\tif ( cached ) {\r\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\r\n\t}\r\n\r\n\tsoFar = selector;\r\n\tgroups = [];\r\n\tpreFilters = Expr.preFilter;\r\n\r\n\twhile ( soFar ) {\r\n\r\n\t\t// Comma and first run\r\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\r\n\t\t\tif ( match ) {\r\n\t\t\t\t// Don't consume trailing commas as valid\r\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\r\n\t\t\t}\r\n\t\t\tgroups.push( tokens = [] );\r\n\t\t}\r\n\r\n\t\tmatched = false;\r\n\r\n\t\t// Combinators\r\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\r\n\t\t\tmatched = match.shift();\r\n\t\t\ttokens.push({\r\n\t\t\t\tvalue: matched,\r\n\t\t\t\t// Cast descendant combinators to space\r\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\r\n\t\t\t});\r\n\t\t\tsoFar = soFar.slice( matched.length );\r\n\t\t}\r\n\r\n\t\t// Filters\r\n\t\tfor ( type in Expr.filter ) {\r\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\r\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\r\n\t\t\t\tmatched = match.shift();\r\n\t\t\t\ttokens.push({\r\n\t\t\t\t\tvalue: matched,\r\n\t\t\t\t\ttype: type,\r\n\t\t\t\t\tmatches: match\r\n\t\t\t\t});\r\n\t\t\t\tsoFar = soFar.slice( matched.length );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( !matched ) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\t// Return the length of the invalid excess\r\n\t// if we're just parsing\r\n\t// Otherwise, throw an error or return tokens\r\n\treturn parseOnly ?\r\n\t\tsoFar.length :\r\n\t\tsoFar ?\r\n\t\t\tSizzle.error( selector ) :\r\n\t\t\t// Cache the tokens\r\n\t\t\ttokenCache( selector, groups ).slice( 0 );\r\n}\r\n\r\nfunction toSelector( tokens ) {\r\n\tvar i = 0,\r\n\t\tlen = tokens.length,\r\n\t\tselector = \"\";\r\n\tfor ( ; i < len; i++ ) {\r\n\t\tselector += tokens[i].value;\r\n\t}\r\n\treturn selector;\r\n}\r\n\r\nfunction addCombinator( matcher, combinator, base ) {\r\n\tvar dir = combinator.dir,\r\n\t\tcheckNonElements = base && dir === \"parentNode\",\r\n\t\tdoneName = done++;\r\n\r\n\treturn combinator.first ?\r\n\t\t// Check against closest ancestor/preceding element\r\n\t\tfunction( elem, context, xml ) {\r\n\t\t\twhile ( (elem = elem[ dir ]) ) {\r\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\r\n\t\t\t\t\treturn matcher( elem, context, xml );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} :\r\n\r\n\t\t// Check against all ancestor/preceding elements\r\n\t\tfunction( elem, context, xml ) {\r\n\t\t\tvar data, cache, outerCache,\r\n\t\t\t\tdirkey = dirruns + \" \" + doneName;\r\n\r\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\r\n\t\t\tif ( xml ) {\r\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\r\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\r\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\r\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\r\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\r\n\t\t\t\t\t\tif ( (cache = outerCache[ dir ]) && cache[0] === dirkey ) {\r\n\t\t\t\t\t\t\tif ( (data = cache[1]) === true || data === cachedruns ) {\r\n\t\t\t\t\t\t\t\treturn data === true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcache = outerCache[ dir ] = [ dirkey ];\r\n\t\t\t\t\t\t\tcache[1] = matcher( elem, context, xml ) || cachedruns;\r\n\t\t\t\t\t\t\tif ( cache[1] === true ) {\r\n\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n}\r\n\r\nfunction elementMatcher( matchers ) {\r\n\treturn matchers.length > 1 ?\r\n\t\tfunction( elem, context, xml ) {\r\n\t\t\tvar i = matchers.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t} :\r\n\t\tmatchers[0];\r\n}\r\n\r\nfunction condense( unmatched, map, filter, context, xml ) {\r\n\tvar elem,\r\n\t\tnewUnmatched = [],\r\n\t\ti = 0,\r\n\t\tlen = unmatched.length,\r\n\t\tmapped = map != null;\r\n\r\n\tfor ( ; i < len; i++ ) {\r\n\t\tif ( (elem = unmatched[i]) ) {\r\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\r\n\t\t\t\tnewUnmatched.push( elem );\r\n\t\t\t\tif ( mapped ) {\r\n\t\t\t\t\tmap.push( i );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn newUnmatched;\r\n}\r\n\r\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\r\n\tif ( postFilter && !postFilter[ expando ] ) {\r\n\t\tpostFilter = setMatcher( postFilter );\r\n\t}\r\n\tif ( postFinder && !postFinder[ expando ] ) {\r\n\t\tpostFinder = setMatcher( postFinder, postSelector );\r\n\t}\r\n\treturn markFunction(function( seed, results, context, xml ) {\r\n\t\tvar temp, i, elem,\r\n\t\t\tpreMap = [],\r\n\t\t\tpostMap = [],\r\n\t\t\tpreexisting = results.length,\r\n\r\n\t\t\t// Get initial elements from seed or context\r\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\r\n\r\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\r\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\r\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\r\n\t\t\t\telems,\r\n\r\n\t\t\tmatcherOut = matcher ?\r\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\r\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\r\n\r\n\t\t\t\t\t// ...intermediate processing is necessary\r\n\t\t\t\t\t[] :\r\n\r\n\t\t\t\t\t// ...otherwise use results directly\r\n\t\t\t\t\tresults :\r\n\t\t\t\tmatcherIn;\r\n\r\n\t\t// Find primary matches\r\n\t\tif ( matcher ) {\r\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\r\n\t\t}\r\n\r\n\t\t// Apply postFilter\r\n\t\tif ( postFilter ) {\r\n\t\t\ttemp = condense( matcherOut, postMap );\r\n\t\t\tpostFilter( temp, [], context, xml );\r\n\r\n\t\t\t// Un-match failing elements by moving them back to matcherIn\r\n\t\t\ti = temp.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tif ( (elem = temp[i]) ) {\r\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( seed ) {\r\n\t\t\tif ( postFinder || preFilter ) {\r\n\t\t\t\tif ( postFinder ) {\r\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\r\n\t\t\t\t\ttemp = [];\r\n\t\t\t\t\ti = matcherOut.length;\r\n\t\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\r\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\r\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\r\n\t\t\t\ti = matcherOut.length;\r\n\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\r\n\t\t\t\t\t\t(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {\r\n\r\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t// Add elements to results, through postFinder if defined\r\n\t\t} else {\r\n\t\t\tmatcherOut = condense(\r\n\t\t\t\tmatcherOut === results ?\r\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\r\n\t\t\t\t\tmatcherOut\r\n\t\t\t);\r\n\t\t\tif ( postFinder ) {\r\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\r\n\t\t\t} else {\r\n\t\t\t\tpush.apply( results, matcherOut );\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n}\r\n\r\nfunction matcherFromTokens( tokens ) {\r\n\tvar checkContext, matcher, j,\r\n\t\tlen = tokens.length,\r\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\r\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\r\n\t\ti = leadingRelative ? 1 : 0,\r\n\r\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\r\n\t\tmatchContext = addCombinator( function( elem ) {\r\n\t\t\treturn elem === checkContext;\r\n\t\t}, implicitRelative, true ),\r\n\t\tmatchAnyContext = addCombinator( function( elem ) {\r\n\t\t\treturn indexOf.call( checkContext, elem ) > -1;\r\n\t\t}, implicitRelative, true ),\r\n\t\tmatchers = [ function( elem, context, xml ) {\r\n\t\t\treturn ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\r\n\t\t\t\t(checkContext = context).nodeType ?\r\n\t\t\t\t\tmatchContext( elem, context, xml ) :\r\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\r\n\t\t} ];\r\n\r\n\tfor ( ; i < len; i++ ) {\r\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\r\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\r\n\t\t} else {\r\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\r\n\r\n\t\t\t// Return special upon seeing a positional matcher\r\n\t\t\tif ( matcher[ expando ] ) {\r\n\t\t\t\t// Find the next relative operator (if any) for proper handling\r\n\t\t\t\tj = ++i;\r\n\t\t\t\tfor ( ; j < len; j++ ) {\r\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn setMatcher(\r\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\r\n\t\t\t\t\ti > 1 && toSelector(\r\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\r\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\r\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\r\n\t\t\t\t\tmatcher,\r\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\r\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\r\n\t\t\t\t\tj < len && toSelector( tokens )\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tmatchers.push( matcher );\r\n\t\t}\r\n\t}\r\n\r\n\treturn elementMatcher( matchers );\r\n}\r\n\r\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\r\n\t// A counter to specify which element is currently being matched\r\n\tvar matcherCachedRuns = 0,\r\n\t\tbySet = setMatchers.length > 0,\r\n\t\tbyElement = elementMatchers.length > 0,\r\n\t\tsuperMatcher = function( seed, context, xml, results, expandContext ) {\r\n\t\t\tvar elem, j, matcher,\r\n\t\t\t\tsetMatched = [],\r\n\t\t\t\tmatchedCount = 0,\r\n\t\t\t\ti = \"0\",\r\n\t\t\t\tunmatched = seed && [],\r\n\t\t\t\toutermost = expandContext != null,\r\n\t\t\t\tcontextBackup = outermostContext,\r\n\t\t\t\t// We must always have either seed elements or context\r\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", expandContext && context.parentNode || context ),\r\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\r\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);\r\n\r\n\t\t\tif ( outermost ) {\r\n\t\t\t\toutermostContext = context !== document && context;\r\n\t\t\t\tcachedruns = matcherCachedRuns;\r\n\t\t\t}\r\n\r\n\t\t\t// Add elements passing elementMatchers directly to results\r\n\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\r\n\t\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\r\n\t\t\t\tif ( byElement && elem ) {\r\n\t\t\t\t\tj = 0;\r\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\r\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\r\n\t\t\t\t\t\t\tresults.push( elem );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( outermost ) {\r\n\t\t\t\t\t\tdirruns = dirrunsUnique;\r\n\t\t\t\t\t\tcachedruns = ++matcherCachedRuns;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Track unmatched elements for set filters\r\n\t\t\t\tif ( bySet ) {\r\n\t\t\t\t\t// They will have gone through all possible matchers\r\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\r\n\t\t\t\t\t\tmatchedCount--;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Lengthen the array for every element, matched or not\r\n\t\t\t\t\tif ( seed ) {\r\n\t\t\t\t\t\tunmatched.push( elem );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Apply set filters to unmatched elements\r\n\t\t\tmatchedCount += i;\r\n\t\t\tif ( bySet && i !== matchedCount ) {\r\n\t\t\t\tj = 0;\r\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\r\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( seed ) {\r\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\r\n\t\t\t\t\tif ( matchedCount > 0 ) {\r\n\t\t\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\r\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\r\n\t\t\t\t\tsetMatched = condense( setMatched );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Add matches to results\r\n\t\t\t\tpush.apply( results, setMatched );\r\n\r\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\r\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\r\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\r\n\r\n\t\t\t\t\tSizzle.uniqueSort( results );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Override manipulation of globals by nested matchers\r\n\t\t\tif ( outermost ) {\r\n\t\t\t\tdirruns = dirrunsUnique;\r\n\t\t\t\toutermostContext = contextBackup;\r\n\t\t\t}\r\n\r\n\t\t\treturn unmatched;\r\n\t\t};\r\n\r\n\treturn bySet ?\r\n\t\tmarkFunction( superMatcher ) :\r\n\t\tsuperMatcher;\r\n}\r\n\r\ncompile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {\r\n\tvar i,\r\n\t\tsetMatchers = [],\r\n\t\telementMatchers = [],\r\n\t\tcached = compilerCache[ selector + \" \" ];\r\n\r\n\tif ( !cached ) {\r\n\t\t// Generate a function of recursive functions that can be used to check each element\r\n\t\tif ( !group ) {\r\n\t\t\tgroup = tokenize( selector );\r\n\t\t}\r\n\t\ti = group.length;\r\n\t\twhile ( i-- ) {\r\n\t\t\tcached = matcherFromTokens( group[i] );\r\n\t\t\tif ( cached[ expando ] ) {\r\n\t\t\t\tsetMatchers.push( cached );\r\n\t\t\t} else {\r\n\t\t\t\telementMatchers.push( cached );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Cache the compiled function\r\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\r\n\t}\r\n\treturn cached;\r\n};\r\n\r\nfunction multipleContexts( selector, contexts, results ) {\r\n\tvar i = 0,\r\n\t\tlen = contexts.length;\r\n\tfor ( ; i < len; i++ ) {\r\n\t\tSizzle( selector, contexts[i], results );\r\n\t}\r\n\treturn results;\r\n}\r\n\r\nfunction select( selector, context, results, seed ) {\r\n\tvar i, tokens, token, type, find,\r\n\t\tmatch = tokenize( selector );\r\n\r\n\tif ( !seed ) {\r\n\t\t// Try to minimize operations if there is only one group\r\n\t\tif ( match.length === 1 ) {\r\n\r\n\t\t\t// Take a shortcut and set the context if the root selector is an ID\r\n\t\t\ttokens = match[0] = match[0].slice( 0 );\r\n\t\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\r\n\t\t\t\t\tsupport.getById && context.nodeType === 9 && documentIsHTML &&\r\n\t\t\t\t\tExpr.relative[ tokens[1].type ] ) {\r\n\r\n\t\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\r\n\t\t\t\tif ( !context ) {\r\n\t\t\t\t\treturn results;\r\n\t\t\t\t}\r\n\t\t\t\tselector = selector.slice( tokens.shift().value.length );\r\n\t\t\t}\r\n\r\n\t\t\t// Fetch a seed set for right-to-left matching\r\n\t\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\ttoken = tokens[i];\r\n\r\n\t\t\t\t// Abort if we hit a combinator\r\n\t\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif ( (find = Expr.find[ type ]) ) {\r\n\t\t\t\t\t// Search, expanding context for leading sibling combinators\r\n\t\t\t\t\tif ( (seed = find(\r\n\t\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\r\n\t\t\t\t\t\trsibling.test( tokens[0].type ) && context.parentNode || context\r\n\t\t\t\t\t)) ) {\r\n\r\n\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\r\n\t\t\t\t\t\ttokens.splice( i, 1 );\r\n\t\t\t\t\t\tselector = seed.length && toSelector( tokens );\r\n\t\t\t\t\t\tif ( !selector ) {\r\n\t\t\t\t\t\t\tpush.apply( results, seed );\r\n\t\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Compile and execute a filtering function\r\n\t// Provide `match` to avoid retokenization if we modified the selector above\r\n\tcompile( selector, match )(\r\n\t\tseed,\r\n\t\tcontext,\r\n\t\t!documentIsHTML,\r\n\t\tresults,\r\n\t\trsibling.test( selector )\r\n\t);\r\n\treturn results;\r\n}\r\n\r\n// One-time assignments\r\n\r\n// Sort stability\r\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\r\n\r\n// Support: Chrome<14\r\n// Always assume duplicates if they aren't passed to the comparison function\r\nsupport.detectDuplicates = hasDuplicate;\r\n\r\n// Initialize against the default document\r\nsetDocument();\r\n\r\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\r\n// Detached nodes confoundingly follow *each other*\r\nsupport.sortDetached = assert(function( div1 ) {\r\n\t// Should return 1, but returns 4 (following)\r\n\treturn div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\r\n});\r\n\r\n// Support: IE<8\r\n// Prevent attribute/property \"interpolation\"\r\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\r\nif ( !assert(function( div ) {\r\n\tdiv.innerHTML = \"<a href='#'></a>\";\r\n\treturn div.firstChild.getAttribute(\"href\") === \"#\" ;\r\n}) ) {\r\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\r\n\t\tif ( !isXML ) {\r\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\r\n\t\t}\r\n\t});\r\n}\r\n\r\n// Support: IE<9\r\n// Use defaultValue in place of getAttribute(\"value\")\r\nif ( !support.attributes || !assert(function( div ) {\r\n\tdiv.innerHTML = \"<input/>\";\r\n\tdiv.firstChild.setAttribute( \"value\", \"\" );\r\n\treturn div.firstChild.getAttribute( \"value\" ) === \"\";\r\n}) ) {\r\n\taddHandle( \"value\", function( elem, name, isXML ) {\r\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\r\n\t\t\treturn elem.defaultValue;\r\n\t\t}\r\n\t});\r\n}\r\n\r\n// Support: IE<9\r\n// Use getAttributeNode to fetch booleans when getAttribute lies\r\nif ( !assert(function( div ) {\r\n\treturn div.getAttribute(\"disabled\") == null;\r\n}) ) {\r\n\taddHandle( booleans, function( elem, name, isXML ) {\r\n\t\tvar val;\r\n\t\tif ( !isXML ) {\r\n\t\t\treturn (val = elem.getAttributeNode( name )) && val.specified ?\r\n\t\t\t\tval.value :\r\n\t\t\t\telem[ name ] === true ? name.toLowerCase() : null;\r\n\t\t}\r\n\t});\r\n}\r\n\r\njQuery.find = Sizzle;\r\njQuery.expr = Sizzle.selectors;\r\njQuery.expr[\":\"] = jQuery.expr.pseudos;\r\njQuery.unique = Sizzle.uniqueSort;\r\njQuery.text = Sizzle.getText;\r\njQuery.isXMLDoc = Sizzle.isXML;\r\njQuery.contains = Sizzle.contains;\r\n\r\n\r\n})( window );\r\n// String to Object options format cache\r\nvar optionsCache = {};\r\n\r\n// Convert String-formatted options into Object-formatted ones and store in cache\r\nfunction createOptions( options ) {\r\n\tvar object = optionsCache[ options ] = {};\r\n\tjQuery.each( options.match( core_rnotwhite ) || [], function( _, flag ) {\r\n\t\tobject[ flag ] = true;\r\n\t});\r\n\treturn object;\r\n}\r\n\r\n/*\r\n * Create a callback list using the following parameters:\r\n *\r\n *\toptions: an optional list of space-separated options that will change how\r\n *\t\t\tthe callback list behaves or a more traditional option object\r\n *\r\n * By default a callback list will act like an event callback list and can be\r\n * \"fired\" multiple times.\r\n *\r\n * Possible options:\r\n *\r\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\r\n *\r\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\r\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\r\n *\t\t\t\t\tvalues (like a Deferred)\r\n *\r\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\r\n *\r\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\r\n *\r\n */\r\njQuery.Callbacks = function( options ) {\r\n\r\n\t// Convert options from String-formatted to Object-formatted if needed\r\n\t// (we check in cache first)\r\n\toptions = typeof options === \"string\" ?\r\n\t\t( optionsCache[ options ] || createOptions( options ) ) :\r\n\t\tjQuery.extend( {}, options );\r\n\r\n\tvar // Last fire value (for non-forgettable lists)\r\n\t\tmemory,\r\n\t\t// Flag to know if list was already fired\r\n\t\tfired,\r\n\t\t// Flag to know if list is currently firing\r\n\t\tfiring,\r\n\t\t// First callback to fire (used internally by add and fireWith)\r\n\t\tfiringStart,\r\n\t\t// End of the loop when firing\r\n\t\tfiringLength,\r\n\t\t// Index of currently firing callback (modified by remove if needed)\r\n\t\tfiringIndex,\r\n\t\t// Actual callback list\r\n\t\tlist = [],\r\n\t\t// Stack of fire calls for repeatable lists\r\n\t\tstack = !options.once && [],\r\n\t\t// Fire callbacks\r\n\t\tfire = function( data ) {\r\n\t\t\tmemory = options.memory && data;\r\n\t\t\tfired = true;\r\n\t\t\tfiringIndex = firingStart || 0;\r\n\t\t\tfiringStart = 0;\r\n\t\t\tfiringLength = list.length;\r\n\t\t\tfiring = true;\r\n\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\r\n\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\r\n\t\t\t\t\tmemory = false; // To prevent further calls using add\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfiring = false;\r\n\t\t\tif ( list ) {\r\n\t\t\t\tif ( stack ) {\r\n\t\t\t\t\tif ( stack.length ) {\r\n\t\t\t\t\t\tfire( stack.shift() );\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if ( memory ) {\r\n\t\t\t\t\tlist = [];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tself.disable();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t// Actual Callbacks object\r\n\t\tself = {\r\n\t\t\t// Add a callback or a collection of callbacks to the list\r\n\t\t\tadd: function() {\r\n\t\t\t\tif ( list ) {\r\n\t\t\t\t\t// First, we save the current length\r\n\t\t\t\t\tvar start = list.length;\r\n\t\t\t\t\t(function add( args ) {\r\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\r\n\t\t\t\t\t\t\tvar type = jQuery.type( arg );\r\n\t\t\t\t\t\t\tif ( type === \"function\" ) {\r\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\r\n\t\t\t\t\t\t\t\t\tlist.push( arg );\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\r\n\t\t\t\t\t\t\t\t// Inspect recursively\r\n\t\t\t\t\t\t\t\tadd( arg );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t})( arguments );\r\n\t\t\t\t\t// Do we need to add the callbacks to the\r\n\t\t\t\t\t// current firing batch?\r\n\t\t\t\t\tif ( firing ) {\r\n\t\t\t\t\t\tfiringLength = list.length;\r\n\t\t\t\t\t// With memory, if we're not firing then\r\n\t\t\t\t\t// we should call right away\r\n\t\t\t\t\t} else if ( memory ) {\r\n\t\t\t\t\t\tfiringStart = start;\r\n\t\t\t\t\t\tfire( memory );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\t// Remove a callback from the list\r\n\t\t\tremove: function() {\r\n\t\t\t\tif ( list ) {\r\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\r\n\t\t\t\t\t\tvar index;\r\n\t\t\t\t\t\twhile( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\r\n\t\t\t\t\t\t\tlist.splice( index, 1 );\r\n\t\t\t\t\t\t\t// Handle firing indexes\r\n\t\t\t\t\t\t\tif ( firing ) {\r\n\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\r\n\t\t\t\t\t\t\t\t\tfiringLength--;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\r\n\t\t\t\t\t\t\t\t\tfiringIndex--;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\t// Check if a given callback is in the list.\r\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\r\n\t\t\thas: function( fn ) {\r\n\t\t\t\treturn fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\r\n\t\t\t},\r\n\t\t\t// Remove all callbacks from the list\r\n\t\t\tempty: function() {\r\n\t\t\t\tlist = [];\r\n\t\t\t\tfiringLength = 0;\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\t// Have the list do nothing anymore\r\n\t\t\tdisable: function() {\r\n\t\t\t\tlist = stack = memory = undefined;\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\t// Is it disabled?\r\n\t\t\tdisabled: function() {\r\n\t\t\t\treturn !list;\r\n\t\t\t},\r\n\t\t\t// Lock the list in its current state\r\n\t\t\tlock: function() {\r\n\t\t\t\tstack = undefined;\r\n\t\t\t\tif ( !memory ) {\r\n\t\t\t\t\tself.disable();\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\t// Is it locked?\r\n\t\t\tlocked: function() {\r\n\t\t\t\treturn !stack;\r\n\t\t\t},\r\n\t\t\t// Call all callbacks with the given context and arguments\r\n\t\t\tfireWith: function( context, args ) {\r\n\t\t\t\tif ( list && ( !fired || stack ) ) {\r\n\t\t\t\t\targs = args || [];\r\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\r\n\t\t\t\t\tif ( firing ) {\r\n\t\t\t\t\t\tstack.push( args );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfire( args );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\t// Call all the callbacks with the given arguments\r\n\t\t\tfire: function() {\r\n\t\t\t\tself.fireWith( this, arguments );\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\t// To know if the callbacks have already been called at least once\r\n\t\t\tfired: function() {\r\n\t\t\t\treturn !!fired;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\treturn self;\r\n};\r\njQuery.extend({\r\n\r\n\tDeferred: function( func ) {\r\n\t\tvar tuples = [\r\n\t\t\t\t// action, add listener, listener list, final state\r\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\r\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\r\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\r\n\t\t\t],\r\n\t\t\tstate = \"pending\",\r\n\t\t\tpromise = {\r\n\t\t\t\tstate: function() {\r\n\t\t\t\t\treturn state;\r\n\t\t\t\t},\r\n\t\t\t\talways: function() {\r\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t},\r\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\r\n\t\t\t\t\tvar fns = arguments;\r\n\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\r\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\r\n\t\t\t\t\t\t\tvar action = tuple[ 0 ],\r\n\t\t\t\t\t\t\t\tfn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\r\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\r\n\t\t\t\t\t\t\tdeferred[ tuple[1] ](function() {\r\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\r\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\r\n\t\t\t\t\t\t\t\t\treturned.promise()\r\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\r\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\r\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tnewDefer[ action + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tfns = null;\r\n\t\t\t\t\t}).promise();\r\n\t\t\t\t},\r\n\t\t\t\t// Get a promise for this deferred\r\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\r\n\t\t\t\tpromise: function( obj ) {\r\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tdeferred = {};\r\n\r\n\t\t// Keep pipe for back-compat\r\n\t\tpromise.pipe = promise.then;\r\n\r\n\t\t// Add list-specific methods\r\n\t\tjQuery.each( tuples, function( i, tuple ) {\r\n\t\t\tvar list = tuple[ 2 ],\r\n\t\t\t\tstateString = tuple[ 3 ];\r\n\r\n\t\t\t// promise[ done | fail | progress ] = list.add\r\n\t\t\tpromise[ tuple[1] ] = list.add;\r\n\r\n\t\t\t// Handle state\r\n\t\t\tif ( stateString ) {\r\n\t\t\t\tlist.add(function() {\r\n\t\t\t\t\t// state = [ resolved | rejected ]\r\n\t\t\t\t\tstate = stateString;\r\n\r\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\r\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\r\n\t\t\t}\r\n\r\n\t\t\t// deferred[ resolve | reject | notify ]\r\n\t\t\tdeferred[ tuple[0] ] = function() {\r\n\t\t\t\tdeferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\r\n\t\t});\r\n\r\n\t\t// Make the deferred a promise\r\n\t\tpromise.promise( deferred );\r\n\r\n\t\t// Call given func if any\r\n\t\tif ( func ) {\r\n\t\t\tfunc.call( deferred, deferred );\r\n\t\t}\r\n\r\n\t\t// All done!\r\n\t\treturn deferred;\r\n\t},\r\n\r\n\t// Deferred helper\r\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\r\n\t\tvar i = 0,\r\n\t\t\tresolveValues = core_slice.call( arguments ),\r\n\t\t\tlength = resolveValues.length,\r\n\r\n\t\t\t// the count of uncompleted subordinates\r\n\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\r\n\r\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\r\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\r\n\r\n\t\t\t// Update function for both resolve and progress values\r\n\t\t\tupdateFunc = function( i, contexts, values ) {\r\n\t\t\t\treturn function( value ) {\r\n\t\t\t\t\tcontexts[ i ] = this;\r\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;\r\n\t\t\t\t\tif( values === progressValues ) {\r\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\r\n\t\t\t\t\t} else if ( !( --remaining ) ) {\r\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t},\r\n\r\n\t\t\tprogressValues, progressContexts, resolveContexts;\r\n\r\n\t\t// add listeners to Deferred subordinates; treat others as resolved\r\n\t\tif ( length > 1 ) {\r\n\t\t\tprogressValues = new Array( length );\r\n\t\t\tprogressContexts = new Array( length );\r\n\t\t\tresolveContexts = new Array( length );\r\n\t\t\tfor ( ; i < length; i++ ) {\r\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\r\n\t\t\t\t\tresolveValues[ i ].promise()\r\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\r\n\t\t\t\t\t\t.fail( deferred.reject )\r\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\r\n\t\t\t\t} else {\r\n\t\t\t\t\t--remaining;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// if we're not waiting on anything, resolve the master\r\n\t\tif ( !remaining ) {\r\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\r\n\t\t}\r\n\r\n\t\treturn deferred.promise();\r\n\t}\r\n});\r\njQuery.support = (function( support ) {\r\n\tvar input = document.createElement(\"input\"),\r\n\t\tfragment = document.createDocumentFragment(),\r\n\t\tdiv = document.createElement(\"div\"),\r\n\t\tselect = document.createElement(\"select\"),\r\n\t\topt = select.appendChild( document.createElement(\"option\") );\r\n\r\n\t// Finish early in limited environments\r\n\tif ( !input.type ) {\r\n\t\treturn support;\r\n\t}\r\n\r\n\tinput.type = \"checkbox\";\r\n\r\n\t// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3\r\n\t// Check the default checkbox/radio value (\"\" on old WebKit; \"on\" elsewhere)\r\n\tsupport.checkOn = input.value !== \"\";\r\n\r\n\t// Must access the parent to make an option select properly\r\n\t// Support: IE9, IE10\r\n\tsupport.optSelected = opt.selected;\r\n\r\n\t// Will be defined later\r\n\tsupport.reliableMarginRight = true;\r\n\tsupport.boxSizingReliable = true;\r\n\tsupport.pixelPosition = false;\r\n\r\n\t// Make sure checked status is properly cloned\r\n\t// Support: IE9, IE10\r\n\tinput.checked = true;\r\n\tsupport.noCloneChecked = input.cloneNode( true ).checked;\r\n\r\n\t// Make sure that the options inside disabled selects aren't marked as disabled\r\n\t// (WebKit marks them as disabled)\r\n\tselect.disabled = true;\r\n\tsupport.optDisabled = !opt.disabled;\r\n\r\n\t// Check if an input maintains its value after becoming a radio\r\n\t// Support: IE9, IE10\r\n\tinput = document.createElement(\"input\");\r\n\tinput.value = \"t\";\r\n\tinput.type = \"radio\";\r\n\tsupport.radioValue = input.value === \"t\";\r\n\r\n\t// #11217 - WebKit loses check when the name is after the checked attribute\r\n\tinput.setAttribute( \"checked\", \"t\" );\r\n\tinput.setAttribute( \"name\", \"t\" );\r\n\r\n\tfragment.appendChild( input );\r\n\r\n\t// Support: Safari 5.1, Android 4.x, Android 2.3\r\n\t// old WebKit doesn't clone checked state correctly in fragments\r\n\tsupport.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;\r\n\r\n\t// Support: Firefox, Chrome, Safari\r\n\t// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)\r\n\tsupport.focusinBubbles = \"onfocusin\" in window;\r\n\r\n\tdiv.style.backgroundClip = \"content-box\";\r\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\r\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\r\n\r\n\t// Run tests that need a body at doc ready\r\n\tjQuery(function() {\r\n\t\tvar container, marginDiv,\r\n\t\t\t// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).\r\n\t\t\tdivReset = \"padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box\",\r\n\t\t\tbody = document.getElementsByTagName(\"body\")[ 0 ];\r\n\r\n\t\tif ( !body ) {\r\n\t\t\t// Return for frameset docs that don't have a body\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tcontainer = document.createElement(\"div\");\r\n\t\tcontainer.style.cssText = \"border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px\";\r\n\r\n\t\t// Check box-sizing and margin behavior.\r\n\t\tbody.appendChild( container ).appendChild( div );\r\n\t\tdiv.innerHTML = \"\";\r\n\t\t// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).\r\n\t\tdiv.style.cssText = \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%\";\r\n\r\n\t\t// Workaround failing boxSizing test due to offsetWidth returning wrong value\r\n\t\t// with some non-1 values of body zoom, ticket #13543\r\n\t\tjQuery.swap( body, body.style.zoom != null ? { zoom: 1 } : {}, function() {\r\n\t\t\tsupport.boxSizing = div.offsetWidth === 4;\r\n\t\t});\r\n\r\n\t\t// Use window.getComputedStyle because jsdom on node.js will break without it.\r\n\t\tif ( window.getComputedStyle ) {\r\n\t\t\tsupport.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== \"1%\";\r\n\t\t\tsupport.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: \"4px\" } ).width === \"4px\";\r\n\r\n\t\t\t// Support: Android 2.3\r\n\t\t\t// Check if div with explicit width and no margin-right incorrectly\r\n\t\t\t// gets computed margin-right based on width of container. (#3333)\r\n\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\r\n\t\t\tmarginDiv = div.appendChild( document.createElement(\"div\") );\r\n\t\t\tmarginDiv.style.cssText = div.style.cssText = divReset;\r\n\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = \"0\";\r\n\t\t\tdiv.style.width = \"1px\";\r\n\r\n\t\t\tsupport.reliableMarginRight =\r\n\t\t\t\t!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );\r\n\t\t}\r\n\r\n\t\tbody.removeChild( container );\r\n\t});\r\n\r\n\treturn support;\r\n})( {} );\r\n\r\n/*\r\n\tImplementation Summary\r\n\r\n\t1. Enforce API surface and semantic compatibility with 1.9.x branch\r\n\t2. Improve the module's maintainability by reducing the storage\r\n\t\tpaths to a single mechanism.\r\n\t3. Use the same single mechanism to support \"private\" and \"user\" data.\r\n\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\r\n\t5. Avoid exposing implementation details on user objects (eg. expando properties)\r\n\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\r\n*/\r\nvar data_user, data_priv,\r\n\trbrace = /(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/,\r\n\trmultiDash = /([A-Z])/g;\r\n\r\nfunction Data() {\r\n\t// Support: Android < 4,\r\n\t// Old WebKit does not have Object.preventExtensions/freeze method,\r\n\t// return new empty object instead with no [[set]] accessor\r\n\tObject.defineProperty( this.cache = {}, 0, {\r\n\t\tget: function() {\r\n\t\t\treturn {};\r\n\t\t}\r\n\t});\r\n\r\n\tthis.expando = jQuery.expando + Math.random();\r\n}\r\n\r\nData.uid = 1;\r\n\r\nData.accepts = function( owner ) {\r\n\t// Accepts only:\r\n\t//  - Node\r\n\t//    - Node.ELEMENT_NODE\r\n\t//    - Node.DOCUMENT_NODE\r\n\t//  - Object\r\n\t//    - Any\r\n\treturn owner.nodeType ?\r\n\t\towner.nodeType === 1 || owner.nodeType === 9 : true;\r\n};\r\n\r\nData.prototype = {\r\n\tkey: function( owner ) {\r\n\t\t// We can accept data for non-element nodes in modern browsers,\r\n\t\t// but we should not, see #8335.\r\n\t\t// Always return the key for a frozen object.\r\n\t\tif ( !Data.accepts( owner ) ) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tvar descriptor = {},\r\n\t\t\t// Check if the owner object already has a cache key\r\n\t\t\tunlock = owner[ this.expando ];\r\n\r\n\t\t// If not, create one\r\n\t\tif ( !unlock ) {\r\n\t\t\tunlock = Data.uid++;\r\n\r\n\t\t\t// Secure it in a non-enumerable, non-writable property\r\n\t\t\ttry {\r\n\t\t\t\tdescriptor[ this.expando ] = { value: unlock };\r\n\t\t\t\tObject.defineProperties( owner, descriptor );\r\n\r\n\t\t\t// Support: Android < 4\r\n\t\t\t// Fallback to a less secure definition\r\n\t\t\t} catch ( e ) {\r\n\t\t\t\tdescriptor[ this.expando ] = unlock;\r\n\t\t\t\tjQuery.extend( owner, descriptor );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Ensure the cache object\r\n\t\tif ( !this.cache[ unlock ] ) {\r\n\t\t\tthis.cache[ unlock ] = {};\r\n\t\t}\r\n\r\n\t\treturn unlock;\r\n\t},\r\n\tset: function( owner, data, value ) {\r\n\t\tvar prop,\r\n\t\t\t// There may be an unlock assigned to this node,\r\n\t\t\t// if there is no entry for this \"owner\", create one inline\r\n\t\t\t// and set the unlock as though an owner entry had always existed\r\n\t\t\tunlock = this.key( owner ),\r\n\t\t\tcache = this.cache[ unlock ];\r\n\r\n\t\t// Handle: [ owner, key, value ] args\r\n\t\tif ( typeof data === \"string\" ) {\r\n\t\t\tcache[ data ] = value;\r\n\r\n\t\t// Handle: [ owner, { properties } ] args\r\n\t\t} else {\r\n\t\t\t// Fresh assignments by object are shallow copied\r\n\t\t\tif ( jQuery.isEmptyObject( cache ) ) {\r\n\t\t\t\tjQuery.extend( this.cache[ unlock ], data );\r\n\t\t\t// Otherwise, copy the properties one-by-one to the cache object\r\n\t\t\t} else {\r\n\t\t\t\tfor ( prop in data ) {\r\n\t\t\t\t\tcache[ prop ] = data[ prop ];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cache;\r\n\t},\r\n\tget: function( owner, key ) {\r\n\t\t// Either a valid cache is found, or will be created.\r\n\t\t// New caches will be created and the unlock returned,\r\n\t\t// allowing direct access to the newly created\r\n\t\t// empty data object. A valid owner object must be provided.\r\n\t\tvar cache = this.cache[ this.key( owner ) ];\r\n\r\n\t\treturn key === undefined ?\r\n\t\t\tcache : cache[ key ];\r\n\t},\r\n\taccess: function( owner, key, value ) {\r\n\t\tvar stored;\r\n\t\t// In cases where either:\r\n\t\t//\r\n\t\t//   1. No key was specified\r\n\t\t//   2. A string key was specified, but no value provided\r\n\t\t//\r\n\t\t// Take the \"read\" path and allow the get method to determine\r\n\t\t// which value to return, respectively either:\r\n\t\t//\r\n\t\t//   1. The entire cache object\r\n\t\t//   2. The data stored at the key\r\n\t\t//\r\n\t\tif ( key === undefined ||\r\n\t\t\t\t((key && typeof key === \"string\") && value === undefined) ) {\r\n\r\n\t\t\tstored = this.get( owner, key );\r\n\r\n\t\t\treturn stored !== undefined ?\r\n\t\t\t\tstored : this.get( owner, jQuery.camelCase(key) );\r\n\t\t}\r\n\r\n\t\t// [*]When the key is not a string, or both a key and value\r\n\t\t// are specified, set or extend (existing objects) with either:\r\n\t\t//\r\n\t\t//   1. An object of properties\r\n\t\t//   2. A key and value\r\n\t\t//\r\n\t\tthis.set( owner, key, value );\r\n\r\n\t\t// Since the \"set\" path can have two possible entry points\r\n\t\t// return the expected data based on which path was taken[*]\r\n\t\treturn value !== undefined ? value : key;\r\n\t},\r\n\tremove: function( owner, key ) {\r\n\t\tvar i, name, camel,\r\n\t\t\tunlock = this.key( owner ),\r\n\t\t\tcache = this.cache[ unlock ];\r\n\r\n\t\tif ( key === undefined ) {\r\n\t\t\tthis.cache[ unlock ] = {};\r\n\r\n\t\t} else {\r\n\t\t\t// Support array or space separated string of keys\r\n\t\t\tif ( jQuery.isArray( key ) ) {\r\n\t\t\t\t// If \"name\" is an array of keys...\r\n\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\r\n\t\t\t\t// keys will be converted to camelCase.\r\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\r\n\t\t\t\t// both plain key and camelCase key. #12786\r\n\t\t\t\t// This will only penalize the array argument path.\r\n\t\t\t\tname = key.concat( key.map( jQuery.camelCase ) );\r\n\t\t\t} else {\r\n\t\t\t\tcamel = jQuery.camelCase( key );\r\n\t\t\t\t// Try the string as a key before any manipulation\r\n\t\t\t\tif ( key in cache ) {\r\n\t\t\t\t\tname = [ key, camel ];\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// If a key with the spaces exists, use it.\r\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\r\n\t\t\t\t\tname = camel;\r\n\t\t\t\t\tname = name in cache ?\r\n\t\t\t\t\t\t[ name ] : ( name.match( core_rnotwhite ) || [] );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ti = name.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tdelete cache[ name[ i ] ];\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\thasData: function( owner ) {\r\n\t\treturn !jQuery.isEmptyObject(\r\n\t\t\tthis.cache[ owner[ this.expando ] ] || {}\r\n\t\t);\r\n\t},\r\n\tdiscard: function( owner ) {\r\n\t\tif ( owner[ this.expando ] ) {\r\n\t\t\tdelete this.cache[ owner[ this.expando ] ];\r\n\t\t}\r\n\t}\r\n};\r\n\r\n// These may be used throughout the jQuery core codebase\r\ndata_user = new Data();\r\ndata_priv = new Data();\r\n\r\n\r\njQuery.extend({\r\n\tacceptData: Data.accepts,\r\n\r\n\thasData: function( elem ) {\r\n\t\treturn data_user.hasData( elem ) || data_priv.hasData( elem );\r\n\t},\r\n\r\n\tdata: function( elem, name, data ) {\r\n\t\treturn data_user.access( elem, name, data );\r\n\t},\r\n\r\n\tremoveData: function( elem, name ) {\r\n\t\tdata_user.remove( elem, name );\r\n\t},\r\n\r\n\t// TODO: Now that all calls to _data and _removeData have been replaced\r\n\t// with direct calls to data_priv methods, these can be deprecated.\r\n\t_data: function( elem, name, data ) {\r\n\t\treturn data_priv.access( elem, name, data );\r\n\t},\r\n\r\n\t_removeData: function( elem, name ) {\r\n\t\tdata_priv.remove( elem, name );\r\n\t}\r\n});\r\n\r\njQuery.fn.extend({\r\n\tdata: function( key, value ) {\r\n\t\tvar attrs, name,\r\n\t\t\telem = this[ 0 ],\r\n\t\t\ti = 0,\r\n\t\t\tdata = null;\r\n\r\n\t\t// Gets all values\r\n\t\tif ( key === undefined ) {\r\n\t\t\tif ( this.length ) {\r\n\t\t\t\tdata = data_user.get( elem );\r\n\r\n\t\t\t\tif ( elem.nodeType === 1 && !data_priv.get( elem, \"hasDataAttrs\" ) ) {\r\n\t\t\t\t\tattrs = elem.attributes;\r\n\t\t\t\t\tfor ( ; i < attrs.length; i++ ) {\r\n\t\t\t\t\t\tname = attrs[ i ].name;\r\n\r\n\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\r\n\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice(5) );\r\n\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdata_priv.set( elem, \"hasDataAttrs\", true );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\t// Sets multiple values\r\n\t\tif ( typeof key === \"object\" ) {\r\n\t\t\treturn this.each(function() {\r\n\t\t\t\tdata_user.set( this, key );\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn jQuery.access( this, function( value ) {\r\n\t\t\tvar data,\r\n\t\t\t\tcamelKey = jQuery.camelCase( key );\r\n\r\n\t\t\t// The calling jQuery object (element matches) is not empty\r\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\r\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\r\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\r\n\t\t\t// throw an exception if an attempt to read a data cache is made.\r\n\t\t\tif ( elem && value === undefined ) {\r\n\t\t\t\t// Attempt to get data from the cache\r\n\t\t\t\t// with the key as-is\r\n\t\t\t\tdata = data_user.get( elem, key );\r\n\t\t\t\tif ( data !== undefined ) {\r\n\t\t\t\t\treturn data;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Attempt to get data from the cache\r\n\t\t\t\t// with the key camelized\r\n\t\t\t\tdata = data_user.get( elem, camelKey );\r\n\t\t\t\tif ( data !== undefined ) {\r\n\t\t\t\t\treturn data;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Attempt to \"discover\" the data in\r\n\t\t\t\t// HTML5 custom data-* attrs\r\n\t\t\t\tdata = dataAttr( elem, camelKey, undefined );\r\n\t\t\t\tif ( data !== undefined ) {\r\n\t\t\t\t\treturn data;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// We tried really hard, but the data doesn't exist.\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Set the data...\r\n\t\t\tthis.each(function() {\r\n\t\t\t\t// First, attempt to store a copy or reference of any\r\n\t\t\t\t// data that might've been store with a camelCased key.\r\n\t\t\t\tvar data = data_user.get( this, camelKey );\r\n\r\n\t\t\t\t// For HTML5 data-* attribute interop, we have to\r\n\t\t\t\t// store property names with dashes in a camelCase form.\r\n\t\t\t\t// This might not apply to all properties...*\r\n\t\t\t\tdata_user.set( this, camelKey, value );\r\n\r\n\t\t\t\t// *... In the case of properties that might _actually_\r\n\t\t\t\t// have dashes, we need to also store a copy of that\r\n\t\t\t\t// unchanged property.\r\n\t\t\t\tif ( key.indexOf(\"-\") !== -1 && data !== undefined ) {\r\n\t\t\t\t\tdata_user.set( this, key, value );\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}, null, value, arguments.length > 1, null, true );\r\n\t},\r\n\r\n\tremoveData: function( key ) {\r\n\t\treturn this.each(function() {\r\n\t\t\tdata_user.remove( this, key );\r\n\t\t});\r\n\t}\r\n});\r\n\r\nfunction dataAttr( elem, key, data ) {\r\n\tvar name;\r\n\r\n\t// If nothing was found internally, try to fetch any\r\n\t// data from the HTML5 data-* attribute\r\n\tif ( data === undefined && elem.nodeType === 1 ) {\r\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\r\n\t\tdata = elem.getAttribute( name );\r\n\r\n\t\tif ( typeof data === \"string\" ) {\r\n\t\t\ttry {\r\n\t\t\t\tdata = data === \"true\" ? true :\r\n\t\t\t\t\tdata === \"false\" ? false :\r\n\t\t\t\t\tdata === \"null\" ? null :\r\n\t\t\t\t\t// Only convert to a number if it doesn't change the string\r\n\t\t\t\t\t+data + \"\" === data ? +data :\r\n\t\t\t\t\trbrace.test( data ) ? JSON.parse( data ) :\r\n\t\t\t\t\tdata;\r\n\t\t\t} catch( e ) {}\r\n\r\n\t\t\t// Make sure we set the data so it isn't changed later\r\n\t\t\tdata_user.set( elem, key, data );\r\n\t\t} else {\r\n\t\t\tdata = undefined;\r\n\t\t}\r\n\t}\r\n\treturn data;\r\n}\r\njQuery.extend({\r\n\tqueue: function( elem, type, data ) {\r\n\t\tvar queue;\r\n\r\n\t\tif ( elem ) {\r\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\r\n\t\t\tqueue = data_priv.get( elem, type );\r\n\r\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\r\n\t\t\tif ( data ) {\r\n\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\r\n\t\t\t\t\tqueue = data_priv.access( elem, type, jQuery.makeArray(data) );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tqueue.push( data );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn queue || [];\r\n\t\t}\r\n\t},\r\n\r\n\tdequeue: function( elem, type ) {\r\n\t\ttype = type || \"fx\";\r\n\r\n\t\tvar queue = jQuery.queue( elem, type ),\r\n\t\t\tstartLength = queue.length,\r\n\t\t\tfn = queue.shift(),\r\n\t\t\thooks = jQuery._queueHooks( elem, type ),\r\n\t\t\tnext = function() {\r\n\t\t\t\tjQuery.dequeue( elem, type );\r\n\t\t\t};\r\n\r\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\r\n\t\tif ( fn === \"inprogress\" ) {\r\n\t\t\tfn = queue.shift();\r\n\t\t\tstartLength--;\r\n\t\t}\r\n\r\n\t\tif ( fn ) {\r\n\r\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\r\n\t\t\t// automatically dequeued\r\n\t\t\tif ( type === \"fx\" ) {\r\n\t\t\t\tqueue.unshift( \"inprogress\" );\r\n\t\t\t}\r\n\r\n\t\t\t// clear up the last queue stop function\r\n\t\t\tdelete hooks.stop;\r\n\t\t\tfn.call( elem, next, hooks );\r\n\t\t}\r\n\r\n\t\tif ( !startLength && hooks ) {\r\n\t\t\thooks.empty.fire();\r\n\t\t}\r\n\t},\r\n\r\n\t// not intended for public consumption - generates a queueHooks object, or returns the current one\r\n\t_queueHooks: function( elem, type ) {\r\n\t\tvar key = type + \"queueHooks\";\r\n\t\treturn data_priv.get( elem, key ) || data_priv.access( elem, key, {\r\n\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function() {\r\n\t\t\t\tdata_priv.remove( elem, [ type + \"queue\", key ] );\r\n\t\t\t})\r\n\t\t});\r\n\t}\r\n});\r\n\r\njQuery.fn.extend({\r\n\tqueue: function( type, data ) {\r\n\t\tvar setter = 2;\r\n\r\n\t\tif ( typeof type !== \"string\" ) {\r\n\t\t\tdata = type;\r\n\t\t\ttype = \"fx\";\r\n\t\t\tsetter--;\r\n\t\t}\r\n\r\n\t\tif ( arguments.length < setter ) {\r\n\t\t\treturn jQuery.queue( this[0], type );\r\n\t\t}\r\n\r\n\t\treturn data === undefined ?\r\n\t\t\tthis :\r\n\t\t\tthis.each(function() {\r\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\r\n\r\n\t\t\t\t// ensure a hooks for this queue\r\n\t\t\t\tjQuery._queueHooks( this, type );\r\n\r\n\t\t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\r\n\t\t\t\t\tjQuery.dequeue( this, type );\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t},\r\n\tdequeue: function( type ) {\r\n\t\treturn this.each(function() {\r\n\t\t\tjQuery.dequeue( this, type );\r\n\t\t});\r\n\t},\r\n\t// Based off of the plugin by Clint Helfers, with permission.\r\n\t// http://blindsignals.com/index.php/2009/07/jquery-delay/\r\n\tdelay: function( time, type ) {\r\n\t\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\r\n\t\ttype = type || \"fx\";\r\n\r\n\t\treturn this.queue( type, function( next, hooks ) {\r\n\t\t\tvar timeout = setTimeout( next, time );\r\n\t\t\thooks.stop = function() {\r\n\t\t\t\tclearTimeout( timeout );\r\n\t\t\t};\r\n\t\t});\r\n\t},\r\n\tclearQueue: function( type ) {\r\n\t\treturn this.queue( type || \"fx\", [] );\r\n\t},\r\n\t// Get a promise resolved when queues of a certain type\r\n\t// are emptied (fx is the type by default)\r\n\tpromise: function( type, obj ) {\r\n\t\tvar tmp,\r\n\t\t\tcount = 1,\r\n\t\t\tdefer = jQuery.Deferred(),\r\n\t\t\telements = this,\r\n\t\t\ti = this.length,\r\n\t\t\tresolve = function() {\r\n\t\t\t\tif ( !( --count ) ) {\r\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\tif ( typeof type !== \"string\" ) {\r\n\t\t\tobj = type;\r\n\t\t\ttype = undefined;\r\n\t\t}\r\n\t\ttype = type || \"fx\";\r\n\r\n\t\twhile( i-- ) {\r\n\t\t\ttmp = data_priv.get( elements[ i ], type + \"queueHooks\" );\r\n\t\t\tif ( tmp && tmp.empty ) {\r\n\t\t\t\tcount++;\r\n\t\t\t\ttmp.empty.add( resolve );\r\n\t\t\t}\r\n\t\t}\r\n\t\tresolve();\r\n\t\treturn defer.promise( obj );\r\n\t}\r\n});\r\nvar nodeHook, boolHook,\r\n\trclass = /[\\t\\r\\n\\f]/g,\r\n\trreturn = /\\r/g,\r\n\trfocusable = /^(?:input|select|textarea|button)$/i;\r\n\r\njQuery.fn.extend({\r\n\tattr: function( name, value ) {\r\n\t\treturn jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );\r\n\t},\r\n\r\n\tremoveAttr: function( name ) {\r\n\t\treturn this.each(function() {\r\n\t\t\tjQuery.removeAttr( this, name );\r\n\t\t});\r\n\t},\r\n\r\n\tprop: function( name, value ) {\r\n\t\treturn jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );\r\n\t},\r\n\r\n\tremoveProp: function( name ) {\r\n\t\treturn this.each(function() {\r\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\r\n\t\t});\r\n\t},\r\n\r\n\taddClass: function( value ) {\r\n\t\tvar classes, elem, cur, clazz, j,\r\n\t\t\ti = 0,\r\n\t\t\tlen = this.length,\r\n\t\t\tproceed = typeof value === \"string\" && value;\r\n\r\n\t\tif ( jQuery.isFunction( value ) ) {\r\n\t\t\treturn this.each(function( j ) {\r\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, this.className ) );\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif ( proceed ) {\r\n\t\t\t// The disjunction here is for better compressibility (see removeClass)\r\n\t\t\tclasses = ( value || \"\" ).match( core_rnotwhite ) || [];\r\n\r\n\t\t\tfor ( ; i < len; i++ ) {\r\n\t\t\t\telem = this[ i ];\r\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\r\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\r\n\t\t\t\t\t\" \"\r\n\t\t\t\t);\r\n\r\n\t\t\t\tif ( cur ) {\r\n\t\t\t\t\tj = 0;\r\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\r\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\r\n\t\t\t\t\t\t\tcur += clazz + \" \";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telem.className = jQuery.trim( cur );\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveClass: function( value ) {\r\n\t\tvar classes, elem, cur, clazz, j,\r\n\t\t\ti = 0,\r\n\t\t\tlen = this.length,\r\n\t\t\tproceed = arguments.length === 0 || typeof value === \"string\" && value;\r\n\r\n\t\tif ( jQuery.isFunction( value ) ) {\r\n\t\t\treturn this.each(function( j ) {\r\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, this.className ) );\r\n\t\t\t});\r\n\t\t}\r\n\t\tif ( proceed ) {\r\n\t\t\tclasses = ( value || \"\" ).match( core_rnotwhite ) || [];\r\n\r\n\t\t\tfor ( ; i < len; i++ ) {\r\n\t\t\t\telem = this[ i ];\r\n\t\t\t\t// This expression is here for better compressibility (see addClass)\r\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\r\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\r\n\t\t\t\t\t\"\"\r\n\t\t\t\t);\r\n\r\n\t\t\t\tif ( cur ) {\r\n\t\t\t\t\tj = 0;\r\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\r\n\t\t\t\t\t\t// Remove *all* instances\r\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\r\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telem.className = value ? jQuery.trim( cur ) : \"\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\ttoggleClass: function( value, stateVal ) {\r\n\t\tvar type = typeof value;\r\n\r\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\r\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\r\n\t\t}\r\n\r\n\t\tif ( jQuery.isFunction( value ) ) {\r\n\t\t\treturn this.each(function( i ) {\r\n\t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn this.each(function() {\r\n\t\t\tif ( type === \"string\" ) {\r\n\t\t\t\t// toggle individual class names\r\n\t\t\t\tvar className,\r\n\t\t\t\t\ti = 0,\r\n\t\t\t\t\tself = jQuery( this ),\r\n\t\t\t\t\tclassNames = value.match( core_rnotwhite ) || [];\r\n\r\n\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\r\n\t\t\t\t\t// check each className given, space separated list\r\n\t\t\t\t\tif ( self.hasClass( className ) ) {\r\n\t\t\t\t\t\tself.removeClass( className );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tself.addClass( className );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t// Toggle whole class name\r\n\t\t\t} else if ( type === core_strundefined || type === \"boolean\" ) {\r\n\t\t\t\tif ( this.className ) {\r\n\t\t\t\t\t// store className if set\r\n\t\t\t\t\tdata_priv.set( this, \"__className__\", this.className );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// If the element has a class name or if we're passed \"false\",\r\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\r\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\r\n\t\t\t\t// falling back to the empty string if nothing was stored.\r\n\t\t\t\tthis.className = this.className || value === false ? \"\" : data_priv.get( this, \"__className__\" ) || \"\";\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\thasClass: function( selector ) {\r\n\t\tvar className = \" \" + selector + \" \",\r\n\t\t\ti = 0,\r\n\t\t\tl = this.length;\r\n\t\tfor ( ; i < l; i++ ) {\r\n\t\t\tif ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\tval: function( value ) {\r\n\t\tvar hooks, ret, isFunction,\r\n\t\t\telem = this[0];\r\n\r\n\t\tif ( !arguments.length ) {\r\n\t\t\tif ( elem ) {\r\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\r\n\r\n\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\r\n\t\t\t\t\treturn ret;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tret = elem.value;\r\n\r\n\t\t\t\treturn typeof ret === \"string\" ?\r\n\t\t\t\t\t// handle most common string cases\r\n\t\t\t\t\tret.replace(rreturn, \"\") :\r\n\t\t\t\t\t// handle cases where value is null/undef or number\r\n\t\t\t\t\tret == null ? \"\" : ret;\r\n\t\t\t}\r\n\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tisFunction = jQuery.isFunction( value );\r\n\r\n\t\treturn this.each(function( i ) {\r\n\t\t\tvar val;\r\n\r\n\t\t\tif ( this.nodeType !== 1 ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif ( isFunction ) {\r\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\r\n\t\t\t} else {\r\n\t\t\t\tval = value;\r\n\t\t\t}\r\n\r\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\r\n\t\t\tif ( val == null ) {\r\n\t\t\t\tval = \"\";\r\n\t\t\t} else if ( typeof val === \"number\" ) {\r\n\t\t\t\tval += \"\";\r\n\t\t\t} else if ( jQuery.isArray( val ) ) {\r\n\t\t\t\tval = jQuery.map(val, function ( value ) {\r\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\r\n\r\n\t\t\t// If set returns undefined, fall back to normal setting\r\n\t\t\tif ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\r\n\t\t\t\tthis.value = val;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n});\r\n\r\njQuery.extend({\r\n\tvalHooks: {\r\n\t\toption: {\r\n\t\t\tget: function( elem ) {\r\n\t\t\t\t// attributes.value is undefined in Blackberry 4.7 but\r\n\t\t\t\t// uses .value. See #6932\r\n\t\t\t\tvar val = elem.attributes.value;\r\n\t\t\t\treturn !val || val.specified ? elem.value : elem.text;\r\n\t\t\t}\r\n\t\t},\r\n\t\tselect: {\r\n\t\t\tget: function( elem ) {\r\n\t\t\t\tvar value, option,\r\n\t\t\t\t\toptions = elem.options,\r\n\t\t\t\t\tindex = elem.selectedIndex,\r\n\t\t\t\t\tone = elem.type === \"select-one\" || index < 0,\r\n\t\t\t\t\tvalues = one ? null : [],\r\n\t\t\t\t\tmax = one ? index + 1 : options.length,\r\n\t\t\t\t\ti = index < 0 ?\r\n\t\t\t\t\t\tmax :\r\n\t\t\t\t\t\tone ? index : 0;\r\n\r\n\t\t\t\t// Loop through all the selected options\r\n\t\t\t\tfor ( ; i < max; i++ ) {\r\n\t\t\t\t\toption = options[ i ];\r\n\r\n\t\t\t\t\t// IE6-9 doesn't update selected after form reset (#2551)\r\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\r\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\r\n\t\t\t\t\t\t\t( jQuery.support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null ) &&\r\n\t\t\t\t\t\t\t( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\r\n\r\n\t\t\t\t\t\t// Get the specific value for the option\r\n\t\t\t\t\t\tvalue = jQuery( option ).val();\r\n\r\n\t\t\t\t\t\t// We don't need an array for one selects\r\n\t\t\t\t\t\tif ( one ) {\r\n\t\t\t\t\t\t\treturn value;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Multi-Selects return an array\r\n\t\t\t\t\t\tvalues.push( value );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn values;\r\n\t\t\t},\r\n\r\n\t\t\tset: function( elem, value ) {\r\n\t\t\t\tvar optionSet, option,\r\n\t\t\t\t\toptions = elem.options,\r\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\r\n\t\t\t\t\ti = options.length;\r\n\r\n\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\toption = options[ i ];\r\n\t\t\t\t\tif ( (option.selected = jQuery.inArray( jQuery(option).val(), values ) >= 0) ) {\r\n\t\t\t\t\t\toptionSet = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// force browsers to behave consistently when non-matching value is set\r\n\t\t\t\tif ( !optionSet ) {\r\n\t\t\t\t\telem.selectedIndex = -1;\r\n\t\t\t\t}\r\n\t\t\t\treturn values;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tattr: function( elem, name, value ) {\r\n\t\tvar hooks, ret,\r\n\t\t\tnType = elem.nodeType;\r\n\r\n\t\t// don't get/set attributes on text, comment and attribute nodes\r\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Fallback to prop when attributes are not supported\r\n\t\tif ( typeof elem.getAttribute === core_strundefined ) {\r\n\t\t\treturn jQuery.prop( elem, name, value );\r\n\t\t}\r\n\r\n\t\t// All attributes are lowercase\r\n\t\t// Grab necessary hook if one is defined\r\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\r\n\t\t\tname = name.toLowerCase();\r\n\t\t\thooks = jQuery.attrHooks[ name ] ||\r\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\r\n\t\t}\r\n\r\n\t\tif ( value !== undefined ) {\r\n\r\n\t\t\tif ( value === null ) {\r\n\t\t\t\tjQuery.removeAttr( elem, name );\r\n\r\n\t\t\t} else if ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\r\n\t\t\t\treturn ret;\r\n\r\n\t\t\t} else {\r\n\t\t\t\telem.setAttribute( name, value + \"\" );\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\r\n\t\t} else if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\r\n\t\t\treturn ret;\r\n\r\n\t\t} else {\r\n\t\t\tret = jQuery.find.attr( elem, name );\r\n\r\n\t\t\t// Non-existent attributes return null, we normalize to undefined\r\n\t\t\treturn ret == null ?\r\n\t\t\t\tundefined :\r\n\t\t\t\tret;\r\n\t\t}\r\n\t},\r\n\r\n\tremoveAttr: function( elem, value ) {\r\n\t\tvar name, propName,\r\n\t\t\ti = 0,\r\n\t\t\tattrNames = value && value.match( core_rnotwhite );\r\n\r\n\t\tif ( attrNames && elem.nodeType === 1 ) {\r\n\t\t\twhile ( (name = attrNames[i++]) ) {\r\n\t\t\t\tpropName = jQuery.propFix[ name ] || name;\r\n\r\n\t\t\t\t// Boolean attributes get special treatment (#10870)\r\n\t\t\t\tif ( jQuery.expr.match.bool.test( name ) ) {\r\n\t\t\t\t\t// Set corresponding property to false\r\n\t\t\t\t\telem[ propName ] = false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\telem.removeAttribute( name );\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tattrHooks: {\r\n\t\ttype: {\r\n\t\t\tset: function( elem, value ) {\r\n\t\t\t\tif ( !jQuery.support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\") ) {\r\n\t\t\t\t\t// Setting the type on a radio button after the value resets the value in IE6-9\r\n\t\t\t\t\t// Reset value to default in case type is set after value during creation\r\n\t\t\t\t\tvar val = elem.value;\r\n\t\t\t\t\telem.setAttribute( \"type\", value );\r\n\t\t\t\t\tif ( val ) {\r\n\t\t\t\t\t\telem.value = val;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tpropFix: {\r\n\t\t\"for\": \"htmlFor\",\r\n\t\t\"class\": \"className\"\r\n\t},\r\n\r\n\tprop: function( elem, name, value ) {\r\n\t\tvar ret, hooks, notxml,\r\n\t\t\tnType = elem.nodeType;\r\n\r\n\t\t// don't get/set properties on text, comment and attribute nodes\r\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\r\n\r\n\t\tif ( notxml ) {\r\n\t\t\t// Fix name and attach hooks\r\n\t\t\tname = jQuery.propFix[ name ] || name;\r\n\t\t\thooks = jQuery.propHooks[ name ];\r\n\t\t}\r\n\r\n\t\tif ( value !== undefined ) {\r\n\t\t\treturn hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\r\n\t\t\t\tret :\r\n\t\t\t\t( elem[ name ] = value );\r\n\r\n\t\t} else {\r\n\t\t\treturn hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ?\r\n\t\t\t\tret :\r\n\t\t\t\telem[ name ];\r\n\t\t}\r\n\t},\r\n\r\n\tpropHooks: {\r\n\t\ttabIndex: {\r\n\t\t\tget: function( elem ) {\r\n\t\t\t\treturn elem.hasAttribute( \"tabindex\" ) || rfocusable.test( elem.nodeName ) || elem.href ?\r\n\t\t\t\t\telem.tabIndex :\r\n\t\t\t\t\t-1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\n// Hooks for boolean attributes\r\nboolHook = {\r\n\tset: function( elem, value, name ) {\r\n\t\tif ( value === false ) {\r\n\t\t\t// Remove boolean attributes when set to false\r\n\t\t\tjQuery.removeAttr( elem, name );\r\n\t\t} else {\r\n\t\t\telem.setAttribute( name, name );\r\n\t\t}\r\n\t\treturn name;\r\n\t}\r\n};\r\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\r\n\tvar getter = jQuery.expr.attrHandle[ name ] || jQuery.find.attr;\r\n\r\n\tjQuery.expr.attrHandle[ name ] = function( elem, name, isXML ) {\r\n\t\tvar fn = jQuery.expr.attrHandle[ name ],\r\n\t\t\tret = isXML ?\r\n\t\t\t\tundefined :\r\n\t\t\t\t/* jshint eqeqeq: false */\r\n\t\t\t\t// Temporarily disable this handler to check existence\r\n\t\t\t\t(jQuery.expr.attrHandle[ name ] = undefined) !=\r\n\t\t\t\t\tgetter( elem, name, isXML ) ?\r\n\r\n\t\t\t\t\tname.toLowerCase() :\r\n\t\t\t\t\tnull;\r\n\r\n\t\t// Restore handler\r\n\t\tjQuery.expr.attrHandle[ name ] = fn;\r\n\r\n\t\treturn ret;\r\n\t};\r\n});\r\n\r\n// Support: IE9+\r\n// Selectedness for an option in an optgroup can be inaccurate\r\nif ( !jQuery.support.optSelected ) {\r\n\tjQuery.propHooks.selected = {\r\n\t\tget: function( elem ) {\r\n\t\t\tvar parent = elem.parentNode;\r\n\t\t\tif ( parent && parent.parentNode ) {\r\n\t\t\t\tparent.parentNode.selectedIndex;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\t};\r\n}\r\n\r\njQuery.each([\r\n\t\"tabIndex\",\r\n\t\"readOnly\",\r\n\t\"maxLength\",\r\n\t\"cellSpacing\",\r\n\t\"cellPadding\",\r\n\t\"rowSpan\",\r\n\t\"colSpan\",\r\n\t\"useMap\",\r\n\t\"frameBorder\",\r\n\t\"contentEditable\"\r\n], function() {\r\n\tjQuery.propFix[ this.toLowerCase() ] = this;\r\n});\r\n\r\n// Radios and checkboxes getter/setter\r\njQuery.each([ \"radio\", \"checkbox\" ], function() {\r\n\tjQuery.valHooks[ this ] = {\r\n\t\tset: function( elem, value ) {\r\n\t\t\tif ( jQuery.isArray( value ) ) {\r\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\tif ( !jQuery.support.checkOn ) {\r\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\r\n\t\t\t// Support: Webkit\r\n\t\t\t// \"\" is returned instead of \"on\" if a value isn't specified\r\n\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\r\n\t\t};\r\n\t}\r\n});\r\nvar rkeyEvent = /^key/,\r\n\trmouseEvent = /^(?:mouse|contextmenu)|click/,\r\n\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\r\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\r\n\r\nfunction returnTrue() {\r\n\treturn true;\r\n}\r\n\r\nfunction returnFalse() {\r\n\treturn false;\r\n}\r\n\r\nfunction safeActiveElement() {\r\n\ttry {\r\n\t\treturn document.activeElement;\r\n\t} catch ( err ) { }\r\n}\r\n\r\n/*\r\n * Helper functions for managing events -- not part of the public interface.\r\n * Props to Dean Edwards' addEvent library for many of the ideas.\r\n */\r\njQuery.event = {\r\n\r\n\tglobal: {},\r\n\r\n\tadd: function( elem, types, handler, data, selector ) {\r\n\r\n\t\tvar handleObjIn, eventHandle, tmp,\r\n\t\t\tevents, t, handleObj,\r\n\t\t\tspecial, handlers, type, namespaces, origType,\r\n\t\t\telemData = data_priv.get( elem );\r\n\r\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\r\n\t\tif ( !elemData ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Caller can pass in an object of custom data in lieu of the handler\r\n\t\tif ( handler.handler ) {\r\n\t\t\thandleObjIn = handler;\r\n\t\t\thandler = handleObjIn.handler;\r\n\t\t\tselector = handleObjIn.selector;\r\n\t\t}\r\n\r\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\r\n\t\tif ( !handler.guid ) {\r\n\t\t\thandler.guid = jQuery.guid++;\r\n\t\t}\r\n\r\n\t\t// Init the element's event structure and main handler, if this is the first\r\n\t\tif ( !(events = elemData.events) ) {\r\n\t\t\tevents = elemData.events = {};\r\n\t\t}\r\n\t\tif ( !(eventHandle = elemData.handle) ) {\r\n\t\t\teventHandle = elemData.handle = function( e ) {\r\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\r\n\t\t\t\t// when an event is called after a page has unloaded\r\n\t\t\t\treturn typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?\r\n\t\t\t\t\tjQuery.event.dispatch.apply( eventHandle.elem, arguments ) :\r\n\t\t\t\t\tundefined;\r\n\t\t\t};\r\n\t\t\t// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events\r\n\t\t\teventHandle.elem = elem;\r\n\t\t}\r\n\r\n\t\t// Handle multiple events separated by a space\r\n\t\ttypes = ( types || \"\" ).match( core_rnotwhite ) || [\"\"];\r\n\t\tt = types.length;\r\n\t\twhile ( t-- ) {\r\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\r\n\t\t\ttype = origType = tmp[1];\r\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\r\n\r\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\r\n\t\t\tif ( !type ) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// If event changes its type, use the special event handlers for the changed type\r\n\t\t\tspecial = jQuery.event.special[ type ] || {};\r\n\r\n\t\t\t// If selector defined, determine special event api type, otherwise given type\r\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\r\n\r\n\t\t\t// Update special based on newly reset type\r\n\t\t\tspecial = jQuery.event.special[ type ] || {};\r\n\r\n\t\t\t// handleObj is passed to all event handlers\r\n\t\t\thandleObj = jQuery.extend({\r\n\t\t\t\ttype: type,\r\n\t\t\t\torigType: origType,\r\n\t\t\t\tdata: data,\r\n\t\t\t\thandler: handler,\r\n\t\t\t\tguid: handler.guid,\r\n\t\t\t\tselector: selector,\r\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\r\n\t\t\t\tnamespace: namespaces.join(\".\")\r\n\t\t\t}, handleObjIn );\r\n\r\n\t\t\t// Init the event handler queue if we're the first\r\n\t\t\tif ( !(handlers = events[ type ]) ) {\r\n\t\t\t\thandlers = events[ type ] = [];\r\n\t\t\t\thandlers.delegateCount = 0;\r\n\r\n\t\t\t\t// Only use addEventListener if the special events handler returns false\r\n\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\r\n\t\t\t\t\tif ( elem.addEventListener ) {\r\n\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( special.add ) {\r\n\t\t\t\tspecial.add.call( elem, handleObj );\r\n\r\n\t\t\t\tif ( !handleObj.handler.guid ) {\r\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Add to the element's handler list, delegates in front\r\n\t\t\tif ( selector ) {\r\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\r\n\t\t\t} else {\r\n\t\t\t\thandlers.push( handleObj );\r\n\t\t\t}\r\n\r\n\t\t\t// Keep track of which events have ever been used, for event optimization\r\n\t\t\tjQuery.event.global[ type ] = true;\r\n\t\t}\r\n\r\n\t\t// Nullify elem to prevent memory leaks in IE\r\n\t\telem = null;\r\n\t},\r\n\r\n\t// Detach an event or set of events from an element\r\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\r\n\r\n\t\tvar j, origCount, tmp,\r\n\t\t\tevents, t, handleObj,\r\n\t\t\tspecial, handlers, type, namespaces, origType,\r\n\t\t\telemData = data_priv.hasData( elem ) && data_priv.get( elem );\r\n\r\n\t\tif ( !elemData || !(events = elemData.events) ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Once for each type.namespace in types; type may be omitted\r\n\t\ttypes = ( types || \"\" ).match( core_rnotwhite ) || [\"\"];\r\n\t\tt = types.length;\r\n\t\twhile ( t-- ) {\r\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\r\n\t\t\ttype = origType = tmp[1];\r\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\r\n\r\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\r\n\t\t\tif ( !type ) {\r\n\t\t\t\tfor ( type in events ) {\r\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\r\n\t\t\t\t}\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tspecial = jQuery.event.special[ type ] || {};\r\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\r\n\t\t\thandlers = events[ type ] || [];\r\n\t\t\ttmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\r\n\r\n\t\t\t// Remove matching events\r\n\t\t\torigCount = j = handlers.length;\r\n\t\t\twhile ( j-- ) {\r\n\t\t\t\thandleObj = handlers[ j ];\r\n\r\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\r\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\r\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\r\n\t\t\t\t\t( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\r\n\t\t\t\t\thandlers.splice( j, 1 );\r\n\r\n\t\t\t\t\tif ( handleObj.selector ) {\r\n\t\t\t\t\t\thandlers.delegateCount--;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( special.remove ) {\r\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\r\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\r\n\t\t\tif ( origCount && !handlers.length ) {\r\n\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\r\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdelete events[ type ];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Remove the expando if it's no longer used\r\n\t\tif ( jQuery.isEmptyObject( events ) ) {\r\n\t\t\tdelete elemData.handle;\r\n\t\t\tdata_priv.remove( elem, \"events\" );\r\n\t\t}\r\n\t},\r\n\r\n\ttrigger: function( event, data, elem, onlyHandlers ) {\r\n\r\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\r\n\t\t\teventPath = [ elem || document ],\r\n\t\t\ttype = core_hasOwn.call( event, \"type\" ) ? event.type : event,\r\n\t\t\tnamespaces = core_hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\r\n\r\n\t\tcur = tmp = elem = elem || document;\r\n\r\n\t\t// Don't do events on text and comment nodes\r\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\r\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif ( type.indexOf(\".\") >= 0 ) {\r\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\r\n\t\t\tnamespaces = type.split(\".\");\r\n\t\t\ttype = namespaces.shift();\r\n\t\t\tnamespaces.sort();\r\n\t\t}\r\n\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\r\n\r\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\r\n\t\tevent = event[ jQuery.expando ] ?\r\n\t\t\tevent :\r\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\r\n\r\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\r\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\r\n\t\tevent.namespace = namespaces.join(\".\");\r\n\t\tevent.namespace_re = event.namespace ?\r\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\r\n\t\t\tnull;\r\n\r\n\t\t// Clean up the event in case it is being reused\r\n\t\tevent.result = undefined;\r\n\t\tif ( !event.target ) {\r\n\t\t\tevent.target = elem;\r\n\t\t}\r\n\r\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\r\n\t\tdata = data == null ?\r\n\t\t\t[ event ] :\r\n\t\t\tjQuery.makeArray( data, [ event ] );\r\n\r\n\t\t// Allow special events to draw outside the lines\r\n\t\tspecial = jQuery.event.special[ type ] || {};\r\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\r\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\r\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\r\n\r\n\t\t\tbubbleType = special.delegateType || type;\r\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\r\n\t\t\t\tcur = cur.parentNode;\r\n\t\t\t}\r\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\r\n\t\t\t\teventPath.push( cur );\r\n\t\t\t\ttmp = cur;\r\n\t\t\t}\r\n\r\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\r\n\t\t\tif ( tmp === (elem.ownerDocument || document) ) {\r\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Fire handlers on the event path\r\n\t\ti = 0;\r\n\t\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\r\n\r\n\t\t\tevent.type = i > 1 ?\r\n\t\t\t\tbubbleType :\r\n\t\t\t\tspecial.bindType || type;\r\n\r\n\t\t\t// jQuery handler\r\n\t\t\thandle = ( data_priv.get( cur, \"events\" ) || {} )[ event.type ] && data_priv.get( cur, \"handle\" );\r\n\t\t\tif ( handle ) {\r\n\t\t\t\thandle.apply( cur, data );\r\n\t\t\t}\r\n\r\n\t\t\t// Native handler\r\n\t\t\thandle = ontype && cur[ ontype ];\r\n\t\t\tif ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {\r\n\t\t\t\tevent.preventDefault();\r\n\t\t\t}\r\n\t\t}\r\n\t\tevent.type = type;\r\n\r\n\t\t// If nobody prevented the default action, do it now\r\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\r\n\r\n\t\t\tif ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\r\n\t\t\t\tjQuery.acceptData( elem ) ) {\r\n\r\n\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\r\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\r\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\r\n\r\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\r\n\t\t\t\t\ttmp = elem[ ontype ];\r\n\r\n\t\t\t\t\tif ( tmp ) {\r\n\t\t\t\t\t\telem[ ontype ] = null;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\r\n\t\t\t\t\tjQuery.event.triggered = type;\r\n\t\t\t\t\telem[ type ]();\r\n\t\t\t\t\tjQuery.event.triggered = undefined;\r\n\r\n\t\t\t\t\tif ( tmp ) {\r\n\t\t\t\t\t\telem[ ontype ] = tmp;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn event.result;\r\n\t},\r\n\r\n\tdispatch: function( event ) {\r\n\r\n\t\t// Make a writable jQuery.Event from the native event object\r\n\t\tevent = jQuery.event.fix( event );\r\n\r\n\t\tvar i, j, ret, matched, handleObj,\r\n\t\t\thandlerQueue = [],\r\n\t\t\targs = core_slice.call( arguments ),\r\n\t\t\thandlers = ( data_priv.get( this, \"events\" ) || {} )[ event.type ] || [],\r\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\r\n\r\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\r\n\t\targs[0] = event;\r\n\t\tevent.delegateTarget = this;\r\n\r\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\r\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Determine handlers\r\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\r\n\r\n\t\t// Run delegates first; they may want to stop propagation beneath us\r\n\t\ti = 0;\r\n\t\twhile ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\r\n\t\t\tevent.currentTarget = matched.elem;\r\n\r\n\t\t\tj = 0;\r\n\t\t\twhile ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\r\n\r\n\t\t\t\t// Triggered event must either 1) have no namespace, or\r\n\t\t\t\t// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\r\n\t\t\t\tif ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\r\n\r\n\t\t\t\t\tevent.handleObj = handleObj;\r\n\t\t\t\t\tevent.data = handleObj.data;\r\n\r\n\t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\r\n\t\t\t\t\t\t\t.apply( matched.elem, args );\r\n\r\n\t\t\t\t\tif ( ret !== undefined ) {\r\n\t\t\t\t\t\tif ( (event.result = ret) === false ) {\r\n\t\t\t\t\t\t\tevent.preventDefault();\r\n\t\t\t\t\t\t\tevent.stopPropagation();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Call the postDispatch hook for the mapped type\r\n\t\tif ( special.postDispatch ) {\r\n\t\t\tspecial.postDispatch.call( this, event );\r\n\t\t}\r\n\r\n\t\treturn event.result;\r\n\t},\r\n\r\n\thandlers: function( event, handlers ) {\r\n\t\tvar i, matches, sel, handleObj,\r\n\t\t\thandlerQueue = [],\r\n\t\t\tdelegateCount = handlers.delegateCount,\r\n\t\t\tcur = event.target;\r\n\r\n\t\t// Find delegate handlers\r\n\t\t// Black-hole SVG <use> instance trees (#13180)\r\n\t\t// Avoid non-left-click bubbling in Firefox (#3861)\r\n\t\tif ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\r\n\r\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\r\n\r\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\r\n\t\t\t\tif ( cur.disabled !== true || event.type !== \"click\" ) {\r\n\t\t\t\t\tmatches = [];\r\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\r\n\t\t\t\t\t\thandleObj = handlers[ i ];\r\n\r\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\r\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\r\n\r\n\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\r\n\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\r\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) >= 0 :\r\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( matches[ sel ] ) {\r\n\t\t\t\t\t\t\tmatches.push( handleObj );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( matches.length ) {\r\n\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Add the remaining (directly-bound) handlers\r\n\t\tif ( delegateCount < handlers.length ) {\r\n\t\t\thandlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\r\n\t\t}\r\n\r\n\t\treturn handlerQueue;\r\n\t},\r\n\r\n\t// Includes some event props shared by KeyEvent and MouseEvent\r\n\tprops: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\r\n\r\n\tfixHooks: {},\r\n\r\n\tkeyHooks: {\r\n\t\tprops: \"char charCode key keyCode\".split(\" \"),\r\n\t\tfilter: function( event, original ) {\r\n\r\n\t\t\t// Add which for key events\r\n\t\t\tif ( event.which == null ) {\r\n\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\r\n\t\t\t}\r\n\r\n\t\t\treturn event;\r\n\t\t}\r\n\t},\r\n\r\n\tmouseHooks: {\r\n\t\tprops: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\r\n\t\tfilter: function( event, original ) {\r\n\t\t\tvar eventDoc, doc, body,\r\n\t\t\t\tbutton = original.button;\r\n\r\n\t\t\t// Calculate pageX/Y if missing and clientX/Y available\r\n\t\t\tif ( event.pageX == null && original.clientX != null ) {\r\n\t\t\t\teventDoc = event.target.ownerDocument || document;\r\n\t\t\t\tdoc = eventDoc.documentElement;\r\n\t\t\t\tbody = eventDoc.body;\r\n\r\n\t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\r\n\t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\r\n\t\t\t}\r\n\r\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\r\n\t\t\t// Note: button is not normalized, so don't use it\r\n\t\t\tif ( !event.which && button !== undefined ) {\r\n\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\r\n\t\t\t}\r\n\r\n\t\t\treturn event;\r\n\t\t}\r\n\t},\r\n\r\n\tfix: function( event ) {\r\n\t\tif ( event[ jQuery.expando ] ) {\r\n\t\t\treturn event;\r\n\t\t}\r\n\r\n\t\t// Create a writable copy of the event object and normalize some properties\r\n\t\tvar i, prop, copy,\r\n\t\t\ttype = event.type,\r\n\t\t\toriginalEvent = event,\r\n\t\t\tfixHook = this.fixHooks[ type ];\r\n\r\n\t\tif ( !fixHook ) {\r\n\t\t\tthis.fixHooks[ type ] = fixHook =\r\n\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\r\n\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\r\n\t\t\t\t{};\r\n\t\t}\r\n\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\r\n\r\n\t\tevent = new jQuery.Event( originalEvent );\r\n\r\n\t\ti = copy.length;\r\n\t\twhile ( i-- ) {\r\n\t\t\tprop = copy[ i ];\r\n\t\t\tevent[ prop ] = originalEvent[ prop ];\r\n\t\t}\r\n\r\n\t\t// Support: Cordova 2.5 (WebKit) (#13255)\r\n\t\t// All events should have a target; Cordova deviceready doesn't\r\n\t\tif ( !event.target ) {\r\n\t\t\tevent.target = document;\r\n\t\t}\r\n\r\n\t\t// Support: Safari 6.0+, Chrome < 28\r\n\t\t// Target should not be a text node (#504, #13143)\r\n\t\tif ( event.target.nodeType === 3 ) {\r\n\t\t\tevent.target = event.target.parentNode;\r\n\t\t}\r\n\r\n\t\treturn fixHook.filter? fixHook.filter( event, originalEvent ) : event;\r\n\t},\r\n\r\n\tspecial: {\r\n\t\tload: {\r\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\r\n\t\t\tnoBubble: true\r\n\t\t},\r\n\t\tfocus: {\r\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\r\n\t\t\ttrigger: function() {\r\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\r\n\t\t\t\t\tthis.focus();\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tdelegateType: \"focusin\"\r\n\t\t},\r\n\t\tblur: {\r\n\t\t\ttrigger: function() {\r\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\r\n\t\t\t\t\tthis.blur();\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tdelegateType: \"focusout\"\r\n\t\t},\r\n\t\tclick: {\r\n\t\t\t// For checkbox, fire native event so checked state will be right\r\n\t\t\ttrigger: function() {\r\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\r\n\t\t\t\t\tthis.click();\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\r\n\t\t\t_default: function( event ) {\r\n\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tbeforeunload: {\r\n\t\t\tpostDispatch: function( event ) {\r\n\r\n\t\t\t\t// Support: Firefox 20+\r\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\r\n\t\t\t\tif ( event.result !== undefined ) {\r\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tsimulate: function( type, elem, event, bubble ) {\r\n\t\t// Piggyback on a donor event to simulate a different one.\r\n\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\r\n\t\t// simulated event prevents default then we do the same on the donor.\r\n\t\tvar e = jQuery.extend(\r\n\t\t\tnew jQuery.Event(),\r\n\t\t\tevent,\r\n\t\t\t{\r\n\t\t\t\ttype: type,\r\n\t\t\t\tisSimulated: true,\r\n\t\t\t\toriginalEvent: {}\r\n\t\t\t}\r\n\t\t);\r\n\t\tif ( bubble ) {\r\n\t\t\tjQuery.event.trigger( e, null, elem );\r\n\t\t} else {\r\n\t\t\tjQuery.event.dispatch.call( elem, e );\r\n\t\t}\r\n\t\tif ( e.isDefaultPrevented() ) {\r\n\t\t\tevent.preventDefault();\r\n\t\t}\r\n\t}\r\n};\r\n\r\njQuery.removeEvent = function( elem, type, handle ) {\r\n\tif ( elem.removeEventListener ) {\r\n\t\telem.removeEventListener( type, handle, false );\r\n\t}\r\n};\r\n\r\njQuery.Event = function( src, props ) {\r\n\t// Allow instantiation without the 'new' keyword\r\n\tif ( !(this instanceof jQuery.Event) ) {\r\n\t\treturn new jQuery.Event( src, props );\r\n\t}\r\n\r\n\t// Event object\r\n\tif ( src && src.type ) {\r\n\t\tthis.originalEvent = src;\r\n\t\tthis.type = src.type;\r\n\r\n\t\t// Events bubbling up the document may have been marked as prevented\r\n\t\t// by a handler lower down the tree; reflect the correct value.\r\n\t\tthis.isDefaultPrevented = ( src.defaultPrevented ||\r\n\t\t\tsrc.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;\r\n\r\n\t// Event type\r\n\t} else {\r\n\t\tthis.type = src;\r\n\t}\r\n\r\n\t// Put explicitly provided properties onto the event object\r\n\tif ( props ) {\r\n\t\tjQuery.extend( this, props );\r\n\t}\r\n\r\n\t// Create a timestamp if incoming event doesn't have one\r\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\r\n\r\n\t// Mark it as fixed\r\n\tthis[ jQuery.expando ] = true;\r\n};\r\n\r\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\r\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\r\njQuery.Event.prototype = {\r\n\tisDefaultPrevented: returnFalse,\r\n\tisPropagationStopped: returnFalse,\r\n\tisImmediatePropagationStopped: returnFalse,\r\n\r\n\tpreventDefault: function() {\r\n\t\tvar e = this.originalEvent;\r\n\r\n\t\tthis.isDefaultPrevented = returnTrue;\r\n\r\n\t\tif ( e && e.preventDefault ) {\r\n\t\t\te.preventDefault();\r\n\t\t}\r\n\t},\r\n\tstopPropagation: function() {\r\n\t\tvar e = this.originalEvent;\r\n\r\n\t\tthis.isPropagationStopped = returnTrue;\r\n\r\n\t\tif ( e && e.stopPropagation ) {\r\n\t\t\te.stopPropagation();\r\n\t\t}\r\n\t},\r\n\tstopImmediatePropagation: function() {\r\n\t\tthis.isImmediatePropagationStopped = returnTrue;\r\n\t\tthis.stopPropagation();\r\n\t}\r\n};\r\n\r\n// Create mouseenter/leave events using mouseover/out and event-time checks\r\n// Support: Chrome 15+\r\njQuery.each({\r\n\tmouseenter: \"mouseover\",\r\n\tmouseleave: \"mouseout\"\r\n}, function( orig, fix ) {\r\n\tjQuery.event.special[ orig ] = {\r\n\t\tdelegateType: fix,\r\n\t\tbindType: fix,\r\n\r\n\t\thandle: function( event ) {\r\n\t\t\tvar ret,\r\n\t\t\t\ttarget = this,\r\n\t\t\t\trelated = event.relatedTarget,\r\n\t\t\t\thandleObj = event.handleObj;\r\n\r\n\t\t\t// For mousenter/leave call the handler if related is outside the target.\r\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\r\n\t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\r\n\t\t\t\tevent.type = handleObj.origType;\r\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\r\n\t\t\t\tevent.type = fix;\r\n\t\t\t}\r\n\t\t\treturn ret;\r\n\t\t}\r\n\t};\r\n});\r\n\r\n// Create \"bubbling\" focus and blur events\r\n// Support: Firefox, Chrome, Safari\r\nif ( !jQuery.support.focusinBubbles ) {\r\n\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\r\n\r\n\t\t// Attach a single capturing handler while someone wants focusin/focusout\r\n\t\tvar attaches = 0,\r\n\t\t\thandler = function( event ) {\r\n\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\r\n\t\t\t};\r\n\r\n\t\tjQuery.event.special[ fix ] = {\r\n\t\t\tsetup: function() {\r\n\t\t\t\tif ( attaches++ === 0 ) {\r\n\t\t\t\t\tdocument.addEventListener( orig, handler, true );\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tteardown: function() {\r\n\t\t\t\tif ( --attaches === 0 ) {\r\n\t\t\t\t\tdocument.removeEventListener( orig, handler, true );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t});\r\n}\r\n\r\njQuery.fn.extend({\r\n\r\n\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\r\n\t\tvar origFn, type;\r\n\r\n\t\t// Types can be a map of types/handlers\r\n\t\tif ( typeof types === \"object\" ) {\r\n\t\t\t// ( types-Object, selector, data )\r\n\t\t\tif ( typeof selector !== \"string\" ) {\r\n\t\t\t\t// ( types-Object, data )\r\n\t\t\t\tdata = data || selector;\r\n\t\t\t\tselector = undefined;\r\n\t\t\t}\r\n\t\t\tfor ( type in types ) {\r\n\t\t\t\tthis.on( type, selector, data, types[ type ], one );\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif ( data == null && fn == null ) {\r\n\t\t\t// ( types, fn )\r\n\t\t\tfn = selector;\r\n\t\t\tdata = selector = undefined;\r\n\t\t} else if ( fn == null ) {\r\n\t\t\tif ( typeof selector === \"string\" ) {\r\n\t\t\t\t// ( types, selector, fn )\r\n\t\t\t\tfn = data;\r\n\t\t\t\tdata = undefined;\r\n\t\t\t} else {\r\n\t\t\t\t// ( types, data, fn )\r\n\t\t\t\tfn = data;\r\n\t\t\t\tdata = selector;\r\n\t\t\t\tselector = undefined;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ( fn === false ) {\r\n\t\t\tfn = returnFalse;\r\n\t\t} else if ( !fn ) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif ( one === 1 ) {\r\n\t\t\torigFn = fn;\r\n\t\t\tfn = function( event ) {\r\n\t\t\t\t// Can use an empty set, since event contains the info\r\n\t\t\t\tjQuery().off( event );\r\n\t\t\t\treturn origFn.apply( this, arguments );\r\n\t\t\t};\r\n\t\t\t// Use same guid so caller can remove using origFn\r\n\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\r\n\t\t}\r\n\t\treturn this.each( function() {\r\n\t\t\tjQuery.event.add( this, types, fn, data, selector );\r\n\t\t});\r\n\t},\r\n\tone: function( types, selector, data, fn ) {\r\n\t\treturn this.on( types, selector, data, fn, 1 );\r\n\t},\r\n\toff: function( types, selector, fn ) {\r\n\t\tvar handleObj, type;\r\n\t\tif ( types && types.preventDefault && types.handleObj ) {\r\n\t\t\t// ( event )  dispatched jQuery.Event\r\n\t\t\thandleObj = types.handleObj;\r\n\t\t\tjQuery( types.delegateTarget ).off(\r\n\t\t\t\thandleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\r\n\t\t\t\thandleObj.selector,\r\n\t\t\t\thandleObj.handler\r\n\t\t\t);\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tif ( typeof types === \"object\" ) {\r\n\t\t\t// ( types-object [, selector] )\r\n\t\t\tfor ( type in types ) {\r\n\t\t\t\tthis.off( type, selector, types[ type ] );\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tif ( selector === false || typeof selector === \"function\" ) {\r\n\t\t\t// ( types [, fn] )\r\n\t\t\tfn = selector;\r\n\t\t\tselector = undefined;\r\n\t\t}\r\n\t\tif ( fn === false ) {\r\n\t\t\tfn = returnFalse;\r\n\t\t}\r\n\t\treturn this.each(function() {\r\n\t\t\tjQuery.event.remove( this, types, fn, selector );\r\n\t\t});\r\n\t},\r\n\r\n\ttrigger: function( type, data ) {\r\n\t\treturn this.each(function() {\r\n\t\t\tjQuery.event.trigger( type, data, this );\r\n\t\t});\r\n\t},\r\n\ttriggerHandler: function( type, data ) {\r\n\t\tvar elem = this[0];\r\n\t\tif ( elem ) {\r\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\r\n\t\t}\r\n\t}\r\n});\r\nvar isSimple = /^.[^:#\\[\\.,]*$/,\r\n\trparentsprev = /^(?:parents|prev(?:Until|All))/,\r\n\trneedsContext = jQuery.expr.match.needsContext,\r\n\t// methods guaranteed to produce a unique set when starting from a unique set\r\n\tguaranteedUnique = {\r\n\t\tchildren: true,\r\n\t\tcontents: true,\r\n\t\tnext: true,\r\n\t\tprev: true\r\n\t};\r\n\r\njQuery.fn.extend({\r\n\tfind: function( selector ) {\r\n\t\tvar i,\r\n\t\t\tret = [],\r\n\t\t\tself = this,\r\n\t\t\tlen = self.length;\r\n\r\n\t\tif ( typeof selector !== \"string\" ) {\r\n\t\t\treturn this.pushStack( jQuery( selector ).filter(function() {\r\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\r\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}) );\r\n\t\t}\r\n\r\n\t\tfor ( i = 0; i < len; i++ ) {\r\n\t\t\tjQuery.find( selector, self[ i ], ret );\r\n\t\t}\r\n\r\n\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\r\n\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\r\n\t\tret.selector = this.selector ? this.selector + \" \" + selector : selector;\r\n\t\treturn ret;\r\n\t},\r\n\r\n\thas: function( target ) {\r\n\t\tvar targets = jQuery( target, this ),\r\n\t\t\tl = targets.length;\r\n\r\n\t\treturn this.filter(function() {\r\n\t\t\tvar i = 0;\r\n\t\t\tfor ( ; i < l; i++ ) {\r\n\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\tnot: function( selector ) {\r\n\t\treturn this.pushStack( winnow(this, selector || [], true) );\r\n\t},\r\n\r\n\tfilter: function( selector ) {\r\n\t\treturn this.pushStack( winnow(this, selector || [], false) );\r\n\t},\r\n\r\n\tis: function( selector ) {\r\n\t\treturn !!winnow(\r\n\t\t\tthis,\r\n\r\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\r\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\r\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\r\n\t\t\t\tjQuery( selector ) :\r\n\t\t\t\tselector || [],\r\n\t\t\tfalse\r\n\t\t).length;\r\n\t},\r\n\r\n\tclosest: function( selectors, context ) {\r\n\t\tvar cur,\r\n\t\t\ti = 0,\r\n\t\t\tl = this.length,\r\n\t\t\tmatched = [],\r\n\t\t\tpos = ( rneedsContext.test( selectors ) || typeof selectors !== \"string\" ) ?\r\n\t\t\t\tjQuery( selectors, context || this.context ) :\r\n\t\t\t\t0;\r\n\r\n\t\tfor ( ; i < l; i++ ) {\r\n\t\t\tfor ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\r\n\t\t\t\t// Always skip document fragments\r\n\t\t\t\tif ( cur.nodeType < 11 && (pos ?\r\n\t\t\t\t\tpos.index(cur) > -1 :\r\n\r\n\t\t\t\t\t// Don't pass non-elements to Sizzle\r\n\t\t\t\t\tcur.nodeType === 1 &&\r\n\t\t\t\t\t\tjQuery.find.matchesSelector(cur, selectors)) ) {\r\n\r\n\t\t\t\t\tcur = matched.push( cur );\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );\r\n\t},\r\n\r\n\t// Determine the position of an element within\r\n\t// the matched set of elements\r\n\tindex: function( elem ) {\r\n\r\n\t\t// No argument, return index in parent\r\n\t\tif ( !elem ) {\r\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\r\n\t\t}\r\n\r\n\t\t// index in selector\r\n\t\tif ( typeof elem === \"string\" ) {\r\n\t\t\treturn core_indexOf.call( jQuery( elem ), this[ 0 ] );\r\n\t\t}\r\n\r\n\t\t// Locate the position of the desired element\r\n\t\treturn core_indexOf.call( this,\r\n\r\n\t\t\t// If it receives a jQuery object, the first element is used\r\n\t\t\telem.jquery ? elem[ 0 ] : elem\r\n\t\t);\r\n\t},\r\n\r\n\tadd: function( selector, context ) {\r\n\t\tvar set = typeof selector === \"string\" ?\r\n\t\t\t\tjQuery( selector, context ) :\r\n\t\t\t\tjQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),\r\n\t\t\tall = jQuery.merge( this.get(), set );\r\n\r\n\t\treturn this.pushStack( jQuery.unique(all) );\r\n\t},\r\n\r\n\taddBack: function( selector ) {\r\n\t\treturn this.add( selector == null ?\r\n\t\t\tthis.prevObject : this.prevObject.filter(selector)\r\n\t\t);\r\n\t}\r\n});\r\n\r\nfunction sibling( cur, dir ) {\r\n\twhile ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}\r\n\r\n\treturn cur;\r\n}\r\n\r\njQuery.each({\r\n\tparent: function( elem ) {\r\n\t\tvar parent = elem.parentNode;\r\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\r\n\t},\r\n\tparents: function( elem ) {\r\n\t\treturn jQuery.dir( elem, \"parentNode\" );\r\n\t},\r\n\tparentsUntil: function( elem, i, until ) {\r\n\t\treturn jQuery.dir( elem, \"parentNode\", until );\r\n\t},\r\n\tnext: function( elem ) {\r\n\t\treturn sibling( elem, \"nextSibling\" );\r\n\t},\r\n\tprev: function( elem ) {\r\n\t\treturn sibling( elem, \"previousSibling\" );\r\n\t},\r\n\tnextAll: function( elem ) {\r\n\t\treturn jQuery.dir( elem, \"nextSibling\" );\r\n\t},\r\n\tprevAll: function( elem ) {\r\n\t\treturn jQuery.dir( elem, \"previousSibling\" );\r\n\t},\r\n\tnextUntil: function( elem, i, until ) {\r\n\t\treturn jQuery.dir( elem, \"nextSibling\", until );\r\n\t},\r\n\tprevUntil: function( elem, i, until ) {\r\n\t\treturn jQuery.dir( elem, \"previousSibling\", until );\r\n\t},\r\n\tsiblings: function( elem ) {\r\n\t\treturn jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\r\n\t},\r\n\tchildren: function( elem ) {\r\n\t\treturn jQuery.sibling( elem.firstChild );\r\n\t},\r\n\tcontents: function( elem ) {\r\n\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\r\n\t}\r\n}, function( name, fn ) {\r\n\tjQuery.fn[ name ] = function( until, selector ) {\r\n\t\tvar matched = jQuery.map( this, fn, until );\r\n\r\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\r\n\t\t\tselector = until;\r\n\t\t}\r\n\r\n\t\tif ( selector && typeof selector === \"string\" ) {\r\n\t\t\tmatched = jQuery.filter( selector, matched );\r\n\t\t}\r\n\r\n\t\tif ( this.length > 1 ) {\r\n\t\t\t// Remove duplicates\r\n\t\t\tif ( !guaranteedUnique[ name ] ) {\r\n\t\t\t\tjQuery.unique( matched );\r\n\t\t\t}\r\n\r\n\t\t\t// Reverse order for parents* and prev-derivatives\r\n\t\t\tif ( rparentsprev.test( name ) ) {\r\n\t\t\t\tmatched.reverse();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.pushStack( matched );\r\n\t};\r\n});\r\n\r\njQuery.extend({\r\n\tfilter: function( expr, elems, not ) {\r\n\t\tvar elem = elems[ 0 ];\r\n\r\n\t\tif ( not ) {\r\n\t\t\texpr = \":not(\" + expr + \")\";\r\n\t\t}\r\n\r\n\t\treturn elems.length === 1 && elem.nodeType === 1 ?\r\n\t\t\tjQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\r\n\t\t\tjQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\r\n\t\t\t\treturn elem.nodeType === 1;\r\n\t\t\t}));\r\n\t},\r\n\r\n\tdir: function( elem, dir, until ) {\r\n\t\tvar matched = [],\r\n\t\t\ttruncate = until !== undefined;\r\n\r\n\t\twhile ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {\r\n\t\t\tif ( elem.nodeType === 1 ) {\r\n\t\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tmatched.push( elem );\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn matched;\r\n\t},\r\n\r\n\tsibling: function( n, elem ) {\r\n\t\tvar matched = [];\r\n\r\n\t\tfor ( ; n; n = n.nextSibling ) {\r\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\r\n\t\t\t\tmatched.push( n );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn matched;\r\n\t}\r\n});\r\n\r\n// Implement the identical functionality for filter and not\r\nfunction winnow( elements, qualifier, not ) {\r\n\tif ( jQuery.isFunction( qualifier ) ) {\r\n\t\treturn jQuery.grep( elements, function( elem, i ) {\r\n\t\t\t/* jshint -W018 */\r\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\r\n\t\t});\r\n\r\n\t}\r\n\r\n\tif ( qualifier.nodeType ) {\r\n\t\treturn jQuery.grep( elements, function( elem ) {\r\n\t\t\treturn ( elem === qualifier ) !== not;\r\n\t\t});\r\n\r\n\t}\r\n\r\n\tif ( typeof qualifier === \"string\" ) {\r\n\t\tif ( isSimple.test( qualifier ) ) {\r\n\t\t\treturn jQuery.filter( qualifier, elements, not );\r\n\t\t}\r\n\r\n\t\tqualifier = jQuery.filter( qualifier, elements );\r\n\t}\r\n\r\n\treturn jQuery.grep( elements, function( elem ) {\r\n\t\treturn ( core_indexOf.call( qualifier, elem ) >= 0 ) !== not;\r\n\t});\r\n}\r\nvar rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\r\n\trtagName = /<([\\w:]+)/,\r\n\trhtml = /<|&#?\\w+;/,\r\n\trnoInnerhtml = /<(?:script|style|link)/i,\r\n\tmanipulation_rcheckableType = /^(?:checkbox|radio)$/i,\r\n\t// checked=\"checked\" or checked\r\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\r\n\trscriptType = /^$|\\/(?:java|ecma)script/i,\r\n\trscriptTypeMasked = /^true\\/(.*)/,\r\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\r\n\r\n\t// We have to close these tags to support XHTML (#13200)\r\n\twrapMap = {\r\n\r\n\t\t// Support: IE 9\r\n\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\r\n\r\n\t\tthead: [ 1, \"<table>\", \"</table>\" ],\r\n\t\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\r\n\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\r\n\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\r\n\r\n\t\t_default: [ 0, \"\", \"\" ]\r\n\t};\r\n\r\n// Support: IE 9\r\nwrapMap.optgroup = wrapMap.option;\r\n\r\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\r\nwrapMap.th = wrapMap.td;\r\n\r\njQuery.fn.extend({\r\n\ttext: function( value ) {\r\n\t\treturn jQuery.access( this, function( value ) {\r\n\t\t\treturn value === undefined ?\r\n\t\t\t\tjQuery.text( this ) :\r\n\t\t\t\tthis.empty().append( ( this[ 0 ] && this[ 0 ].ownerDocument || document ).createTextNode( value ) );\r\n\t\t}, null, value, arguments.length );\r\n\t},\r\n\r\n\tappend: function() {\r\n\t\treturn this.domManip( arguments, function( elem ) {\r\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\r\n\t\t\t\tvar target = manipulationTarget( this, elem );\r\n\t\t\t\ttarget.appendChild( elem );\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\tprepend: function() {\r\n\t\treturn this.domManip( arguments, function( elem ) {\r\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\r\n\t\t\t\tvar target = manipulationTarget( this, elem );\r\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\tbefore: function() {\r\n\t\treturn this.domManip( arguments, function( elem ) {\r\n\t\t\tif ( this.parentNode ) {\r\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\tafter: function() {\r\n\t\treturn this.domManip( arguments, function( elem ) {\r\n\t\t\tif ( this.parentNode ) {\r\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\t// keepData is for internal use only--do not document\r\n\tremove: function( selector, keepData ) {\r\n\t\tvar elem,\r\n\t\t\telems = selector ? jQuery.filter( selector, this ) : this,\r\n\t\t\ti = 0;\r\n\r\n\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\r\n\t\t\tif ( !keepData && elem.nodeType === 1 ) {\r\n\t\t\t\tjQuery.cleanData( getAll( elem ) );\r\n\t\t\t}\r\n\r\n\t\t\tif ( elem.parentNode ) {\r\n\t\t\t\tif ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\r\n\t\t\t\t\tsetGlobalEval( getAll( elem, \"script\" ) );\r\n\t\t\t\t}\r\n\t\t\t\telem.parentNode.removeChild( elem );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tempty: function() {\r\n\t\tvar elem,\r\n\t\t\ti = 0;\r\n\r\n\t\tfor ( ; (elem = this[i]) != null; i++ ) {\r\n\t\t\tif ( elem.nodeType === 1 ) {\r\n\r\n\t\t\t\t// Prevent memory leaks\r\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\r\n\r\n\t\t\t\t// Remove any remaining nodes\r\n\t\t\t\telem.textContent = \"\";\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\r\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\r\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\r\n\r\n\t\treturn this.map( function () {\r\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\r\n\t\t});\r\n\t},\r\n\r\n\thtml: function( value ) {\r\n\t\treturn jQuery.access( this, function( value ) {\r\n\t\t\tvar elem = this[ 0 ] || {},\r\n\t\t\t\ti = 0,\r\n\t\t\t\tl = this.length;\r\n\r\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\r\n\t\t\t\treturn elem.innerHTML;\r\n\t\t\t}\r\n\r\n\t\t\t// See if we can take a shortcut and just use innerHTML\r\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\r\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\r\n\r\n\t\t\t\tvalue = value.replace( rxhtmlTag, \"<$1></$2>\" );\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\tfor ( ; i < l; i++ ) {\r\n\t\t\t\t\t\telem = this[ i ] || {};\r\n\r\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\r\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\r\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\r\n\t\t\t\t\t\t\telem.innerHTML = value;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\telem = 0;\r\n\r\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\r\n\t\t\t\t} catch( e ) {}\r\n\t\t\t}\r\n\r\n\t\t\tif ( elem ) {\r\n\t\t\t\tthis.empty().append( value );\r\n\t\t\t}\r\n\t\t}, null, value, arguments.length );\r\n\t},\r\n\r\n\treplaceWith: function() {\r\n\t\tvar\r\n\t\t\t// Snapshot the DOM in case .domManip sweeps something relevant into its fragment\r\n\t\t\targs = jQuery.map( this, function( elem ) {\r\n\t\t\t\treturn [ elem.nextSibling, elem.parentNode ];\r\n\t\t\t}),\r\n\t\t\ti = 0;\r\n\r\n\t\t// Make the changes, replacing each context element with the new content\r\n\t\tthis.domManip( arguments, function( elem ) {\r\n\t\t\tvar next = args[ i++ ],\r\n\t\t\t\tparent = args[ i++ ];\r\n\r\n\t\t\tif ( parent ) {\r\n\t\t\t\t// Don't use the snapshot next if it has moved (#13810)\r\n\t\t\t\tif ( next && next.parentNode !== parent ) {\r\n\t\t\t\t\tnext = this.nextSibling;\r\n\t\t\t\t}\r\n\t\t\t\tjQuery( this ).remove();\r\n\t\t\t\tparent.insertBefore( elem, next );\r\n\t\t\t}\r\n\t\t// Allow new content to include elements from the context set\r\n\t\t}, true );\r\n\r\n\t\t// Force removal if there was no new content (e.g., from empty arguments)\r\n\t\treturn i ? this : this.remove();\r\n\t},\r\n\r\n\tdetach: function( selector ) {\r\n\t\treturn this.remove( selector, true );\r\n\t},\r\n\r\n\tdomManip: function( args, callback, allowIntersection ) {\r\n\r\n\t\t// Flatten any nested arrays\r\n\t\targs = core_concat.apply( [], args );\r\n\r\n\t\tvar fragment, first, scripts, hasScripts, node, doc,\r\n\t\t\ti = 0,\r\n\t\t\tl = this.length,\r\n\t\t\tset = this,\r\n\t\t\tiNoClone = l - 1,\r\n\t\t\tvalue = args[ 0 ],\r\n\t\t\tisFunction = jQuery.isFunction( value );\r\n\r\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\r\n\t\tif ( isFunction || !( l <= 1 || typeof value !== \"string\" || jQuery.support.checkClone || !rchecked.test( value ) ) ) {\r\n\t\t\treturn this.each(function( index ) {\r\n\t\t\t\tvar self = set.eq( index );\r\n\t\t\t\tif ( isFunction ) {\r\n\t\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\r\n\t\t\t\t}\r\n\t\t\t\tself.domManip( args, callback, allowIntersection );\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif ( l ) {\r\n\t\t\tfragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, !allowIntersection && this );\r\n\t\t\tfirst = fragment.firstChild;\r\n\r\n\t\t\tif ( fragment.childNodes.length === 1 ) {\r\n\t\t\t\tfragment = first;\r\n\t\t\t}\r\n\r\n\t\t\tif ( first ) {\r\n\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\r\n\t\t\t\thasScripts = scripts.length;\r\n\r\n\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\r\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\r\n\t\t\t\tfor ( ; i < l; i++ ) {\r\n\t\t\t\t\tnode = fragment;\r\n\r\n\t\t\t\t\tif ( i !== iNoClone ) {\r\n\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\r\n\r\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\r\n\t\t\t\t\t\tif ( hasScripts ) {\r\n\t\t\t\t\t\t\t// Support: QtWebKit\r\n\t\t\t\t\t\t\t// jQuery.merge because core_push.apply(_, arraylike) throws\r\n\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcallback.call( this[ i ], node, i );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( hasScripts ) {\r\n\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\r\n\r\n\t\t\t\t\t// Reenable scripts\r\n\t\t\t\t\tjQuery.map( scripts, restoreScript );\r\n\r\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\r\n\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\r\n\t\t\t\t\t\tnode = scripts[ i ];\r\n\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\r\n\t\t\t\t\t\t\t!data_priv.access( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\r\n\r\n\t\t\t\t\t\t\tif ( node.src ) {\r\n\t\t\t\t\t\t\t\t// Hope ajax is available...\r\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tjQuery.globalEval( node.textContent.replace( rcleanScript, \"\" ) );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\njQuery.each({\r\n\tappendTo: \"append\",\r\n\tprependTo: \"prepend\",\r\n\tinsertBefore: \"before\",\r\n\tinsertAfter: \"after\",\r\n\treplaceAll: \"replaceWith\"\r\n}, function( name, original ) {\r\n\tjQuery.fn[ name ] = function( selector ) {\r\n\t\tvar elems,\r\n\t\t\tret = [],\r\n\t\t\tinsert = jQuery( selector ),\r\n\t\t\tlast = insert.length - 1,\r\n\t\t\ti = 0;\r\n\r\n\t\tfor ( ; i <= last; i++ ) {\r\n\t\t\telems = i === last ? this : this.clone( true );\r\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\r\n\r\n\t\t\t// Support: QtWebKit\r\n\t\t\t// .get() because core_push.apply(_, arraylike) throws\r\n\t\t\tcore_push.apply( ret, elems.get() );\r\n\t\t}\r\n\r\n\t\treturn this.pushStack( ret );\r\n\t};\r\n});\r\n\r\njQuery.extend({\r\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\r\n\t\tvar i, l, srcElements, destElements,\r\n\t\t\tclone = elem.cloneNode( true ),\r\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\r\n\r\n\t\t// Support: IE >= 9\r\n\t\t// Fix Cloning issues\r\n\t\tif ( !jQuery.support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) && !jQuery.isXMLDoc( elem ) ) {\r\n\r\n\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\r\n\t\t\tdestElements = getAll( clone );\r\n\t\t\tsrcElements = getAll( elem );\r\n\r\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\r\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Copy the events from the original to the clone\r\n\t\tif ( dataAndEvents ) {\r\n\t\t\tif ( deepDataAndEvents ) {\r\n\t\t\t\tsrcElements = srcElements || getAll( elem );\r\n\t\t\t\tdestElements = destElements || getAll( clone );\r\n\r\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\r\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcloneCopyEvent( elem, clone );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Preserve script evaluation history\r\n\t\tdestElements = getAll( clone, \"script\" );\r\n\t\tif ( destElements.length > 0 ) {\r\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\r\n\t\t}\r\n\r\n\t\t// Return the cloned set\r\n\t\treturn clone;\r\n\t},\r\n\r\n\tbuildFragment: function( elems, context, scripts, selection ) {\r\n\t\tvar elem, tmp, tag, wrap, contains, j,\r\n\t\t\ti = 0,\r\n\t\t\tl = elems.length,\r\n\t\t\tfragment = context.createDocumentFragment(),\r\n\t\t\tnodes = [];\r\n\r\n\t\tfor ( ; i < l; i++ ) {\r\n\t\t\telem = elems[ i ];\r\n\r\n\t\t\tif ( elem || elem === 0 ) {\r\n\r\n\t\t\t\t// Add nodes directly\r\n\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\r\n\t\t\t\t\t// Support: QtWebKit\r\n\t\t\t\t\t// jQuery.merge because core_push.apply(_, arraylike) throws\r\n\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\r\n\r\n\t\t\t\t// Convert non-html into a text node\r\n\t\t\t\t} else if ( !rhtml.test( elem ) ) {\r\n\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\r\n\r\n\t\t\t\t// Convert html into DOM nodes\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement(\"div\") );\r\n\r\n\t\t\t\t\t// Deserialize a standard representation\r\n\t\t\t\t\ttag = ( rtagName.exec( elem ) || [\"\", \"\"] )[ 1 ].toLowerCase();\r\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\r\n\t\t\t\t\ttmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[ 2 ];\r\n\r\n\t\t\t\t\t// Descend through wrappers to the right content\r\n\t\t\t\t\tj = wrap[ 0 ];\r\n\t\t\t\t\twhile ( j-- ) {\r\n\t\t\t\t\t\ttmp = tmp.lastChild;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Support: QtWebKit\r\n\t\t\t\t\t// jQuery.merge because core_push.apply(_, arraylike) throws\r\n\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\r\n\r\n\t\t\t\t\t// Remember the top-level container\r\n\t\t\t\t\ttmp = fragment.firstChild;\r\n\r\n\t\t\t\t\t// Fixes #12346\r\n\t\t\t\t\t// Support: Webkit, IE\r\n\t\t\t\t\ttmp.textContent = \"\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Remove wrapper from fragment\r\n\t\tfragment.textContent = \"\";\r\n\r\n\t\ti = 0;\r\n\t\twhile ( (elem = nodes[ i++ ]) ) {\r\n\r\n\t\t\t// #4087 - If origin and destination elements are the same, and this is\r\n\t\t\t// that element, do not do anything\r\n\t\t\tif ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\r\n\r\n\t\t\t// Append to fragment\r\n\t\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\r\n\r\n\t\t\t// Preserve script evaluation history\r\n\t\t\tif ( contains ) {\r\n\t\t\t\tsetGlobalEval( tmp );\r\n\t\t\t}\r\n\r\n\t\t\t// Capture executables\r\n\t\t\tif ( scripts ) {\r\n\t\t\t\tj = 0;\r\n\t\t\t\twhile ( (elem = tmp[ j++ ]) ) {\r\n\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\r\n\t\t\t\t\t\tscripts.push( elem );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn fragment;\r\n\t},\r\n\r\n\tcleanData: function( elems ) {\r\n\t\tvar data, elem, events, type, key, j,\r\n\t\t\tspecial = jQuery.event.special,\r\n\t\t\ti = 0;\r\n\r\n\t\tfor ( ; (elem = elems[ i ]) !== undefined; i++ ) {\r\n\t\t\tif ( Data.accepts( elem ) ) {\r\n\t\t\t\tkey = elem[ data_priv.expando ];\r\n\r\n\t\t\t\tif ( key && (data = data_priv.cache[ key ]) ) {\r\n\t\t\t\t\tevents = Object.keys( data.events || {} );\r\n\t\t\t\t\tif ( events.length ) {\r\n\t\t\t\t\t\tfor ( j = 0; (type = events[j]) !== undefined; j++ ) {\r\n\t\t\t\t\t\t\tif ( special[ type ] ) {\r\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\r\n\r\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( data_priv.cache[ key ] ) {\r\n\t\t\t\t\t\t// Discard any remaining `private` data\r\n\t\t\t\t\t\tdelete data_priv.cache[ key ];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Discard any remaining `user` data\r\n\t\t\tdelete data_user.cache[ elem[ data_user.expando ] ];\r\n\t\t}\r\n\t},\r\n\r\n\t_evalUrl: function( url ) {\r\n\t\treturn jQuery.ajax({\r\n\t\t\turl: url,\r\n\t\t\ttype: \"GET\",\r\n\t\t\tdataType: \"script\",\r\n\t\t\tasync: false,\r\n\t\t\tglobal: false,\r\n\t\t\t\"throws\": true\r\n\t\t});\r\n\t}\r\n});\r\n\r\n// Support: 1.x compatibility\r\n// Manipulating tables requires a tbody\r\nfunction manipulationTarget( elem, content ) {\r\n\treturn jQuery.nodeName( elem, \"table\" ) &&\r\n\t\tjQuery.nodeName( content.nodeType === 1 ? content : content.firstChild, \"tr\" ) ?\r\n\r\n\t\telem.getElementsByTagName(\"tbody\")[0] ||\r\n\t\t\telem.appendChild( elem.ownerDocument.createElement(\"tbody\") ) :\r\n\t\telem;\r\n}\r\n\r\n// Replace/restore the type attribute of script elements for safe DOM manipulation\r\nfunction disableScript( elem ) {\r\n\telem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\r\n\treturn elem;\r\n}\r\nfunction restoreScript( elem ) {\r\n\tvar match = rscriptTypeMasked.exec( elem.type );\r\n\r\n\tif ( match ) {\r\n\t\telem.type = match[ 1 ];\r\n\t} else {\r\n\t\telem.removeAttribute(\"type\");\r\n\t}\r\n\r\n\treturn elem;\r\n}\r\n\r\n// Mark scripts as having already been evaluated\r\nfunction setGlobalEval( elems, refElements ) {\r\n\tvar l = elems.length,\r\n\t\ti = 0;\r\n\r\n\tfor ( ; i < l; i++ ) {\r\n\t\tdata_priv.set(\r\n\t\t\telems[ i ], \"globalEval\", !refElements || data_priv.get( refElements[ i ], \"globalEval\" )\r\n\t\t);\r\n\t}\r\n}\r\n\r\nfunction cloneCopyEvent( src, dest ) {\r\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\r\n\r\n\tif ( dest.nodeType !== 1 ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// 1. Copy private data: events, handlers, etc.\r\n\tif ( data_priv.hasData( src ) ) {\r\n\t\tpdataOld = data_priv.access( src );\r\n\t\tpdataCur = data_priv.set( dest, pdataOld );\r\n\t\tevents = pdataOld.events;\r\n\r\n\t\tif ( events ) {\r\n\t\t\tdelete pdataCur.handle;\r\n\t\t\tpdataCur.events = {};\r\n\r\n\t\t\tfor ( type in events ) {\r\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\r\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// 2. Copy user data\r\n\tif ( data_user.hasData( src ) ) {\r\n\t\tudataOld = data_user.access( src );\r\n\t\tudataCur = jQuery.extend( {}, udataOld );\r\n\r\n\t\tdata_user.set( dest, udataCur );\r\n\t}\r\n}\r\n\r\n\r\nfunction getAll( context, tag ) {\r\n\tvar ret = context.getElementsByTagName ? context.getElementsByTagName( tag || \"*\" ) :\r\n\t\t\tcontext.querySelectorAll ? context.querySelectorAll( tag || \"*\" ) :\r\n\t\t\t[];\r\n\r\n\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\r\n\t\tjQuery.merge( [ context ], ret ) :\r\n\t\tret;\r\n}\r\n\r\n// Support: IE >= 9\r\nfunction fixInput( src, dest ) {\r\n\tvar nodeName = dest.nodeName.toLowerCase();\r\n\r\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\r\n\tif ( nodeName === \"input\" && manipulation_rcheckableType.test( src.type ) ) {\r\n\t\tdest.checked = src.checked;\r\n\r\n\t// Fails to return the selected option to the default selected state when cloning options\r\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\r\n\t\tdest.defaultValue = src.defaultValue;\r\n\t}\r\n}\r\njQuery.fn.extend({\r\n\twrapAll: function( html ) {\r\n\t\tvar wrap;\r\n\r\n\t\tif ( jQuery.isFunction( html ) ) {\r\n\t\t\treturn this.each(function( i ) {\r\n\t\t\t\tjQuery( this ).wrapAll( html.call(this, i) );\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif ( this[ 0 ] ) {\r\n\r\n\t\t\t// The elements to wrap the target around\r\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\r\n\r\n\t\t\tif ( this[ 0 ].parentNode ) {\r\n\t\t\t\twrap.insertBefore( this[ 0 ] );\r\n\t\t\t}\r\n\r\n\t\t\twrap.map(function() {\r\n\t\t\t\tvar elem = this;\r\n\r\n\t\t\t\twhile ( elem.firstElementChild ) {\r\n\t\t\t\t\telem = elem.firstElementChild;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn elem;\r\n\t\t\t}).append( this );\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\twrapInner: function( html ) {\r\n\t\tif ( jQuery.isFunction( html ) ) {\r\n\t\t\treturn this.each(function( i ) {\r\n\t\t\t\tjQuery( this ).wrapInner( html.call(this, i) );\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn this.each(function() {\r\n\t\t\tvar self = jQuery( this ),\r\n\t\t\t\tcontents = self.contents();\r\n\r\n\t\t\tif ( contents.length ) {\r\n\t\t\t\tcontents.wrapAll( html );\r\n\r\n\t\t\t} else {\r\n\t\t\t\tself.append( html );\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\twrap: function( html ) {\r\n\t\tvar isFunction = jQuery.isFunction( html );\r\n\r\n\t\treturn this.each(function( i ) {\r\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\r\n\t\t});\r\n\t},\r\n\r\n\tunwrap: function() {\r\n\t\treturn this.parent().each(function() {\r\n\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\r\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\r\n\t\t\t}\r\n\t\t}).end();\r\n\t}\r\n});\r\nvar curCSS, iframe,\r\n\t// swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\r\n\t// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\r\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\r\n\trmargin = /^margin/,\r\n\trnumsplit = new RegExp( \"^(\" + core_pnum + \")(.*)$\", \"i\" ),\r\n\trnumnonpx = new RegExp( \"^(\" + core_pnum + \")(?!px)[a-z%]+$\", \"i\" ),\r\n\trrelNum = new RegExp( \"^([+-])=(\" + core_pnum + \")\", \"i\" ),\r\n\telemdisplay = { BODY: \"block\" },\r\n\r\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\r\n\tcssNormalTransform = {\r\n\t\tletterSpacing: 0,\r\n\t\tfontWeight: 400\r\n\t},\r\n\r\n\tcssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ],\r\n\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\r\n\r\n// return a css property mapped to a potentially vendor prefixed property\r\nfunction vendorPropName( style, name ) {\r\n\r\n\t// shortcut for names that are not vendor prefixed\r\n\tif ( name in style ) {\r\n\t\treturn name;\r\n\t}\r\n\r\n\t// check for vendor prefixed names\r\n\tvar capName = name.charAt(0).toUpperCase() + name.slice(1),\r\n\t\torigName = name,\r\n\t\ti = cssPrefixes.length;\r\n\r\n\twhile ( i-- ) {\r\n\t\tname = cssPrefixes[ i ] + capName;\r\n\t\tif ( name in style ) {\r\n\t\t\treturn name;\r\n\t\t}\r\n\t}\r\n\r\n\treturn origName;\r\n}\r\n\r\nfunction isHidden( elem, el ) {\r\n\t// isHidden might be called from jQuery#filter function;\r\n\t// in that case, element will be second argument\r\n\telem = el || elem;\r\n\treturn jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\r\n}\r\n\r\n// NOTE: we've included the \"window\" in window.getComputedStyle\r\n// because jsdom on node.js will break without it.\r\nfunction getStyles( elem ) {\r\n\treturn window.getComputedStyle( elem, null );\r\n}\r\n\r\nfunction showHide( elements, show ) {\r\n\tvar display, elem, hidden,\r\n\t\tvalues = [],\r\n\t\tindex = 0,\r\n\t\tlength = elements.length;\r\n\r\n\tfor ( ; index < length; index++ ) {\r\n\t\telem = elements[ index ];\r\n\t\tif ( !elem.style ) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tvalues[ index ] = data_priv.get( elem, \"olddisplay\" );\r\n\t\tdisplay = elem.style.display;\r\n\t\tif ( show ) {\r\n\t\t\t// Reset the inline display of this element to learn if it is\r\n\t\t\t// being hidden by cascaded rules or not\r\n\t\t\tif ( !values[ index ] && display === \"none\" ) {\r\n\t\t\t\telem.style.display = \"\";\r\n\t\t\t}\r\n\r\n\t\t\t// Set elements which have been overridden with display: none\r\n\t\t\t// in a stylesheet to whatever the default browser style is\r\n\t\t\t// for such an element\r\n\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\r\n\t\t\t\tvalues[ index ] = data_priv.access( elem, \"olddisplay\", css_defaultDisplay(elem.nodeName) );\r\n\t\t\t}\r\n\t\t} else {\r\n\r\n\t\t\tif ( !values[ index ] ) {\r\n\t\t\t\thidden = isHidden( elem );\r\n\r\n\t\t\t\tif ( display && display !== \"none\" || !hidden ) {\r\n\t\t\t\t\tdata_priv.set( elem, \"olddisplay\", hidden ? display : jQuery.css(elem, \"display\") );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Set the display of most of the elements in a second loop\r\n\t// to avoid the constant reflow\r\n\tfor ( index = 0; index < length; index++ ) {\r\n\t\telem = elements[ index ];\r\n\t\tif ( !elem.style ) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\r\n\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\r\n\t\t}\r\n\t}\r\n\r\n\treturn elements;\r\n}\r\n\r\njQuery.fn.extend({\r\n\tcss: function( name, value ) {\r\n\t\treturn jQuery.access( this, function( elem, name, value ) {\r\n\t\t\tvar styles, len,\r\n\t\t\t\tmap = {},\r\n\t\t\t\ti = 0;\r\n\r\n\t\t\tif ( jQuery.isArray( name ) ) {\r\n\t\t\t\tstyles = getStyles( elem );\r\n\t\t\t\tlen = name.length;\r\n\r\n\t\t\t\tfor ( ; i < len; i++ ) {\r\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn map;\r\n\t\t\t}\r\n\r\n\t\t\treturn value !== undefined ?\r\n\t\t\t\tjQuery.style( elem, name, value ) :\r\n\t\t\t\tjQuery.css( elem, name );\r\n\t\t}, name, value, arguments.length > 1 );\r\n\t},\r\n\tshow: function() {\r\n\t\treturn showHide( this, true );\r\n\t},\r\n\thide: function() {\r\n\t\treturn showHide( this );\r\n\t},\r\n\ttoggle: function( state ) {\r\n\t\tif ( typeof state === \"boolean\" ) {\r\n\t\t\treturn state ? this.show() : this.hide();\r\n\t\t}\r\n\r\n\t\treturn this.each(function() {\r\n\t\t\tif ( isHidden( this ) ) {\r\n\t\t\t\tjQuery( this ).show();\r\n\t\t\t} else {\r\n\t\t\t\tjQuery( this ).hide();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n});\r\n\r\njQuery.extend({\r\n\t// Add in style property hooks for overriding the default\r\n\t// behavior of getting and setting a style property\r\n\tcssHooks: {\r\n\t\topacity: {\r\n\t\t\tget: function( elem, computed ) {\r\n\t\t\t\tif ( computed ) {\r\n\t\t\t\t\t// We should always get a number back from opacity\r\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\r\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// Don't automatically add \"px\" to these possibly-unitless properties\r\n\tcssNumber: {\r\n\t\t\"columnCount\": true,\r\n\t\t\"fillOpacity\": true,\r\n\t\t\"fontWeight\": true,\r\n\t\t\"lineHeight\": true,\r\n\t\t\"opacity\": true,\r\n\t\t\"order\": true,\r\n\t\t\"orphans\": true,\r\n\t\t\"widows\": true,\r\n\t\t\"zIndex\": true,\r\n\t\t\"zoom\": true\r\n\t},\r\n\r\n\t// Add in properties whose names you wish to fix before\r\n\t// setting or getting the value\r\n\tcssProps: {\r\n\t\t// normalize float css property\r\n\t\t\"float\": \"cssFloat\"\r\n\t},\r\n\r\n\t// Get and set the style property on a DOM Node\r\n\tstyle: function( elem, name, value, extra ) {\r\n\t\t// Don't set styles on text and comment nodes\r\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Make sure that we're working with the right name\r\n\t\tvar ret, type, hooks,\r\n\t\t\torigName = jQuery.camelCase( name ),\r\n\t\t\tstyle = elem.style;\r\n\r\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\r\n\r\n\t\t// gets hook for the prefixed version\r\n\t\t// followed by the unprefixed version\r\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\r\n\r\n\t\t// Check if we're setting a value\r\n\t\tif ( value !== undefined ) {\r\n\t\t\ttype = typeof value;\r\n\r\n\t\t\t// convert relative number strings (+= or -=) to relative numbers. #7345\r\n\t\t\tif ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\r\n\t\t\t\tvalue = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\r\n\t\t\t\t// Fixes bug #9237\r\n\t\t\t\ttype = \"number\";\r\n\t\t\t}\r\n\r\n\t\t\t// Make sure that NaN and null values aren't set. See: #7116\r\n\t\t\tif ( value == null || type === \"number\" && isNaN( value ) ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// If a number was passed in, add 'px' to the (except for certain CSS properties)\r\n\t\t\tif ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\r\n\t\t\t\tvalue += \"px\";\r\n\t\t\t}\r\n\r\n\t\t\t// Fixes #8908, it can be done more correctly by specifying setters in cssHooks,\r\n\t\t\t// but it would mean to define eight (for every problematic property) identical functions\r\n\t\t\tif ( !jQuery.support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0 ) {\r\n\t\t\t\tstyle[ name ] = \"inherit\";\r\n\t\t\t}\r\n\r\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\r\n\t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\r\n\t\t\t\tstyle[ name ] = value;\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\t// If a hook was provided get the non-computed value from there\r\n\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\r\n\t\t\t\treturn ret;\r\n\t\t\t}\r\n\r\n\t\t\t// Otherwise just get the value from the style object\r\n\t\t\treturn style[ name ];\r\n\t\t}\r\n\t},\r\n\r\n\tcss: function( elem, name, extra, styles ) {\r\n\t\tvar val, num, hooks,\r\n\t\t\torigName = jQuery.camelCase( name );\r\n\r\n\t\t// Make sure that we're working with the right name\r\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\r\n\r\n\t\t// gets hook for the prefixed version\r\n\t\t// followed by the unprefixed version\r\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\r\n\r\n\t\t// If a hook was provided get the computed value from there\r\n\t\tif ( hooks && \"get\" in hooks ) {\r\n\t\t\tval = hooks.get( elem, true, extra );\r\n\t\t}\r\n\r\n\t\t// Otherwise, if a way to get the computed value exists, use that\r\n\t\tif ( val === undefined ) {\r\n\t\t\tval = curCSS( elem, name, styles );\r\n\t\t}\r\n\r\n\t\t//convert \"normal\" to computed value\r\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\r\n\t\t\tval = cssNormalTransform[ name ];\r\n\t\t}\r\n\r\n\t\t// Return, converting to number if forced or a qualifier was provided and val looks numeric\r\n\t\tif ( extra === \"\" || extra ) {\r\n\t\t\tnum = parseFloat( val );\r\n\t\t\treturn extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\r\n\t\t}\r\n\t\treturn val;\r\n\t}\r\n});\r\n\r\ncurCSS = function( elem, name, _computed ) {\r\n\tvar width, minWidth, maxWidth,\r\n\t\tcomputed = _computed || getStyles( elem ),\r\n\r\n\t\t// Support: IE9\r\n\t\t// getPropertyValue is only needed for .css('filter') in IE9, see #12537\r\n\t\tret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,\r\n\t\tstyle = elem.style;\r\n\r\n\tif ( computed ) {\r\n\r\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\r\n\t\t\tret = jQuery.style( elem, name );\r\n\t\t}\r\n\r\n\t\t// Support: Safari 5.1\r\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\r\n\t\t// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\r\n\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\r\n\t\tif ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\r\n\r\n\t\t\t// Remember the original values\r\n\t\t\twidth = style.width;\r\n\t\t\tminWidth = style.minWidth;\r\n\t\t\tmaxWidth = style.maxWidth;\r\n\r\n\t\t\t// Put in the new values to get a computed value out\r\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\r\n\t\t\tret = computed.width;\r\n\r\n\t\t\t// Revert the changed values\r\n\t\t\tstyle.width = width;\r\n\t\t\tstyle.minWidth = minWidth;\r\n\t\t\tstyle.maxWidth = maxWidth;\r\n\t\t}\r\n\t}\r\n\r\n\treturn ret;\r\n};\r\n\r\n\r\nfunction setPositiveNumber( elem, value, subtract ) {\r\n\tvar matches = rnumsplit.exec( value );\r\n\treturn matches ?\r\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\r\n\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\r\n\t\tvalue;\r\n}\r\n\r\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\r\n\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\r\n\t\t// If we already have the right measurement, avoid augmentation\r\n\t\t4 :\r\n\t\t// Otherwise initialize for horizontal or vertical properties\r\n\t\tname === \"width\" ? 1 : 0,\r\n\r\n\t\tval = 0;\r\n\r\n\tfor ( ; i < 4; i += 2 ) {\r\n\t\t// both box models exclude margin, so add it if we want it\r\n\t\tif ( extra === \"margin\" ) {\r\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\r\n\t\t}\r\n\r\n\t\tif ( isBorderBox ) {\r\n\t\t\t// border-box includes padding, so remove it if we want content\r\n\t\t\tif ( extra === \"content\" ) {\r\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\r\n\t\t\t}\r\n\r\n\t\t\t// at this point, extra isn't border nor margin, so remove border\r\n\t\t\tif ( extra !== \"margin\" ) {\r\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// at this point, extra isn't content, so add padding\r\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\r\n\r\n\t\t\t// at this point, extra isn't content nor padding, so add border\r\n\t\t\tif ( extra !== \"padding\" ) {\r\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn val;\r\n}\r\n\r\nfunction getWidthOrHeight( elem, name, extra ) {\r\n\r\n\t// Start with offset property, which is equivalent to the border-box value\r\n\tvar valueIsBorderBox = true,\r\n\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\r\n\t\tstyles = getStyles( elem ),\r\n\t\tisBorderBox = jQuery.support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\r\n\r\n\t// some non-html elements return undefined for offsetWidth, so check for null/undefined\r\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\r\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\r\n\tif ( val <= 0 || val == null ) {\r\n\t\t// Fall back to computed then uncomputed css if necessary\r\n\t\tval = curCSS( elem, name, styles );\r\n\t\tif ( val < 0 || val == null ) {\r\n\t\t\tval = elem.style[ name ];\r\n\t\t}\r\n\r\n\t\t// Computed unit is not pixels. Stop here and return.\r\n\t\tif ( rnumnonpx.test(val) ) {\r\n\t\t\treturn val;\r\n\t\t}\r\n\r\n\t\t// we need the check for style in case a browser which returns unreliable values\r\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\r\n\t\tvalueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );\r\n\r\n\t\t// Normalize \"\", auto, and prepare for extra\r\n\t\tval = parseFloat( val ) || 0;\r\n\t}\r\n\r\n\t// use the active box-sizing model to add/subtract irrelevant styles\r\n\treturn ( val +\r\n\t\taugmentWidthOrHeight(\r\n\t\t\telem,\r\n\t\t\tname,\r\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\r\n\t\t\tvalueIsBorderBox,\r\n\t\t\tstyles\r\n\t\t)\r\n\t) + \"px\";\r\n}\r\n\r\n// Try to determine the default display value of an element\r\nfunction css_defaultDisplay( nodeName ) {\r\n\tvar doc = document,\r\n\t\tdisplay = elemdisplay[ nodeName ];\r\n\r\n\tif ( !display ) {\r\n\t\tdisplay = actualDisplay( nodeName, doc );\r\n\r\n\t\t// If the simple way fails, read from inside an iframe\r\n\t\tif ( display === \"none\" || !display ) {\r\n\t\t\t// Use the already-created iframe if possible\r\n\t\t\tiframe = ( iframe ||\r\n\t\t\t\tjQuery(\"<iframe frameborder='0' width='0' height='0'/>\")\r\n\t\t\t\t.css( \"cssText\", \"display:block !important\" )\r\n\t\t\t).appendTo( doc.documentElement );\r\n\r\n\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\r\n\t\t\tdoc = ( iframe[0].contentWindow || iframe[0].contentDocument ).document;\r\n\t\t\tdoc.write(\"<!doctype html><html><body>\");\r\n\t\t\tdoc.close();\r\n\r\n\t\t\tdisplay = actualDisplay( nodeName, doc );\r\n\t\t\tiframe.detach();\r\n\t\t}\r\n\r\n\t\t// Store the correct default display\r\n\t\telemdisplay[ nodeName ] = display;\r\n\t}\r\n\r\n\treturn display;\r\n}\r\n\r\n// Called ONLY from within css_defaultDisplay\r\nfunction actualDisplay( name, doc ) {\r\n\tvar elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\r\n\t\tdisplay = jQuery.css( elem[0], \"display\" );\r\n\telem.remove();\r\n\treturn display;\r\n}\r\n\r\njQuery.each([ \"height\", \"width\" ], function( i, name ) {\r\n\tjQuery.cssHooks[ name ] = {\r\n\t\tget: function( elem, computed, extra ) {\r\n\t\t\tif ( computed ) {\r\n\t\t\t\t// certain elements can have dimension info if we invisibly show them\r\n\t\t\t\t// however, it must have a current display style that would benefit from this\r\n\t\t\t\treturn elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, \"display\" ) ) ?\r\n\t\t\t\t\tjQuery.swap( elem, cssShow, function() {\r\n\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\r\n\t\t\t\t\t}) :\r\n\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tset: function( elem, value, extra ) {\r\n\t\t\tvar styles = extra && getStyles( elem );\r\n\t\t\treturn setPositiveNumber( elem, value, extra ?\r\n\t\t\t\taugmentWidthOrHeight(\r\n\t\t\t\t\telem,\r\n\t\t\t\t\tname,\r\n\t\t\t\t\textra,\r\n\t\t\t\t\tjQuery.support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\r\n\t\t\t\t\tstyles\r\n\t\t\t\t) : 0\r\n\t\t\t);\r\n\t\t}\r\n\t};\r\n});\r\n\r\n// These hooks cannot be added until DOM ready because the support test\r\n// for it is not run until after DOM ready\r\njQuery(function() {\r\n\t// Support: Android 2.3\r\n\tif ( !jQuery.support.reliableMarginRight ) {\r\n\t\tjQuery.cssHooks.marginRight = {\r\n\t\t\tget: function( elem, computed ) {\r\n\t\t\t\tif ( computed ) {\r\n\t\t\t\t\t// Support: Android 2.3\r\n\t\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\r\n\t\t\t\t\t// Work around by temporarily setting element display to inline-block\r\n\t\t\t\t\treturn jQuery.swap( elem, { \"display\": \"inline-block\" },\r\n\t\t\t\t\t\tcurCSS, [ elem, \"marginRight\" ] );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\t// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\r\n\t// getComputedStyle returns percent when specified for top/left/bottom/right\r\n\t// rather than make the css module depend on the offset module, we just check for it here\r\n\tif ( !jQuery.support.pixelPosition && jQuery.fn.position ) {\r\n\t\tjQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\r\n\t\t\tjQuery.cssHooks[ prop ] = {\r\n\t\t\t\tget: function( elem, computed ) {\r\n\t\t\t\t\tif ( computed ) {\r\n\t\t\t\t\t\tcomputed = curCSS( elem, prop );\r\n\t\t\t\t\t\t// if curCSS returns percentage, fallback to offset\r\n\t\t\t\t\t\treturn rnumnonpx.test( computed ) ?\r\n\t\t\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\r\n\t\t\t\t\t\t\tcomputed;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t});\r\n\t}\r\n\r\n});\r\n\r\nif ( jQuery.expr && jQuery.expr.filters ) {\r\n\tjQuery.expr.filters.hidden = function( elem ) {\r\n\t\t// Support: Opera <= 12.12\r\n\t\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\r\n\t\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0;\r\n\t};\r\n\r\n\tjQuery.expr.filters.visible = function( elem ) {\r\n\t\treturn !jQuery.expr.filters.hidden( elem );\r\n\t};\r\n}\r\n\r\n// These hooks are used by animate to expand properties\r\njQuery.each({\r\n\tmargin: \"\",\r\n\tpadding: \"\",\r\n\tborder: \"Width\"\r\n}, function( prefix, suffix ) {\r\n\tjQuery.cssHooks[ prefix + suffix ] = {\r\n\t\texpand: function( value ) {\r\n\t\t\tvar i = 0,\r\n\t\t\t\texpanded = {},\r\n\r\n\t\t\t\t// assumes a single number if not a string\r\n\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [ value ];\r\n\r\n\t\t\tfor ( ; i < 4; i++ ) {\r\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\r\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\r\n\t\t\t}\r\n\r\n\t\t\treturn expanded;\r\n\t\t}\r\n\t};\r\n\r\n\tif ( !rmargin.test( prefix ) ) {\r\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\r\n\t}\r\n});\r\nvar r20 = /%20/g,\r\n\trbracket = /\\[\\]$/,\r\n\trCRLF = /\\r?\\n/g,\r\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\r\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\r\n\r\njQuery.fn.extend({\r\n\tserialize: function() {\r\n\t\treturn jQuery.param( this.serializeArray() );\r\n\t},\r\n\tserializeArray: function() {\r\n\t\treturn this.map(function(){\r\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\r\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\r\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\r\n\t\t})\r\n\t\t.filter(function(){\r\n\t\t\tvar type = this.type;\r\n\t\t\t// Use .is(\":disabled\") so that fieldset[disabled] works\r\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\r\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\r\n\t\t\t\t( this.checked || !manipulation_rcheckableType.test( type ) );\r\n\t\t})\r\n\t\t.map(function( i, elem ){\r\n\t\t\tvar val = jQuery( this ).val();\r\n\r\n\t\t\treturn val == null ?\r\n\t\t\t\tnull :\r\n\t\t\t\tjQuery.isArray( val ) ?\r\n\t\t\t\t\tjQuery.map( val, function( val ){\r\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\r\n\t\t\t\t\t}) :\r\n\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\r\n\t\t}).get();\r\n\t}\r\n});\r\n\r\n//Serialize an array of form elements or a set of\r\n//key/values into a query string\r\njQuery.param = function( a, traditional ) {\r\n\tvar prefix,\r\n\t\ts = [],\r\n\t\tadd = function( key, value ) {\r\n\t\t\t// If value is a function, invoke it and return its value\r\n\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\r\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\r\n\t\t};\r\n\r\n\t// Set traditional to true for jQuery <= 1.3.2 behavior.\r\n\tif ( traditional === undefined ) {\r\n\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\r\n\t}\r\n\r\n\t// If an array was passed in, assume that it is an array of form elements.\r\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\r\n\t\t// Serialize the form elements\r\n\t\tjQuery.each( a, function() {\r\n\t\t\tadd( this.name, this.value );\r\n\t\t});\r\n\r\n\t} else {\r\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\r\n\t\t// did it), otherwise encode params recursively.\r\n\t\tfor ( prefix in a ) {\r\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\r\n\t\t}\r\n\t}\r\n\r\n\t// Return the resulting serialization\r\n\treturn s.join( \"&\" ).replace( r20, \"+\" );\r\n};\r\n\r\nfunction buildParams( prefix, obj, traditional, add ) {\r\n\tvar name;\r\n\r\n\tif ( jQuery.isArray( obj ) ) {\r\n\t\t// Serialize array item.\r\n\t\tjQuery.each( obj, function( i, v ) {\r\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\r\n\t\t\t\t// Treat each array item as a scalar.\r\n\t\t\t\tadd( prefix, v );\r\n\r\n\t\t\t} else {\r\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\r\n\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\r\n\t\t// Serialize object item.\r\n\t\tfor ( name in obj ) {\r\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\r\n\t\t}\r\n\r\n\t} else {\r\n\t\t// Serialize scalar item.\r\n\t\tadd( prefix, obj );\r\n\t}\r\n}\r\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\r\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\r\n\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\r\n\r\n\t// Handle event binding\r\n\tjQuery.fn[ name ] = function( data, fn ) {\r\n\t\treturn arguments.length > 0 ?\r\n\t\t\tthis.on( name, null, data, fn ) :\r\n\t\t\tthis.trigger( name );\r\n\t};\r\n});\r\n\r\njQuery.fn.extend({\r\n\thover: function( fnOver, fnOut ) {\r\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\r\n\t},\r\n\r\n\tbind: function( types, data, fn ) {\r\n\t\treturn this.on( types, null, data, fn );\r\n\t},\r\n\tunbind: function( types, fn ) {\r\n\t\treturn this.off( types, null, fn );\r\n\t},\r\n\r\n\tdelegate: function( selector, types, data, fn ) {\r\n\t\treturn this.on( types, selector, data, fn );\r\n\t},\r\n\tundelegate: function( selector, types, fn ) {\r\n\t\t// ( namespace ) or ( selector, types [, fn] )\r\n\t\treturn arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\r\n\t}\r\n});\r\nvar\r\n\t// Document location\r\n\tajaxLocParts,\r\n\tajaxLocation,\r\n\r\n\tajax_nonce = jQuery.now(),\r\n\r\n\tajax_rquery = /\\?/,\r\n\trhash = /#.*$/,\r\n\trts = /([?&])_=[^&]*/,\r\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\r\n\t// #7653, #8125, #8152: local protocol detection\r\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\r\n\trnoContent = /^(?:GET|HEAD)$/,\r\n\trprotocol = /^\\/\\//,\r\n\trurl = /^([\\w.+-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+)|)|)/,\r\n\r\n\t// Keep a copy of the old load method\r\n\t_load = jQuery.fn.load,\r\n\r\n\t/* Prefilters\r\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\r\n\t * 2) These are called:\r\n\t *    - BEFORE asking for a transport\r\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\r\n\t * 3) key is the dataType\r\n\t * 4) the catchall symbol \"*\" can be used\r\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\r\n\t */\r\n\tprefilters = {},\r\n\r\n\t/* Transports bindings\r\n\t * 1) key is the dataType\r\n\t * 2) the catchall symbol \"*\" can be used\r\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\r\n\t */\r\n\ttransports = {},\r\n\r\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\r\n\tallTypes = \"*/\".concat(\"*\");\r\n\r\n// #8138, IE may throw an exception when accessing\r\n// a field from window.location if document.domain has been set\r\ntry {\r\n\tajaxLocation = location.href;\r\n} catch( e ) {\r\n\t// Use the href attribute of an A element\r\n\t// since IE will modify it given document.location\r\n\tajaxLocation = document.createElement( \"a\" );\r\n\tajaxLocation.href = \"\";\r\n\tajaxLocation = ajaxLocation.href;\r\n}\r\n\r\n// Segment location into parts\r\najaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\r\n\r\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\r\nfunction addToPrefiltersOrTransports( structure ) {\r\n\r\n\t// dataTypeExpression is optional and defaults to \"*\"\r\n\treturn function( dataTypeExpression, func ) {\r\n\r\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\r\n\t\t\tfunc = dataTypeExpression;\r\n\t\t\tdataTypeExpression = \"*\";\r\n\t\t}\r\n\r\n\t\tvar dataType,\r\n\t\t\ti = 0,\r\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( core_rnotwhite ) || [];\r\n\r\n\t\tif ( jQuery.isFunction( func ) ) {\r\n\t\t\t// For each dataType in the dataTypeExpression\r\n\t\t\twhile ( (dataType = dataTypes[i++]) ) {\r\n\t\t\t\t// Prepend if requested\r\n\t\t\t\tif ( dataType[0] === \"+\" ) {\r\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\r\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\r\n\r\n\t\t\t\t// Otherwise append\r\n\t\t\t\t} else {\r\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).push( func );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\n// Base inspection function for prefilters and transports\r\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\r\n\r\n\tvar inspected = {},\r\n\t\tseekingTransport = ( structure === transports );\r\n\r\n\tfunction inspect( dataType ) {\r\n\t\tvar selected;\r\n\t\tinspected[ dataType ] = true;\r\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\r\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\r\n\t\t\tif( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\r\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\r\n\t\t\t\tinspect( dataTypeOrTransport );\r\n\t\t\t\treturn false;\r\n\t\t\t} else if ( seekingTransport ) {\r\n\t\t\t\treturn !( selected = dataTypeOrTransport );\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn selected;\r\n\t}\r\n\r\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\r\n}\r\n\r\n// A special extend for ajax options\r\n// that takes \"flat\" options (not to be deep extended)\r\n// Fixes #9887\r\nfunction ajaxExtend( target, src ) {\r\n\tvar key, deep,\r\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\r\n\r\n\tfor ( key in src ) {\r\n\t\tif ( src[ key ] !== undefined ) {\r\n\t\t\t( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\r\n\t\t}\r\n\t}\r\n\tif ( deep ) {\r\n\t\tjQuery.extend( true, target, deep );\r\n\t}\r\n\r\n\treturn target;\r\n}\r\n\r\njQuery.fn.load = function( url, params, callback ) {\r\n\tif ( typeof url !== \"string\" && _load ) {\r\n\t\treturn _load.apply( this, arguments );\r\n\t}\r\n\r\n\tvar selector, type, response,\r\n\t\tself = this,\r\n\t\toff = url.indexOf(\" \");\r\n\r\n\tif ( off >= 0 ) {\r\n\t\tselector = url.slice( off );\r\n\t\turl = url.slice( 0, off );\r\n\t}\r\n\r\n\t// If it's a function\r\n\tif ( jQuery.isFunction( params ) ) {\r\n\r\n\t\t// We assume that it's the callback\r\n\t\tcallback = params;\r\n\t\tparams = undefined;\r\n\r\n\t// Otherwise, build a param string\r\n\t} else if ( params && typeof params === \"object\" ) {\r\n\t\ttype = \"POST\";\r\n\t}\r\n\r\n\t// If we have elements to modify, make the request\r\n\tif ( self.length > 0 ) {\r\n\t\tjQuery.ajax({\r\n\t\t\turl: url,\r\n\r\n\t\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\r\n\t\t\ttype: type,\r\n\t\t\tdataType: \"html\",\r\n\t\t\tdata: params\r\n\t\t}).done(function( responseText ) {\r\n\r\n\t\t\t// Save response for use in complete callback\r\n\t\t\tresponse = arguments;\r\n\r\n\t\t\tself.html( selector ?\r\n\r\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\r\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\r\n\t\t\t\tjQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\r\n\r\n\t\t\t\t// Otherwise use the full result\r\n\t\t\t\tresponseText );\r\n\r\n\t\t}).complete( callback && function( jqXHR, status ) {\r\n\t\t\tself.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\r\n\t\t});\r\n\t}\r\n\r\n\treturn this;\r\n};\r\n\r\n// Attach a bunch of functions for handling common AJAX events\r\njQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ){\r\n\tjQuery.fn[ type ] = function( fn ){\r\n\t\treturn this.on( type, fn );\r\n\t};\r\n});\r\n\r\njQuery.extend({\r\n\r\n\t// Counter for holding the number of active queries\r\n\tactive: 0,\r\n\r\n\t// Last-Modified header cache for next request\r\n\tlastModified: {},\r\n\tetag: {},\r\n\r\n\tajaxSettings: {\r\n\t\turl: ajaxLocation,\r\n\t\ttype: \"GET\",\r\n\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\r\n\t\tglobal: true,\r\n\t\tprocessData: true,\r\n\t\tasync: true,\r\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\r\n\t\t/*\r\n\t\ttimeout: 0,\r\n\t\tdata: null,\r\n\t\tdataType: null,\r\n\t\tusername: null,\r\n\t\tpassword: null,\r\n\t\tcache: null,\r\n\t\tthrows: false,\r\n\t\ttraditional: false,\r\n\t\theaders: {},\r\n\t\t*/\r\n\r\n\t\taccepts: {\r\n\t\t\t\"*\": allTypes,\r\n\t\t\ttext: \"text/plain\",\r\n\t\t\thtml: \"text/html\",\r\n\t\t\txml: \"application/xml, text/xml\",\r\n\t\t\tjson: \"application/json, text/javascript\"\r\n\t\t},\r\n\r\n\t\tcontents: {\r\n\t\t\txml: /xml/,\r\n\t\t\thtml: /html/,\r\n\t\t\tjson: /json/\r\n\t\t},\r\n\r\n\t\tresponseFields: {\r\n\t\t\txml: \"responseXML\",\r\n\t\t\ttext: \"responseText\",\r\n\t\t\tjson: \"responseJSON\"\r\n\t\t},\r\n\r\n\t\t// Data converters\r\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\r\n\t\tconverters: {\r\n\r\n\t\t\t// Convert anything to text\r\n\t\t\t\"* text\": String,\r\n\r\n\t\t\t// Text to html (true = no transformation)\r\n\t\t\t\"text html\": true,\r\n\r\n\t\t\t// Evaluate text as a json expression\r\n\t\t\t\"text json\": jQuery.parseJSON,\r\n\r\n\t\t\t// Parse text as xml\r\n\t\t\t\"text xml\": jQuery.parseXML\r\n\t\t},\r\n\r\n\t\t// For options that shouldn't be deep extended:\r\n\t\t// you can add your own custom options here if\r\n\t\t// and when you create one that shouldn't be\r\n\t\t// deep extended (see ajaxExtend)\r\n\t\tflatOptions: {\r\n\t\t\turl: true,\r\n\t\t\tcontext: true\r\n\t\t}\r\n\t},\r\n\r\n\t// Creates a full fledged settings object into target\r\n\t// with both ajaxSettings and settings fields.\r\n\t// If target is omitted, writes into ajaxSettings.\r\n\tajaxSetup: function( target, settings ) {\r\n\t\treturn settings ?\r\n\r\n\t\t\t// Building a settings object\r\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\r\n\r\n\t\t\t// Extending ajaxSettings\r\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\r\n\t},\r\n\r\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\r\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\r\n\r\n\t// Main method\r\n\tajax: function( url, options ) {\r\n\r\n\t\t// If url is an object, simulate pre-1.5 signature\r\n\t\tif ( typeof url === \"object\" ) {\r\n\t\t\toptions = url;\r\n\t\t\turl = undefined;\r\n\t\t}\r\n\r\n\t\t// Force options to be an object\r\n\t\toptions = options || {};\r\n\r\n\t\tvar transport,\r\n\t\t\t// URL without anti-cache param\r\n\t\t\tcacheURL,\r\n\t\t\t// Response headers\r\n\t\t\tresponseHeadersString,\r\n\t\t\tresponseHeaders,\r\n\t\t\t// timeout handle\r\n\t\t\ttimeoutTimer,\r\n\t\t\t// Cross-domain detection vars\r\n\t\t\tparts,\r\n\t\t\t// To know if global events are to be dispatched\r\n\t\t\tfireGlobals,\r\n\t\t\t// Loop variable\r\n\t\t\ti,\r\n\t\t\t// Create the final options object\r\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\r\n\t\t\t// Callbacks context\r\n\t\t\tcallbackContext = s.context || s,\r\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\r\n\t\t\tglobalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\r\n\t\t\t\tjQuery( callbackContext ) :\r\n\t\t\t\tjQuery.event,\r\n\t\t\t// Deferreds\r\n\t\t\tdeferred = jQuery.Deferred(),\r\n\t\t\tcompleteDeferred = jQuery.Callbacks(\"once memory\"),\r\n\t\t\t// Status-dependent callbacks\r\n\t\t\tstatusCode = s.statusCode || {},\r\n\t\t\t// Headers (they are sent all at once)\r\n\t\t\trequestHeaders = {},\r\n\t\t\trequestHeadersNames = {},\r\n\t\t\t// The jqXHR state\r\n\t\t\tstate = 0,\r\n\t\t\t// Default abort message\r\n\t\t\tstrAbort = \"canceled\",\r\n\t\t\t// Fake xhr\r\n\t\t\tjqXHR = {\r\n\t\t\t\treadyState: 0,\r\n\r\n\t\t\t\t// Builds headers hashtable if needed\r\n\t\t\t\tgetResponseHeader: function( key ) {\r\n\t\t\t\t\tvar match;\r\n\t\t\t\t\tif ( state === 2 ) {\r\n\t\t\t\t\t\tif ( !responseHeaders ) {\r\n\t\t\t\t\t\t\tresponseHeaders = {};\r\n\t\t\t\t\t\t\twhile ( (match = rheaders.exec( responseHeadersString )) ) {\r\n\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn match == null ? null : match;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Raw string\r\n\t\t\t\tgetAllResponseHeaders: function() {\r\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Caches the header\r\n\t\t\t\tsetRequestHeader: function( name, value ) {\r\n\t\t\t\t\tvar lname = name.toLowerCase();\r\n\t\t\t\t\tif ( !state ) {\r\n\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\r\n\t\t\t\t\t\trequestHeaders[ name ] = value;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Overrides response content-type header\r\n\t\t\t\toverrideMimeType: function( type ) {\r\n\t\t\t\t\tif ( !state ) {\r\n\t\t\t\t\t\ts.mimeType = type;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Status-dependent callbacks\r\n\t\t\t\tstatusCode: function( map ) {\r\n\t\t\t\t\tvar code;\r\n\t\t\t\t\tif ( map ) {\r\n\t\t\t\t\t\tif ( state < 2 ) {\r\n\t\t\t\t\t\t\tfor ( code in map ) {\r\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\r\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\r\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Cancel the request\r\n\t\t\t\tabort: function( statusText ) {\r\n\t\t\t\t\tvar finalText = statusText || strAbort;\r\n\t\t\t\t\tif ( transport ) {\r\n\t\t\t\t\t\ttransport.abort( finalText );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdone( 0, finalText );\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t// Attach deferreds\r\n\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\r\n\t\tjqXHR.success = jqXHR.done;\r\n\t\tjqXHR.error = jqXHR.fail;\r\n\r\n\t\t// Remove hash character (#7531: and string promotion)\r\n\t\t// Add protocol if not provided (prefilters might expect it)\r\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\r\n\t\t// We also use the url parameter if available\r\n\t\ts.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" )\r\n\t\t\t.replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\r\n\r\n\t\t// Alias method option to type as per ticket #12004\r\n\t\ts.type = options.method || options.type || s.method || s.type;\r\n\r\n\t\t// Extract dataTypes list\r\n\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( core_rnotwhite ) || [\"\"];\r\n\r\n\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\r\n\t\tif ( s.crossDomain == null ) {\r\n\t\t\tparts = rurl.exec( s.url.toLowerCase() );\r\n\t\t\ts.crossDomain = !!( parts &&\r\n\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\r\n\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) !==\r\n\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) )\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// Convert data if not already a string\r\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\r\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\r\n\t\t}\r\n\r\n\t\t// Apply prefilters\r\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\r\n\r\n\t\t// If request was aborted inside a prefilter, stop there\r\n\t\tif ( state === 2 ) {\r\n\t\t\treturn jqXHR;\r\n\t\t}\r\n\r\n\t\t// We can fire global events as of now if asked to\r\n\t\tfireGlobals = s.global;\r\n\r\n\t\t// Watch for a new set of requests\r\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\r\n\t\t\tjQuery.event.trigger(\"ajaxStart\");\r\n\t\t}\r\n\r\n\t\t// Uppercase the type\r\n\t\ts.type = s.type.toUpperCase();\r\n\r\n\t\t// Determine if request has content\r\n\t\ts.hasContent = !rnoContent.test( s.type );\r\n\r\n\t\t// Save the URL in case we're toying with the If-Modified-Since\r\n\t\t// and/or If-None-Match header later on\r\n\t\tcacheURL = s.url;\r\n\r\n\t\t// More options handling for requests with no content\r\n\t\tif ( !s.hasContent ) {\r\n\r\n\t\t\t// If data is available, append data to url\r\n\t\t\tif ( s.data ) {\r\n\t\t\t\tcacheURL = ( s.url += ( ajax_rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\r\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\r\n\t\t\t\tdelete s.data;\r\n\t\t\t}\r\n\r\n\t\t\t// Add anti-cache in url if needed\r\n\t\t\tif ( s.cache === false ) {\r\n\t\t\t\ts.url = rts.test( cacheURL ) ?\r\n\r\n\t\t\t\t\t// If there is already a '_' parameter, set its value\r\n\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + ajax_nonce++ ) :\r\n\r\n\t\t\t\t\t// Otherwise add one to the end\r\n\t\t\t\t\tcacheURL + ( ajax_rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ajax_nonce++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\r\n\t\tif ( s.ifModified ) {\r\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\r\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\r\n\t\t\t}\r\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\r\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Set the correct header, if data is being sent\r\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\r\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\r\n\t\t}\r\n\r\n\t\t// Set the Accepts header for the server, depending on the dataType\r\n\t\tjqXHR.setRequestHeader(\r\n\t\t\t\"Accept\",\r\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\r\n\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\r\n\t\t\t\ts.accepts[ \"*\" ]\r\n\t\t);\r\n\r\n\t\t// Check for headers option\r\n\t\tfor ( i in s.headers ) {\r\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\r\n\t\t}\r\n\r\n\t\t// Allow custom headers/mimetypes and early abort\r\n\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\r\n\t\t\t// Abort if not done already and return\r\n\t\t\treturn jqXHR.abort();\r\n\t\t}\r\n\r\n\t\t// aborting is no longer a cancellation\r\n\t\tstrAbort = \"abort\";\r\n\r\n\t\t// Install callbacks on deferreds\r\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\r\n\t\t\tjqXHR[ i ]( s[ i ] );\r\n\t\t}\r\n\r\n\t\t// Get transport\r\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\r\n\r\n\t\t// If no transport, we auto-abort\r\n\t\tif ( !transport ) {\r\n\t\t\tdone( -1, \"No Transport\" );\r\n\t\t} else {\r\n\t\t\tjqXHR.readyState = 1;\r\n\r\n\t\t\t// Send global event\r\n\t\t\tif ( fireGlobals ) {\r\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\r\n\t\t\t}\r\n\t\t\t// Timeout\r\n\t\t\tif ( s.async && s.timeout > 0 ) {\r\n\t\t\t\ttimeoutTimer = setTimeout(function() {\r\n\t\t\t\t\tjqXHR.abort(\"timeout\");\r\n\t\t\t\t}, s.timeout );\r\n\t\t\t}\r\n\r\n\t\t\ttry {\r\n\t\t\t\tstate = 1;\r\n\t\t\t\ttransport.send( requestHeaders, done );\r\n\t\t\t} catch ( e ) {\r\n\t\t\t\t// Propagate exception as error if not done\r\n\t\t\t\tif ( state < 2 ) {\r\n\t\t\t\t\tdone( -1, e );\r\n\t\t\t\t// Simply rethrow otherwise\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Callback for when everything is done\r\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\r\n\t\t\tvar isSuccess, success, error, response, modified,\r\n\t\t\t\tstatusText = nativeStatusText;\r\n\r\n\t\t\t// Called once\r\n\t\t\tif ( state === 2 ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// State is \"done\" now\r\n\t\t\tstate = 2;\r\n\r\n\t\t\t// Clear timeout if it exists\r\n\t\t\tif ( timeoutTimer ) {\r\n\t\t\t\tclearTimeout( timeoutTimer );\r\n\t\t\t}\r\n\r\n\t\t\t// Dereference transport for early garbage collection\r\n\t\t\t// (no matter how long the jqXHR object will be used)\r\n\t\t\ttransport = undefined;\r\n\r\n\t\t\t// Cache response headers\r\n\t\t\tresponseHeadersString = headers || \"\";\r\n\r\n\t\t\t// Set readyState\r\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\r\n\r\n\t\t\t// Determine if successful\r\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\r\n\r\n\t\t\t// Get response data\r\n\t\t\tif ( responses ) {\r\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\r\n\t\t\t}\r\n\r\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\r\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\r\n\r\n\t\t\t// If successful, handle type chaining\r\n\t\t\tif ( isSuccess ) {\r\n\r\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\r\n\t\t\t\tif ( s.ifModified ) {\r\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\r\n\t\t\t\t\tif ( modified ) {\r\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\r\n\t\t\t\t\tif ( modified ) {\r\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if no content\r\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\r\n\t\t\t\t\tstatusText = \"nocontent\";\r\n\r\n\t\t\t\t// if not modified\r\n\t\t\t\t} else if ( status === 304 ) {\r\n\t\t\t\t\tstatusText = \"notmodified\";\r\n\r\n\t\t\t\t// If we have data, let's convert it\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstatusText = response.state;\r\n\t\t\t\t\tsuccess = response.data;\r\n\t\t\t\t\terror = response.error;\r\n\t\t\t\t\tisSuccess = !error;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// We extract error from statusText\r\n\t\t\t\t// then normalize statusText and status for non-aborts\r\n\t\t\t\terror = statusText;\r\n\t\t\t\tif ( status || !statusText ) {\r\n\t\t\t\t\tstatusText = \"error\";\r\n\t\t\t\t\tif ( status < 0 ) {\r\n\t\t\t\t\t\tstatus = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Set data for the fake xhr object\r\n\t\t\tjqXHR.status = status;\r\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\r\n\r\n\t\t\t// Success/Error\r\n\t\t\tif ( isSuccess ) {\r\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\r\n\t\t\t} else {\r\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\r\n\t\t\t}\r\n\r\n\t\t\t// Status-dependent callbacks\r\n\t\t\tjqXHR.statusCode( statusCode );\r\n\t\t\tstatusCode = undefined;\r\n\r\n\t\t\tif ( fireGlobals ) {\r\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\r\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\r\n\t\t\t}\r\n\r\n\t\t\t// Complete\r\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\r\n\r\n\t\t\tif ( fireGlobals ) {\r\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\r\n\t\t\t\t// Handle the global AJAX counter\r\n\t\t\t\tif ( !( --jQuery.active ) ) {\r\n\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn jqXHR;\r\n\t},\r\n\r\n\tgetJSON: function( url, data, callback ) {\r\n\t\treturn jQuery.get( url, data, callback, \"json\" );\r\n\t},\r\n\r\n\tgetScript: function( url, callback ) {\r\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\r\n\t}\r\n});\r\n\r\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\r\n\tjQuery[ method ] = function( url, data, callback, type ) {\r\n\t\t// shift arguments if data argument was omitted\r\n\t\tif ( jQuery.isFunction( data ) ) {\r\n\t\t\ttype = type || callback;\r\n\t\t\tcallback = data;\r\n\t\t\tdata = undefined;\r\n\t\t}\r\n\r\n\t\treturn jQuery.ajax({\r\n\t\t\turl: url,\r\n\t\t\ttype: method,\r\n\t\t\tdataType: type,\r\n\t\t\tdata: data,\r\n\t\t\tsuccess: callback\r\n\t\t});\r\n\t};\r\n});\r\n\r\n/* Handles responses to an ajax request:\r\n * - finds the right dataType (mediates between content-type and expected dataType)\r\n * - returns the corresponding response\r\n */\r\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\r\n\r\n\tvar ct, type, finalDataType, firstDataType,\r\n\t\tcontents = s.contents,\r\n\t\tdataTypes = s.dataTypes;\r\n\r\n\t// Remove auto dataType and get content-type in the process\r\n\twhile( dataTypes[ 0 ] === \"*\" ) {\r\n\t\tdataTypes.shift();\r\n\t\tif ( ct === undefined ) {\r\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\r\n\t\t}\r\n\t}\r\n\r\n\t// Check if we're dealing with a known content-type\r\n\tif ( ct ) {\r\n\t\tfor ( type in contents ) {\r\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\r\n\t\t\t\tdataTypes.unshift( type );\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Check to see if we have a response for the expected dataType\r\n\tif ( dataTypes[ 0 ] in responses ) {\r\n\t\tfinalDataType = dataTypes[ 0 ];\r\n\t} else {\r\n\t\t// Try convertible dataTypes\r\n\t\tfor ( type in responses ) {\r\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\r\n\t\t\t\tfinalDataType = type;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif ( !firstDataType ) {\r\n\t\t\t\tfirstDataType = type;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Or just use first one\r\n\t\tfinalDataType = finalDataType || firstDataType;\r\n\t}\r\n\r\n\t// If we found a dataType\r\n\t// We add the dataType to the list if needed\r\n\t// and return the corresponding response\r\n\tif ( finalDataType ) {\r\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\r\n\t\t\tdataTypes.unshift( finalDataType );\r\n\t\t}\r\n\t\treturn responses[ finalDataType ];\r\n\t}\r\n}\r\n\r\n/* Chain conversions given the request and the original response\r\n * Also sets the responseXXX fields on the jqXHR instance\r\n */\r\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\r\n\tvar conv2, current, conv, tmp, prev,\r\n\t\tconverters = {},\r\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\r\n\t\tdataTypes = s.dataTypes.slice();\r\n\r\n\t// Create converters map with lowercased keys\r\n\tif ( dataTypes[ 1 ] ) {\r\n\t\tfor ( conv in s.converters ) {\r\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\r\n\t\t}\r\n\t}\r\n\r\n\tcurrent = dataTypes.shift();\r\n\r\n\t// Convert to each sequential dataType\r\n\twhile ( current ) {\r\n\r\n\t\tif ( s.responseFields[ current ] ) {\r\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\r\n\t\t}\r\n\r\n\t\t// Apply the dataFilter if provided\r\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\r\n\t\t\tresponse = s.dataFilter( response, s.dataType );\r\n\t\t}\r\n\r\n\t\tprev = current;\r\n\t\tcurrent = dataTypes.shift();\r\n\r\n\t\tif ( current ) {\r\n\r\n\t\t// There's only work to do if current dataType is non-auto\r\n\t\t\tif ( current === \"*\" ) {\r\n\r\n\t\t\t\tcurrent = prev;\r\n\r\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\r\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\r\n\r\n\t\t\t\t// Seek a direct converter\r\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\r\n\r\n\t\t\t\t// If none found, seek a pair\r\n\t\t\t\tif ( !conv ) {\r\n\t\t\t\t\tfor ( conv2 in converters ) {\r\n\r\n\t\t\t\t\t\t// If conv2 outputs current\r\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\r\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\r\n\r\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\r\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\r\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\r\n\t\t\t\t\t\t\tif ( conv ) {\r\n\t\t\t\t\t\t\t\t// Condense equivalence converters\r\n\t\t\t\t\t\t\t\tif ( conv === true ) {\r\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\r\n\r\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\r\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\r\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\r\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Apply converter (if not an equivalence)\r\n\t\t\t\tif ( conv !== true ) {\r\n\r\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\r\n\t\t\t\t\tif ( conv && s[ \"throws\" ] ) {\r\n\t\t\t\t\t\tresponse = conv( response );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tresponse = conv( response );\r\n\t\t\t\t\t\t} catch ( e ) {\r\n\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn { state: \"success\", data: response };\r\n}\r\n// Install script dataType\r\njQuery.ajaxSetup({\r\n\taccepts: {\r\n\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\r\n\t},\r\n\tcontents: {\r\n\t\tscript: /(?:java|ecma)script/\r\n\t},\r\n\tconverters: {\r\n\t\t\"text script\": function( text ) {\r\n\t\t\tjQuery.globalEval( text );\r\n\t\t\treturn text;\r\n\t\t}\r\n\t}\r\n});\r\n\r\n// Handle cache's special case and crossDomain\r\njQuery.ajaxPrefilter( \"script\", function( s ) {\r\n\tif ( s.cache === undefined ) {\r\n\t\ts.cache = false;\r\n\t}\r\n\tif ( s.crossDomain ) {\r\n\t\ts.type = \"GET\";\r\n\t}\r\n});\r\n\r\n// Bind script tag hack transport\r\njQuery.ajaxTransport( \"script\", function( s ) {\r\n\t// This transport only deals with cross domain requests\r\n\tif ( s.crossDomain ) {\r\n\t\tvar script, callback;\r\n\t\treturn {\r\n\t\t\tsend: function( _, complete ) {\r\n\t\t\t\tscript = jQuery(\"<script>\").prop({\r\n\t\t\t\t\tasync: true,\r\n\t\t\t\t\tcharset: s.scriptCharset,\r\n\t\t\t\t\tsrc: s.url\r\n\t\t\t\t}).on(\r\n\t\t\t\t\t\"load error\",\r\n\t\t\t\t\tcallback = function( evt ) {\r\n\t\t\t\t\t\tscript.remove();\r\n\t\t\t\t\t\tcallback = null;\r\n\t\t\t\t\t\tif ( evt ) {\r\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\r\n\t\t\t},\r\n\t\t\tabort: function() {\r\n\t\t\t\tif ( callback ) {\r\n\t\t\t\t\tcallback();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n});\r\nvar oldCallbacks = [],\r\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\r\n\r\n// Default jsonp settings\r\njQuery.ajaxSetup({\r\n\tjsonp: \"callback\",\r\n\tjsonpCallback: function() {\r\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( ajax_nonce++ ) );\r\n\t\tthis[ callback ] = true;\r\n\t\treturn callback;\r\n\t}\r\n});\r\n\r\n// Detect, normalize options and install callbacks for jsonp requests\r\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\r\n\r\n\tvar callbackName, overwritten, responseContainer,\r\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\r\n\t\t\t\"url\" :\r\n\t\t\ttypeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\r\n\t\t);\r\n\r\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\r\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\r\n\r\n\t\t// Get callback name, remembering preexisting value associated with it\r\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\r\n\t\t\ts.jsonpCallback() :\r\n\t\t\ts.jsonpCallback;\r\n\r\n\t\t// Insert callback into url or form data\r\n\t\tif ( jsonProp ) {\r\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\r\n\t\t} else if ( s.jsonp !== false ) {\r\n\t\t\ts.url += ( ajax_rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\r\n\t\t}\r\n\r\n\t\t// Use data converter to retrieve json after script execution\r\n\t\ts.converters[\"script json\"] = function() {\r\n\t\t\tif ( !responseContainer ) {\r\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\r\n\t\t\t}\r\n\t\t\treturn responseContainer[ 0 ];\r\n\t\t};\r\n\r\n\t\t// force json dataType\r\n\t\ts.dataTypes[ 0 ] = \"json\";\r\n\r\n\t\t// Install callback\r\n\t\toverwritten = window[ callbackName ];\r\n\t\twindow[ callbackName ] = function() {\r\n\t\t\tresponseContainer = arguments;\r\n\t\t};\r\n\r\n\t\t// Clean-up function (fires after converters)\r\n\t\tjqXHR.always(function() {\r\n\t\t\t// Restore preexisting value\r\n\t\t\twindow[ callbackName ] = overwritten;\r\n\r\n\t\t\t// Save back as free\r\n\t\t\tif ( s[ callbackName ] ) {\r\n\t\t\t\t// make sure that re-using the options doesn't screw things around\r\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\r\n\r\n\t\t\t\t// save the callback name for future use\r\n\t\t\t\toldCallbacks.push( callbackName );\r\n\t\t\t}\r\n\r\n\t\t\t// Call if it was a function and we have a response\r\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\r\n\t\t\t\toverwritten( responseContainer[ 0 ] );\r\n\t\t\t}\r\n\r\n\t\t\tresponseContainer = overwritten = undefined;\r\n\t\t});\r\n\r\n\t\t// Delegate to script\r\n\t\treturn \"script\";\r\n\t}\r\n});\r\njQuery.ajaxSettings.xhr = function() {\r\n\ttry {\r\n\t\treturn new XMLHttpRequest();\r\n\t} catch( e ) {}\r\n};\r\n\r\nvar xhrSupported = jQuery.ajaxSettings.xhr(),\r\n\txhrSuccessStatus = {\r\n\t\t// file protocol always yields status code 0, assume 200\r\n\t\t0: 200,\r\n\t\t// Support: IE9\r\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\r\n\t\t1223: 204\r\n\t},\r\n\t// Support: IE9\r\n\t// We need to keep track of outbound xhr and abort them manually\r\n\t// because IE is not smart enough to do it all by itself\r\n\txhrId = 0,\r\n\txhrCallbacks = {};\r\n\r\nif ( window.ActiveXObject ) {\r\n\tjQuery( window ).on( \"unload\", function() {\r\n\t\tfor( var key in xhrCallbacks ) {\r\n\t\t\txhrCallbacks[ key ]();\r\n\t\t}\r\n\t\txhrCallbacks = undefined;\r\n\t});\r\n}\r\n\r\njQuery.support.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\r\njQuery.support.ajax = xhrSupported = !!xhrSupported;\r\n\r\njQuery.ajaxTransport(function( options ) {\r\n\tvar callback;\r\n\t// Cross domain only allowed if supported through XMLHttpRequest\r\n\tif ( jQuery.support.cors || xhrSupported && !options.crossDomain ) {\r\n\t\treturn {\r\n\t\t\tsend: function( headers, complete ) {\r\n\t\t\t\tvar i, id,\r\n\t\t\t\t\txhr = options.xhr();\r\n\t\t\t\txhr.open( options.type, options.url, options.async, options.username, options.password );\r\n\t\t\t\t// Apply custom fields if provided\r\n\t\t\t\tif ( options.xhrFields ) {\r\n\t\t\t\t\tfor ( i in options.xhrFields ) {\r\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Override mime type if needed\r\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\r\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\r\n\t\t\t\t}\r\n\t\t\t\t// X-Requested-With header\r\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\r\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\r\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\r\n\t\t\t\t// For same-domain requests, won't change header if already provided.\r\n\t\t\t\tif ( !options.crossDomain && !headers[\"X-Requested-With\"] ) {\r\n\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\r\n\t\t\t\t}\r\n\t\t\t\t// Set headers\r\n\t\t\t\tfor ( i in headers ) {\r\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\r\n\t\t\t\t}\r\n\t\t\t\t// Callback\r\n\t\t\t\tcallback = function( type ) {\r\n\t\t\t\t\treturn function() {\r\n\t\t\t\t\t\tif ( callback ) {\r\n\t\t\t\t\t\t\tdelete xhrCallbacks[ id ];\r\n\t\t\t\t\t\t\tcallback = xhr.onload = xhr.onerror = null;\r\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\r\n\t\t\t\t\t\t\t\txhr.abort();\r\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\r\n\t\t\t\t\t\t\t\tcomplete(\r\n\t\t\t\t\t\t\t\t\t// file protocol always yields status 0, assume 404\r\n\t\t\t\t\t\t\t\t\txhr.status || 404,\r\n\t\t\t\t\t\t\t\t\txhr.statusText\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcomplete(\r\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\r\n\t\t\t\t\t\t\t\t\txhr.statusText,\r\n\t\t\t\t\t\t\t\t\t// Support: IE9\r\n\t\t\t\t\t\t\t\t\t// #11426: When requesting binary data, IE9 will throw an exception\r\n\t\t\t\t\t\t\t\t\t// on any attempt to access responseText\r\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText === \"string\" ? {\r\n\t\t\t\t\t\t\t\t\t\ttext: xhr.responseText\r\n\t\t\t\t\t\t\t\t\t} : undefined,\r\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t};\r\n\t\t\t\t// Listen to events\r\n\t\t\t\txhr.onload = callback();\r\n\t\t\t\txhr.onerror = callback(\"error\");\r\n\t\t\t\t// Create the abort callback\r\n\t\t\t\tcallback = xhrCallbacks[( id = xhrId++ )] = callback(\"abort\");\r\n\t\t\t\t// Do send the request\r\n\t\t\t\t// This may raise an exception which is actually\r\n\t\t\t\t// handled in jQuery.ajax (so no try/catch here)\r\n\t\t\t\txhr.send( options.hasContent && options.data || null );\r\n\t\t\t},\r\n\t\t\tabort: function() {\r\n\t\t\t\tif ( callback ) {\r\n\t\t\t\t\tcallback();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n});\r\nvar fxNow, timerId,\r\n\trfxtypes = /^(?:toggle|show|hide)$/,\r\n\trfxnum = new RegExp( \"^(?:([+-])=|)(\" + core_pnum + \")([a-z%]*)$\", \"i\" ),\r\n\trrun = /queueHooks$/,\r\n\tanimationPrefilters = [ defaultPrefilter ],\r\n\ttweeners = {\r\n\t\t\"*\": [function( prop, value ) {\r\n\t\t\tvar tween = this.createTween( prop, value ),\r\n\t\t\t\ttarget = tween.cur(),\r\n\t\t\t\tparts = rfxnum.exec( value ),\r\n\t\t\t\tunit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\r\n\r\n\t\t\t\t// Starting value computation is required for potential unit mismatches\r\n\t\t\t\tstart = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +target ) &&\r\n\t\t\t\t\trfxnum.exec( jQuery.css( tween.elem, prop ) ),\r\n\t\t\t\tscale = 1,\r\n\t\t\t\tmaxIterations = 20;\r\n\r\n\t\t\tif ( start && start[ 3 ] !== unit ) {\r\n\t\t\t\t// Trust units reported by jQuery.css\r\n\t\t\t\tunit = unit || start[ 3 ];\r\n\r\n\t\t\t\t// Make sure we update the tween properties later on\r\n\t\t\t\tparts = parts || [];\r\n\r\n\t\t\t\t// Iteratively approximate from a nonzero starting point\r\n\t\t\t\tstart = +target || 1;\r\n\r\n\t\t\t\tdo {\r\n\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*\r\n\t\t\t\t\t// Use a string for doubling factor so we don't accidentally see scale as unchanged below\r\n\t\t\t\t\tscale = scale || \".5\";\r\n\r\n\t\t\t\t\t// Adjust and apply\r\n\t\t\t\t\tstart = start / scale;\r\n\t\t\t\t\tjQuery.style( tween.elem, prop, start + unit );\r\n\r\n\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur()\r\n\t\t\t\t// And breaking the loop if scale is unchanged or perfect, or if we've just had enough\r\n\t\t\t\t} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\r\n\t\t\t}\r\n\r\n\t\t\t// Update tween properties\r\n\t\t\tif ( parts ) {\r\n\t\t\t\tstart = tween.start = +start || +target || 0;\r\n\t\t\t\ttween.unit = unit;\r\n\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\r\n\t\t\t\ttween.end = parts[ 1 ] ?\r\n\t\t\t\t\tstart + ( parts[ 1 ] + 1 ) * parts[ 2 ] :\r\n\t\t\t\t\t+parts[ 2 ];\r\n\t\t\t}\r\n\r\n\t\t\treturn tween;\r\n\t\t}]\r\n\t};\r\n\r\n// Animations created synchronously will run synchronously\r\nfunction createFxNow() {\r\n\tsetTimeout(function() {\r\n\t\tfxNow = undefined;\r\n\t});\r\n\treturn ( fxNow = jQuery.now() );\r\n}\r\n\r\nfunction createTween( value, prop, animation ) {\r\n\tvar tween,\r\n\t\tcollection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\r\n\t\tindex = 0,\r\n\t\tlength = collection.length;\r\n\tfor ( ; index < length; index++ ) {\r\n\t\tif ( (tween = collection[ index ].call( animation, prop, value )) ) {\r\n\r\n\t\t\t// we're done with this property\r\n\t\t\treturn tween;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction Animation( elem, properties, options ) {\r\n\tvar result,\r\n\t\tstopped,\r\n\t\tindex = 0,\r\n\t\tlength = animationPrefilters.length,\r\n\t\tdeferred = jQuery.Deferred().always( function() {\r\n\t\t\t// don't match elem in the :animated selector\r\n\t\t\tdelete tick.elem;\r\n\t\t}),\r\n\t\ttick = function() {\r\n\t\t\tif ( stopped ) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tvar currentTime = fxNow || createFxNow(),\r\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\r\n\t\t\t\t// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)\r\n\t\t\t\ttemp = remaining / animation.duration || 0,\r\n\t\t\t\tpercent = 1 - temp,\r\n\t\t\t\tindex = 0,\r\n\t\t\t\tlength = animation.tweens.length;\r\n\r\n\t\t\tfor ( ; index < length ; index++ ) {\r\n\t\t\t\tanimation.tweens[ index ].run( percent );\r\n\t\t\t}\r\n\r\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ]);\r\n\r\n\t\t\tif ( percent < 1 && length ) {\r\n\t\t\t\treturn remaining;\r\n\t\t\t} else {\r\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t},\r\n\t\tanimation = deferred.promise({\r\n\t\t\telem: elem,\r\n\t\t\tprops: jQuery.extend( {}, properties ),\r\n\t\t\topts: jQuery.extend( true, { specialEasing: {} }, options ),\r\n\t\t\toriginalProperties: properties,\r\n\t\t\toriginalOptions: options,\r\n\t\t\tstartTime: fxNow || createFxNow(),\r\n\t\t\tduration: options.duration,\r\n\t\t\ttweens: [],\r\n\t\t\tcreateTween: function( prop, end ) {\r\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\r\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\r\n\t\t\t\tanimation.tweens.push( tween );\r\n\t\t\t\treturn tween;\r\n\t\t\t},\r\n\t\t\tstop: function( gotoEnd ) {\r\n\t\t\t\tvar index = 0,\r\n\t\t\t\t\t// if we are going to the end, we want to run all the tweens\r\n\t\t\t\t\t// otherwise we skip this part\r\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\r\n\t\t\t\tif ( stopped ) {\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t}\r\n\t\t\t\tstopped = true;\r\n\t\t\t\tfor ( ; index < length ; index++ ) {\r\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// resolve when we played the last frame\r\n\t\t\t\t// otherwise, reject\r\n\t\t\t\tif ( gotoEnd ) {\r\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\t}),\r\n\t\tprops = animation.props;\r\n\r\n\tpropFilter( props, animation.opts.specialEasing );\r\n\r\n\tfor ( ; index < length ; index++ ) {\r\n\t\tresult = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\r\n\t\tif ( result ) {\r\n\t\t\treturn result;\r\n\t\t}\r\n\t}\r\n\r\n\tjQuery.map( props, createTween, animation );\r\n\r\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\r\n\t\tanimation.opts.start.call( elem, animation );\r\n\t}\r\n\r\n\tjQuery.fx.timer(\r\n\t\tjQuery.extend( tick, {\r\n\t\t\telem: elem,\r\n\t\t\tanim: animation,\r\n\t\t\tqueue: animation.opts.queue\r\n\t\t})\r\n\t);\r\n\r\n\t// attach callbacks from options\r\n\treturn animation.progress( animation.opts.progress )\r\n\t\t.done( animation.opts.done, animation.opts.complete )\r\n\t\t.fail( animation.opts.fail )\r\n\t\t.always( animation.opts.always );\r\n}\r\n\r\nfunction propFilter( props, specialEasing ) {\r\n\tvar index, name, easing, value, hooks;\r\n\r\n\t// camelCase, specialEasing and expand cssHook pass\r\n\tfor ( index in props ) {\r\n\t\tname = jQuery.camelCase( index );\r\n\t\teasing = specialEasing[ name ];\r\n\t\tvalue = props[ index ];\r\n\t\tif ( jQuery.isArray( value ) ) {\r\n\t\t\teasing = value[ 1 ];\r\n\t\t\tvalue = props[ index ] = value[ 0 ];\r\n\t\t}\r\n\r\n\t\tif ( index !== name ) {\r\n\t\t\tprops[ name ] = value;\r\n\t\t\tdelete props[ index ];\r\n\t\t}\r\n\r\n\t\thooks = jQuery.cssHooks[ name ];\r\n\t\tif ( hooks && \"expand\" in hooks ) {\r\n\t\t\tvalue = hooks.expand( value );\r\n\t\t\tdelete props[ name ];\r\n\r\n\t\t\t// not quite $.extend, this wont overwrite keys already present.\r\n\t\t\t// also - reusing 'index' from above because we have the correct \"name\"\r\n\t\t\tfor ( index in value ) {\r\n\t\t\t\tif ( !( index in props ) ) {\r\n\t\t\t\t\tprops[ index ] = value[ index ];\r\n\t\t\t\t\tspecialEasing[ index ] = easing;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tspecialEasing[ name ] = easing;\r\n\t\t}\r\n\t}\r\n}\r\n\r\njQuery.Animation = jQuery.extend( Animation, {\r\n\r\n\ttweener: function( props, callback ) {\r\n\t\tif ( jQuery.isFunction( props ) ) {\r\n\t\t\tcallback = props;\r\n\t\t\tprops = [ \"*\" ];\r\n\t\t} else {\r\n\t\t\tprops = props.split(\" \");\r\n\t\t}\r\n\r\n\t\tvar prop,\r\n\t\t\tindex = 0,\r\n\t\t\tlength = props.length;\r\n\r\n\t\tfor ( ; index < length ; index++ ) {\r\n\t\t\tprop = props[ index ];\r\n\t\t\ttweeners[ prop ] = tweeners[ prop ] || [];\r\n\t\t\ttweeners[ prop ].unshift( callback );\r\n\t\t}\r\n\t},\r\n\r\n\tprefilter: function( callback, prepend ) {\r\n\t\tif ( prepend ) {\r\n\t\t\tanimationPrefilters.unshift( callback );\r\n\t\t} else {\r\n\t\t\tanimationPrefilters.push( callback );\r\n\t\t}\r\n\t}\r\n});\r\n\r\nfunction defaultPrefilter( elem, props, opts ) {\r\n\t/* jshint validthis: true */\r\n\tvar prop, value, toggle, tween, hooks, oldfire,\r\n\t\tanim = this,\r\n\t\torig = {},\r\n\t\tstyle = elem.style,\r\n\t\thidden = elem.nodeType && isHidden( elem ),\r\n\t\tdataShow = data_priv.get( elem, \"fxshow\" );\r\n\r\n\t// handle queue: false promises\r\n\tif ( !opts.queue ) {\r\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\r\n\t\tif ( hooks.unqueued == null ) {\r\n\t\t\thooks.unqueued = 0;\r\n\t\t\toldfire = hooks.empty.fire;\r\n\t\t\thooks.empty.fire = function() {\r\n\t\t\t\tif ( !hooks.unqueued ) {\r\n\t\t\t\t\toldfire();\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\t\thooks.unqueued++;\r\n\r\n\t\tanim.always(function() {\r\n\t\t\t// doing this makes sure that the complete handler will be called\r\n\t\t\t// before this completes\r\n\t\t\tanim.always(function() {\r\n\t\t\t\thooks.unqueued--;\r\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\r\n\t\t\t\t\thooks.empty.fire();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\r\n\t// height/width overflow pass\r\n\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\r\n\t\t// Make sure that nothing sneaks out\r\n\t\t// Record all 3 overflow attributes because IE9-10 do not\r\n\t\t// change the overflow attribute when overflowX and\r\n\t\t// overflowY are set to the same value\r\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\r\n\r\n\t\t// Set display property to inline-block for height/width\r\n\t\t// animations on inline elements that are having width/height animated\r\n\t\tif ( jQuery.css( elem, \"display\" ) === \"inline\" &&\r\n\t\t\t\tjQuery.css( elem, \"float\" ) === \"none\" ) {\r\n\r\n\t\t\tstyle.display = \"inline-block\";\r\n\t\t}\r\n\t}\r\n\r\n\tif ( opts.overflow ) {\r\n\t\tstyle.overflow = \"hidden\";\r\n\t\tanim.always(function() {\r\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\r\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\r\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\r\n\t\t});\r\n\t}\r\n\r\n\r\n\t// show/hide pass\r\n\tfor ( prop in props ) {\r\n\t\tvalue = props[ prop ];\r\n\t\tif ( rfxtypes.exec( value ) ) {\r\n\t\t\tdelete props[ prop ];\r\n\t\t\ttoggle = toggle || value === \"toggle\";\r\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\r\n\r\n\t\t\t\t// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\r\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\r\n\t\t\t\t\thidden = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\r\n\t\t}\r\n\t}\r\n\r\n\tif ( !jQuery.isEmptyObject( orig ) ) {\r\n\t\tif ( dataShow ) {\r\n\t\t\tif ( \"hidden\" in dataShow ) {\r\n\t\t\t\thidden = dataShow.hidden;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tdataShow = data_priv.access( elem, \"fxshow\", {} );\r\n\t\t}\r\n\r\n\t\t// store state if its toggle - enables .stop().toggle() to \"reverse\"\r\n\t\tif ( toggle ) {\r\n\t\t\tdataShow.hidden = !hidden;\r\n\t\t}\r\n\t\tif ( hidden ) {\r\n\t\t\tjQuery( elem ).show();\r\n\t\t} else {\r\n\t\t\tanim.done(function() {\r\n\t\t\t\tjQuery( elem ).hide();\r\n\t\t\t});\r\n\t\t}\r\n\t\tanim.done(function() {\r\n\t\t\tvar prop;\r\n\r\n\t\t\tdata_priv.remove( elem, \"fxshow\" );\r\n\t\t\tfor ( prop in orig ) {\r\n\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\r\n\t\t\t}\r\n\t\t});\r\n\t\tfor ( prop in orig ) {\r\n\t\t\ttween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\r\n\r\n\t\t\tif ( !( prop in dataShow ) ) {\r\n\t\t\t\tdataShow[ prop ] = tween.start;\r\n\t\t\t\tif ( hidden ) {\r\n\t\t\t\t\ttween.end = tween.start;\r\n\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction Tween( elem, options, prop, end, easing ) {\r\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\r\n}\r\njQuery.Tween = Tween;\r\n\r\nTween.prototype = {\r\n\tconstructor: Tween,\r\n\tinit: function( elem, options, prop, end, easing, unit ) {\r\n\t\tthis.elem = elem;\r\n\t\tthis.prop = prop;\r\n\t\tthis.easing = easing || \"swing\";\r\n\t\tthis.options = options;\r\n\t\tthis.start = this.now = this.cur();\r\n\t\tthis.end = end;\r\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\r\n\t},\r\n\tcur: function() {\r\n\t\tvar hooks = Tween.propHooks[ this.prop ];\r\n\r\n\t\treturn hooks && hooks.get ?\r\n\t\t\thooks.get( this ) :\r\n\t\t\tTween.propHooks._default.get( this );\r\n\t},\r\n\trun: function( percent ) {\r\n\t\tvar eased,\r\n\t\t\thooks = Tween.propHooks[ this.prop ];\r\n\r\n\t\tif ( this.options.duration ) {\r\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\r\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\tthis.pos = eased = percent;\r\n\t\t}\r\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\r\n\r\n\t\tif ( this.options.step ) {\r\n\t\t\tthis.options.step.call( this.elem, this.now, this );\r\n\t\t}\r\n\r\n\t\tif ( hooks && hooks.set ) {\r\n\t\t\thooks.set( this );\r\n\t\t} else {\r\n\t\t\tTween.propHooks._default.set( this );\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n};\r\n\r\nTween.prototype.init.prototype = Tween.prototype;\r\n\r\nTween.propHooks = {\r\n\t_default: {\r\n\t\tget: function( tween ) {\r\n\t\t\tvar result;\r\n\r\n\t\t\tif ( tween.elem[ tween.prop ] != null &&\r\n\t\t\t\t(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\r\n\t\t\t\treturn tween.elem[ tween.prop ];\r\n\t\t\t}\r\n\r\n\t\t\t// passing an empty string as a 3rd parameter to .css will automatically\r\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails\r\n\t\t\t// so, simple values such as \"10px\" are parsed to Float.\r\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as is.\r\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\r\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\r\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\r\n\t\t},\r\n\t\tset: function( tween ) {\r\n\t\t\t// use step hook for back compat - use cssHook if its there - use .style if its\r\n\t\t\t// available and use plain properties where available\r\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\r\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\r\n\t\t\t} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\r\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\r\n\t\t\t} else {\r\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n\r\n// Support: IE9\r\n// Panic based approach to setting things on disconnected nodes\r\n\r\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\r\n\tset: function( tween ) {\r\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\r\n\t\t\ttween.elem[ tween.prop ] = tween.now;\r\n\t\t}\r\n\t}\r\n};\r\n\r\njQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\r\n\tvar cssFn = jQuery.fn[ name ];\r\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\r\n\t\treturn speed == null || typeof speed === \"boolean\" ?\r\n\t\t\tcssFn.apply( this, arguments ) :\r\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\r\n\t};\r\n});\r\n\r\njQuery.fn.extend({\r\n\tfadeTo: function( speed, to, easing, callback ) {\r\n\r\n\t\t// show any hidden elements after setting opacity to 0\r\n\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\r\n\r\n\t\t\t// animate to the value specified\r\n\t\t\t.end().animate({ opacity: to }, speed, easing, callback );\r\n\t},\r\n\tanimate: function( prop, speed, easing, callback ) {\r\n\t\tvar empty = jQuery.isEmptyObject( prop ),\r\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\r\n\t\t\tdoAnimation = function() {\r\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\r\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\r\n\r\n\t\t\t\t// Empty animations, or finishing resolves immediately\r\n\t\t\t\tif ( empty || data_priv.get( this, \"finish\" ) ) {\r\n\t\t\t\t\tanim.stop( true );\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tdoAnimation.finish = doAnimation;\r\n\r\n\t\treturn empty || optall.queue === false ?\r\n\t\t\tthis.each( doAnimation ) :\r\n\t\t\tthis.queue( optall.queue, doAnimation );\r\n\t},\r\n\tstop: function( type, clearQueue, gotoEnd ) {\r\n\t\tvar stopQueue = function( hooks ) {\r\n\t\t\tvar stop = hooks.stop;\r\n\t\t\tdelete hooks.stop;\r\n\t\t\tstop( gotoEnd );\r\n\t\t};\r\n\r\n\t\tif ( typeof type !== \"string\" ) {\r\n\t\t\tgotoEnd = clearQueue;\r\n\t\t\tclearQueue = type;\r\n\t\t\ttype = undefined;\r\n\t\t}\r\n\t\tif ( clearQueue && type !== false ) {\r\n\t\t\tthis.queue( type || \"fx\", [] );\r\n\t\t}\r\n\r\n\t\treturn this.each(function() {\r\n\t\t\tvar dequeue = true,\r\n\t\t\t\tindex = type != null && type + \"queueHooks\",\r\n\t\t\t\ttimers = jQuery.timers,\r\n\t\t\t\tdata = data_priv.get( this );\r\n\r\n\t\t\tif ( index ) {\r\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\r\n\t\t\t\t\tstopQueue( data[ index ] );\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor ( index in data ) {\r\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\r\n\t\t\t\t\t\tstopQueue( data[ index ] );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfor ( index = timers.length; index--; ) {\r\n\t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\r\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\r\n\t\t\t\t\tdequeue = false;\r\n\t\t\t\t\ttimers.splice( index, 1 );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// start the next in the queue if the last step wasn't forced\r\n\t\t\t// timers currently will call their complete callbacks, which will dequeue\r\n\t\t\t// but only if they were gotoEnd\r\n\t\t\tif ( dequeue || !gotoEnd ) {\r\n\t\t\t\tjQuery.dequeue( this, type );\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\tfinish: function( type ) {\r\n\t\tif ( type !== false ) {\r\n\t\t\ttype = type || \"fx\";\r\n\t\t}\r\n\t\treturn this.each(function() {\r\n\t\t\tvar index,\r\n\t\t\t\tdata = data_priv.get( this ),\r\n\t\t\t\tqueue = data[ type + \"queue\" ],\r\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\r\n\t\t\t\ttimers = jQuery.timers,\r\n\t\t\t\tlength = queue ? queue.length : 0;\r\n\r\n\t\t\t// enable finishing flag on private data\r\n\t\t\tdata.finish = true;\r\n\r\n\t\t\t// empty the queue first\r\n\t\t\tjQuery.queue( this, type, [] );\r\n\r\n\t\t\tif ( hooks && hooks.stop ) {\r\n\t\t\t\thooks.stop.call( this, true );\r\n\t\t\t}\r\n\r\n\t\t\t// look for any active animations, and finish them\r\n\t\t\tfor ( index = timers.length; index--; ) {\r\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\r\n\t\t\t\t\ttimers[ index ].anim.stop( true );\r\n\t\t\t\t\ttimers.splice( index, 1 );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// look for any animations in the old queue and finish them\r\n\t\t\tfor ( index = 0; index < length; index++ ) {\r\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\r\n\t\t\t\t\tqueue[ index ].finish.call( this );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// turn off finishing flag\r\n\t\t\tdelete data.finish;\r\n\t\t});\r\n\t}\r\n});\r\n\r\n// Generate parameters to create a standard animation\r\nfunction genFx( type, includeWidth ) {\r\n\tvar which,\r\n\t\tattrs = { height: type },\r\n\t\ti = 0;\r\n\r\n\t// if we include width, step value is 1 to do all cssExpand values,\r\n\t// if we don't include width, step value is 2 to skip over Left and Right\r\n\tincludeWidth = includeWidth? 1 : 0;\r\n\tfor( ; i < 4 ; i += 2 - includeWidth ) {\r\n\t\twhich = cssExpand[ i ];\r\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\r\n\t}\r\n\r\n\tif ( includeWidth ) {\r\n\t\tattrs.opacity = attrs.width = type;\r\n\t}\r\n\r\n\treturn attrs;\r\n}\r\n\r\n// Generate shortcuts for custom animations\r\njQuery.each({\r\n\tslideDown: genFx(\"show\"),\r\n\tslideUp: genFx(\"hide\"),\r\n\tslideToggle: genFx(\"toggle\"),\r\n\tfadeIn: { opacity: \"show\" },\r\n\tfadeOut: { opacity: \"hide\" },\r\n\tfadeToggle: { opacity: \"toggle\" }\r\n}, function( name, props ) {\r\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\r\n\t\treturn this.animate( props, speed, easing, callback );\r\n\t};\r\n});\r\n\r\njQuery.speed = function( speed, easing, fn ) {\r\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\r\n\t\tcomplete: fn || !fn && easing ||\r\n\t\t\tjQuery.isFunction( speed ) && speed,\r\n\t\tduration: speed,\r\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\r\n\t};\r\n\r\n\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\r\n\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\r\n\r\n\t// normalize opt.queue - true/undefined/null -> \"fx\"\r\n\tif ( opt.queue == null || opt.queue === true ) {\r\n\t\topt.queue = \"fx\";\r\n\t}\r\n\r\n\t// Queueing\r\n\topt.old = opt.complete;\r\n\r\n\topt.complete = function() {\r\n\t\tif ( jQuery.isFunction( opt.old ) ) {\r\n\t\t\topt.old.call( this );\r\n\t\t}\r\n\r\n\t\tif ( opt.queue ) {\r\n\t\t\tjQuery.dequeue( this, opt.queue );\r\n\t\t}\r\n\t};\r\n\r\n\treturn opt;\r\n};\r\n\r\njQuery.easing = {\r\n\tlinear: function( p ) {\r\n\t\treturn p;\r\n\t},\r\n\tswing: function( p ) {\r\n\t\treturn 0.5 - Math.cos( p*Math.PI ) / 2;\r\n\t}\r\n};\r\n\r\njQuery.timers = [];\r\njQuery.fx = Tween.prototype.init;\r\njQuery.fx.tick = function() {\r\n\tvar timer,\r\n\t\ttimers = jQuery.timers,\r\n\t\ti = 0;\r\n\r\n\tfxNow = jQuery.now();\r\n\r\n\tfor ( ; i < timers.length; i++ ) {\r\n\t\ttimer = timers[ i ];\r\n\t\t// Checks the timer has not already been removed\r\n\t\tif ( !timer() && timers[ i ] === timer ) {\r\n\t\t\ttimers.splice( i--, 1 );\r\n\t\t}\r\n\t}\r\n\r\n\tif ( !timers.length ) {\r\n\t\tjQuery.fx.stop();\r\n\t}\r\n\tfxNow = undefined;\r\n};\r\n\r\njQuery.fx.timer = function( timer ) {\r\n\tif ( timer() && jQuery.timers.push( timer ) ) {\r\n\t\tjQuery.fx.start();\r\n\t}\r\n};\r\n\r\njQuery.fx.interval = 13;\r\n\r\njQuery.fx.start = function() {\r\n\tif ( !timerId ) {\r\n\t\ttimerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\r\n\t}\r\n};\r\n\r\njQuery.fx.stop = function() {\r\n\tclearInterval( timerId );\r\n\ttimerId = null;\r\n};\r\n\r\njQuery.fx.speeds = {\r\n\tslow: 600,\r\n\tfast: 200,\r\n\t// Default speed\r\n\t_default: 400\r\n};\r\n\r\n// Back Compat <1.8 extension point\r\njQuery.fx.step = {};\r\n\r\nif ( jQuery.expr && jQuery.expr.filters ) {\r\n\tjQuery.expr.filters.animated = function( elem ) {\r\n\t\treturn jQuery.grep(jQuery.timers, function( fn ) {\r\n\t\t\treturn elem === fn.elem;\r\n\t\t}).length;\r\n\t};\r\n}\r\njQuery.fn.offset = function( options ) {\r\n\tif ( arguments.length ) {\r\n\t\treturn options === undefined ?\r\n\t\t\tthis :\r\n\t\t\tthis.each(function( i ) {\r\n\t\t\t\tjQuery.offset.setOffset( this, options, i );\r\n\t\t\t});\r\n\t}\r\n\r\n\tvar docElem, win,\r\n\t\telem = this[ 0 ],\r\n\t\tbox = { top: 0, left: 0 },\r\n\t\tdoc = elem && elem.ownerDocument;\r\n\r\n\tif ( !doc ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tdocElem = doc.documentElement;\r\n\r\n\t// Make sure it's not a disconnected DOM node\r\n\tif ( !jQuery.contains( docElem, elem ) ) {\r\n\t\treturn box;\r\n\t}\r\n\r\n\t// If we don't have gBCR, just use 0,0 rather than error\r\n\t// BlackBerry 5, iOS 3 (original iPhone)\r\n\tif ( typeof elem.getBoundingClientRect !== core_strundefined ) {\r\n\t\tbox = elem.getBoundingClientRect();\r\n\t}\r\n\twin = getWindow( doc );\r\n\treturn {\r\n\t\ttop: box.top + win.pageYOffset - docElem.clientTop,\r\n\t\tleft: box.left + win.pageXOffset - docElem.clientLeft\r\n\t};\r\n};\r\n\r\njQuery.offset = {\r\n\r\n\tsetOffset: function( elem, options, i ) {\r\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\r\n\t\t\tposition = jQuery.css( elem, \"position\" ),\r\n\t\t\tcurElem = jQuery( elem ),\r\n\t\t\tprops = {};\r\n\r\n\t\t// Set position first, in-case top/left are set even on static elem\r\n\t\tif ( position === \"static\" ) {\r\n\t\t\telem.style.position = \"relative\";\r\n\t\t}\r\n\r\n\t\tcurOffset = curElem.offset();\r\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\r\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\r\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) && ( curCSSTop + curCSSLeft ).indexOf(\"auto\") > -1;\r\n\r\n\t\t// Need to be able to calculate position if either top or left is auto and position is either absolute or fixed\r\n\t\tif ( calculatePosition ) {\r\n\t\t\tcurPosition = curElem.position();\r\n\t\t\tcurTop = curPosition.top;\r\n\t\t\tcurLeft = curPosition.left;\r\n\r\n\t\t} else {\r\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\r\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\r\n\t\t}\r\n\r\n\t\tif ( jQuery.isFunction( options ) ) {\r\n\t\t\toptions = options.call( elem, i, curOffset );\r\n\t\t}\r\n\r\n\t\tif ( options.top != null ) {\r\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\r\n\t\t}\r\n\t\tif ( options.left != null ) {\r\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\r\n\t\t}\r\n\r\n\t\tif ( \"using\" in options ) {\r\n\t\t\toptions.using.call( elem, props );\r\n\r\n\t\t} else {\r\n\t\t\tcurElem.css( props );\r\n\t\t}\r\n\t}\r\n};\r\n\r\n\r\njQuery.fn.extend({\r\n\r\n\tposition: function() {\r\n\t\tif ( !this[ 0 ] ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar offsetParent, offset,\r\n\t\t\telem = this[ 0 ],\r\n\t\t\tparentOffset = { top: 0, left: 0 };\r\n\r\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\r\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\r\n\t\t\t// We assume that getBoundingClientRect is available when computed position is fixed\r\n\t\t\toffset = elem.getBoundingClientRect();\r\n\r\n\t\t} else {\r\n\t\t\t// Get *real* offsetParent\r\n\t\t\toffsetParent = this.offsetParent();\r\n\r\n\t\t\t// Get correct offsets\r\n\t\t\toffset = this.offset();\r\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\r\n\t\t\t\tparentOffset = offsetParent.offset();\r\n\t\t\t}\r\n\r\n\t\t\t// Add offsetParent borders\r\n\t\t\tparentOffset.top += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\r\n\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\r\n\t\t}\r\n\r\n\t\t// Subtract parent offsets and element margins\r\n\t\treturn {\r\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\r\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\r\n\t\t};\r\n\t},\r\n\r\n\toffsetParent: function() {\r\n\t\treturn this.map(function() {\r\n\t\t\tvar offsetParent = this.offsetParent || docElem;\r\n\r\n\t\t\twhile ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\") === \"static\" ) ) {\r\n\t\t\t\toffsetParent = offsetParent.offsetParent;\r\n\t\t\t}\r\n\r\n\t\t\treturn offsetParent || docElem;\r\n\t\t});\r\n\t}\r\n});\r\n\r\n\r\n// Create scrollLeft and scrollTop methods\r\njQuery.each( {scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\"}, function( method, prop ) {\r\n\tvar top = \"pageYOffset\" === prop;\r\n\r\n\tjQuery.fn[ method ] = function( val ) {\r\n\t\treturn jQuery.access( this, function( elem, method, val ) {\r\n\t\t\tvar win = getWindow( elem );\r\n\r\n\t\t\tif ( val === undefined ) {\r\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\r\n\t\t\t}\r\n\r\n\t\t\tif ( win ) {\r\n\t\t\t\twin.scrollTo(\r\n\t\t\t\t\t!top ? val : window.pageXOffset,\r\n\t\t\t\t\ttop ? val : window.pageYOffset\r\n\t\t\t\t);\r\n\r\n\t\t\t} else {\r\n\t\t\t\telem[ method ] = val;\r\n\t\t\t}\r\n\t\t}, method, val, arguments.length, null );\r\n\t};\r\n});\r\n\r\nfunction getWindow( elem ) {\r\n\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\r\n}\r\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\r\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\r\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\r\n\t\t// margin is only for outerHeight, outerWidth\r\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\r\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\r\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\r\n\r\n\t\t\treturn jQuery.access( this, function( elem, type, value ) {\r\n\t\t\t\tvar doc;\r\n\r\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\r\n\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\r\n\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\r\n\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\r\n\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Get document width or height\r\n\t\t\t\tif ( elem.nodeType === 9 ) {\r\n\t\t\t\t\tdoc = elem.documentElement;\r\n\r\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\r\n\t\t\t\t\t// whichever is greatest\r\n\t\t\t\t\treturn Math.max(\r\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\r\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\r\n\t\t\t\t\t\tdoc[ \"client\" + name ]\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn value === undefined ?\r\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\r\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\r\n\r\n\t\t\t\t\t// Set width or height on the element\r\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\r\n\t\t\t}, type, chainable ? margin : undefined, chainable, null );\r\n\t\t};\r\n\t});\r\n});\r\n// Limit scope pollution from any deprecated API\r\n// (function() {\r\n\r\n// The number of elements contained in the matched element set\r\njQuery.fn.size = function() {\r\n\treturn this.length;\r\n};\r\n\r\njQuery.fn.andSelf = jQuery.fn.addBack;\r\n\r\n// })();\r\nif ( typeof module === \"object\" && module && typeof module.exports === \"object\" ) {\r\n\t// Expose jQuery as module.exports in loaders that implement the Node\r\n\t// module pattern (including browserify). Do not create the global, since\r\n\t// the user will be storing it themselves locally, and globals are frowned\r\n\t// upon in the Node module world.\r\n\tmodule.exports = jQuery;\r\n} else {\r\n\t// Register as a named AMD module, since jQuery can be concatenated with other\r\n\t// files that may use define, but not via a proper concatenation script that\r\n\t// understands anonymous AMD modules. A named AMD is safest and most robust\r\n\t// way to register. Lowercase jquery is used because AMD module names are\r\n\t// derived from file names, and jQuery is normally delivered in a lowercase\r\n\t// file name. Do this after creating the global so that if an AMD module wants\r\n\t// to call noConflict to hide this version of jQuery, it will work.\r\n\tif ( typeof define === \"function\" && define.amd ) {\r\n\t\tdefine( \"jquery\", [], function () { return jQuery; } );\r\n\t}\r\n}\r\n\r\n// If there is a window object, that at least has a document property,\r\n// define jQuery and $ identifiers\r\nif ( typeof window === \"object\" && typeof window.document === \"object\" ) {\r\n\twindow.jQuery = window.$ = jQuery;\r\n}\r\n\r\n})( window );",
    "\n/*! Ractive - v0.3.7 - 2013-10-14\r\n* Next-generation DOM manipulation\r\n\r\n* http://ractivejs.org\r\n* Copyright (c) 2013 Rich Harris; Licensed MIT */\r\n\r\n(function ( global ) {\r\n\r\n'use strict';\r\n\r\nvar Ractive,\r\n\r\n// current version\r\nVERSION = '0.3.7',\r\n\r\ndoc = global.document || null,\r\n\r\n// Ractive prototype\r\nproto = {},\r\n\r\n// properties of the public Ractive object\r\nadaptors = {},\r\neventDefinitions = {},\r\neasing,\r\nextend,\r\nparse,\r\ninterpolate,\r\ninterpolators,\r\ntransitions = {},\r\n\r\n\r\n// internal utils - instance-specific\r\nteardown,\r\nclearCache,\r\nregisterDependant,\r\nunregisterDependant,\r\nnotifyDependants,\r\nnotifyMultipleDependants,\r\nnotifyDependantsByPriority,\r\nresolveRef,\r\nprocessDeferredUpdates,\r\n\r\n\r\n// internal utils\r\ntoString,\r\nisArray,\r\nisObject,\r\nisNumeric,\r\nisEqual,\r\ngetEl,\r\ninsertHtml,\r\nreassignFragments,\r\nexecuteTransition,\r\ngetPartialDescriptor,\r\ngetComponentConstructor,\r\nisStringFragmentSimple,\r\nmakeTransitionManager,\r\nrequestAnimationFrame,\r\ndefineProperty,\r\ndefineProperties,\r\ncreate,\r\ncreateFromNull,\r\nhasOwn = {}.hasOwnProperty,\r\nnoop = function () {},\r\naddEventProxies,\r\naddEventProxy,\r\nappendElementChildren,\r\nbindElement,\r\ncreateElementAttributes,\r\ngetElementNamespace,\r\nupdateAttribute,\r\nbindAttribute,\r\nconsole = global.console || { log: noop, warn: noop },\r\n\r\n\r\n// internally used constructors\r\nDomFragment,\r\nDomElement,\r\nDomAttribute,\r\nDomPartial,\r\nDomComponent,\r\nDomInterpolator,\r\nDomTriple,\r\nDomSection,\r\nDomText,\r\n\r\nStringFragment,\r\nStringInterpolator,\r\nStringSection,\r\nStringText,\r\n\r\nExpressionResolver,\r\nEvaluator,\r\nAnimation,\r\n\r\n\r\n// internally used regexes\r\nleadingWhitespace = /^\\s+/,\r\ntrailingWhitespace = /\\s+$/,\r\n\r\n\r\n// other bits and pieces\r\nrender,\r\n\r\ninitMustache,\r\nupdateMustache,\r\nresolveMustache,\r\n\r\ninitFragment,\r\nupdateSection,\r\n\r\nanimationCollection,\r\n\r\n\r\n// array modification\r\nregisterKeypathToArray,\r\nunregisterKeypathFromArray,\r\n\r\n\r\n// parser and tokenizer\r\ngetFragmentStubFromTokens,\r\ngetToken,\r\ntokenize,\r\nstripCommentTokens,\r\nstripHtmlComments,\r\nstripStandalones,\r\n\r\n\r\n// error messages\r\nmissingParser = 'Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser',\r\n\r\n\r\n// constants\r\nTEXT              = 1,\r\nINTERPOLATOR      = 2,\r\nTRIPLE            = 3,\r\nSECTION           = 4,\r\nINVERTED          = 5,\r\nCLOSING           = 6,\r\nELEMENT           = 7,\r\nPARTIAL           = 8,\r\nCOMMENT           = 9,\r\nDELIMCHANGE       = 10,\r\nMUSTACHE          = 11,\r\nTAG               = 12,\r\n\r\nCOMPONENT         = 15,\r\n\r\nNUMBER_LITERAL    = 20,\r\nSTRING_LITERAL    = 21,\r\nARRAY_LITERAL     = 22,\r\nOBJECT_LITERAL    = 23,\r\nBOOLEAN_LITERAL   = 24,\r\n\r\nGLOBAL            = 26,\r\nKEY_VALUE_PAIR    = 27,\r\n\r\n\r\nREFERENCE         = 30,\r\nREFINEMENT        = 31,\r\nMEMBER            = 32,\r\nPREFIX_OPERATOR   = 33,\r\nBRACKETED         = 34,\r\nCONDITIONAL       = 35,\r\nINFIX_OPERATOR    = 36,\r\n\r\nINVOCATION        = 40,\r\n\r\ntestDiv = ( doc ? doc.createElement( 'div' ) : null ),\r\nnoMagic,\r\n\r\n\r\n// namespaces\r\nnamespaces = {\r\n\thtml:   'http://www.w3.org/1999/xhtml',\r\n\tmathml: 'http://www.w3.org/1998/Math/MathML',\r\n\tsvg:    'http://www.w3.org/2000/svg',\r\n\txlink:  'http://www.w3.org/1999/xlink',\r\n\txml:    'http://www.w3.org/XML/1998/namespace',\r\n\txmlns:  'http://www.w3.org/2000/xmlns/'\r\n};\r\n\r\n\r\n\r\n// we're creating a defineProperty function here - we don't want to add\r\n// this to _legacy.js since it's not a polyfill. It won't allow us to set\r\n// non-enumerable properties. That shouldn't be a problem, unless you're\r\n// using for...in on a (modified) array, in which case you deserve what's\r\n// coming anyway\r\ntry {\r\n\ttry {\r\n\t\tObject.defineProperty({}, 'test', { value: 0 });\r\n\t\tObject.defineProperties({}, { test: { value: 0 } });\r\n\t} catch ( err ) {\r\n\t\tnoMagic = true;\r\n\t\tthrow err;\r\n\t}\r\n\r\n\tif ( doc ) {\r\n\t\tObject.defineProperty( testDiv, 'test', { value: 0 });\r\n\t\tObject.defineProperties( testDiv, { test: { value: 0 } });\r\n\t}\r\n\r\n\tdefineProperty = Object.defineProperty;\r\n\tdefineProperties = Object.defineProperties;\r\n} catch ( err ) {\r\n\t// Object.defineProperty doesn't exist, or we're in IE8 where you can\r\n\t// only use it with DOM objects (what the fuck were you smoking, MSFT?)\r\n\tdefineProperty = function ( obj, prop, desc ) {\r\n\t\tobj[ prop ] = desc.value;\r\n\t};\r\n\r\n\tdefineProperties = function ( obj, props ) {\r\n\t\tvar prop;\r\n\r\n\t\tfor ( prop in props ) {\r\n\t\t\tif ( props.hasOwnProperty( prop ) ) {\r\n\t\t\t\tdefineProperty( obj, prop, props[ prop ] );\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\n\r\ntry {\r\n\tObject.create( null );\r\n\r\n\tcreate = Object.create;\r\n\r\n\tcreateFromNull = function () {\r\n\t\treturn Object.create( null );\r\n\t};\r\n} catch ( err ) {\r\n\t// sigh\r\n\tcreate = (function () {\r\n\t\tvar F = function () {};\r\n\r\n\t\treturn function ( proto, props ) {\r\n\t\t\tvar obj;\r\n\r\n\t\t\tF.prototype = proto;\r\n\t\t\tobj = new F();\r\n\r\n\t\t\tif ( props ) {\r\n\t\t\t\tObject.defineProperties( obj, props );\r\n\t\t\t}\r\n\r\n\t\t\treturn obj;\r\n\t\t};\r\n\t}());\r\n\r\n\tcreateFromNull = function () {\r\n\t\treturn {}; // hope you're not modifying the Object prototype\r\n\t};\r\n}\r\n\r\n\r\n\r\nvar hyphenate = function ( str ) {\r\n\treturn str.replace( /[A-Z]/g, function ( match ) {\r\n\t\treturn '-' + match.toLowerCase();\r\n\t});\r\n};\r\n\r\n// determine some facts about our environment\r\nvar cssTransitionsEnabled, transition, transitionend;\r\n\r\n(function () {\r\n\r\n\tif ( !doc ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tif ( testDiv.style.transition !== undefined ) {\r\n\t\ttransition = 'transition';\r\n\t\ttransitionend = 'transitionend';\r\n\t\tcssTransitionsEnabled = true;\r\n\t} else if ( testDiv.style.webkitTransition !== undefined ) {\r\n\t\ttransition = 'webkitTransition';\r\n\t\ttransitionend = 'webkitTransitionEnd';\r\n\t\tcssTransitionsEnabled = true;\r\n\t} else {\r\n\t\tcssTransitionsEnabled = false;\r\n\t}\r\n\r\n}());\r\n\r\n\r\n// Internet Explorer derp. Methods that should be attached to Node.prototype\r\n// are instead attached to HTMLElement.prototype, which means SVG elements\r\n// can't use them. Remember kids, friends don't let friends use IE.\r\nif ( global.Node && !global.Node.prototype.contains && global.HTMLElement && global.HTMLElement.prototype.contains ) {\r\n\tglobal.Node.prototype.contains = global.HTMLElement.prototype.contains;\r\n}\r\n(function () {\r\n\r\n\tvar getInterpolator,\r\n\t\tupdateModel,\r\n\t\tgetBinding,\r\n\t\tinheritProperties,\r\n\t\tMultipleSelectBinding,\r\n\t\tSelectBinding,\r\n\t\tRadioNameBinding,\r\n\t\tCheckboxNameBinding,\r\n\t\tCheckedBinding,\r\n\t\tFileListBinding,\r\n\t\tGenericBinding;\r\n\r\n\tbindAttribute = function () {\r\n\t\tvar node = this.parentNode, interpolator, binding, bindings;\r\n\r\n\t\tif ( !this.fragment ) {\r\n\t\t\treturn false; // report failure\r\n\t\t}\r\n\r\n\t\tinterpolator = getInterpolator( this );\r\n\r\n\t\tif ( !interpolator ) {\r\n\t\t\treturn false; // report failure\r\n\t\t}\r\n\r\n\t\tthis.interpolator = interpolator;\r\n\r\n\t\t// Hmmm. Not sure if this is the best way to handle this ambiguity...\r\n\t\t//\r\n\t\t// Let's say we were given `value=\"{{bar}}\"`. If the context stack was\r\n\t\t// context stack was `[\"foo\"]`, and `foo.bar` *wasn't* `undefined`, the\r\n\t\t// keypath would be `foo.bar`. Then, any user input would result in\r\n\t\t// `foo.bar` being updated.\r\n\t\t//\r\n\t\t// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be\r\n\t\t// left with an unresolved partial keypath - so we are forced to make an\r\n\t\t// assumption. That assumption is that the input in question should\r\n\t\t// be forced to resolve to `bar`, and any user input would affect `bar`\r\n\t\t// and not `foo.bar`.\r\n\t\t//\r\n\t\t// Did that make any sense? No? Oh. Sorry. Well the moral of the story is\r\n\t\t// be explicit when using two-way data-binding about what keypath you're\r\n\t\t// updating. Using it in lists is probably a recipe for confusion...\r\n\t\tthis.keypath = interpolator.keypath || interpolator.descriptor.r;\r\n\r\n\t\tbinding = getBinding( this );\r\n\r\n\t\tif ( !binding ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tnode._ractive.binding = binding;\r\n\t\tthis.twoway = true;\r\n\r\n\t\t// register this with the root, so that we can force an update later\r\n\t\tbindings = this.root._twowayBindings[ this.keypath ] || ( this.root._twowayBindings[ this.keypath ] = [] );\r\n\t\tbindings[ bindings.length ] = binding;\r\n\r\n\t\treturn true;\r\n\t};\r\n\r\n\r\n\t// This is the handler for DOM events that would lead to a change in the model\r\n\t// (i.e. change, sometimes, input, and occasionally click and keyup)\r\n\tupdateModel = function () {\r\n\t\tthis._ractive.binding.update();\r\n\t};\r\n\r\n\tgetInterpolator = function ( attribute ) {\r\n\t\tvar item;\r\n\r\n\t\t// TODO refactor this? Couldn't the interpolator have got a keypath via an expression?\r\n\t\t// Check this is a suitable candidate for two-way binding - i.e. it is\r\n\t\t// a single interpolator, which isn't an expression\r\n\t\tif ( attribute.fragment.items.length !== 1 ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\titem = attribute.fragment.items[0];\r\n\t\t\t\r\n\t\tif ( item.type !== INTERPOLATOR ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tif ( !item.keypath && !item.ref ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn item;\r\n\t};\r\n\r\n\tgetBinding = function ( attribute ) {\r\n\t\tvar node = attribute.parentNode;\r\n\r\n\t\tif ( node.tagName === 'SELECT' ) {\r\n\t\t\treturn ( node.multiple ? new MultipleSelectBinding( attribute, node ) : new SelectBinding( attribute, node ) );\r\n\t\t}\r\n\r\n\t\tif ( node.type === 'checkbox' || node.type === 'radio' ) {\r\n\t\t\tif ( attribute.propertyName === 'name' ) {\r\n\t\t\t\tif ( node.type === 'checkbox' ) {\r\n\t\t\t\t\treturn new CheckboxNameBinding( attribute, node );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( node.type === 'radio' ) {\r\n\t\t\t\t\treturn new RadioNameBinding( attribute, node );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( attribute.propertyName === 'checked' ) {\r\n\t\t\t\treturn new CheckedBinding( attribute, node );\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tif ( attribute.propertyName !== 'value' ) {\r\n\t\t\tconsole.warn( 'This is... odd' );\r\n\t\t}\r\n\r\n\t\tif ( attribute.parentNode.type === 'file' ) {\r\n\t\t\treturn new FileListBinding( attribute, node );\r\n\t\t}\r\n\r\n\t\treturn new GenericBinding( attribute, node );\r\n\t};\r\n\r\n\tMultipleSelectBinding = function ( attribute, node ) {\r\n\t\tvar valueFromModel;\r\n\r\n\t\tinheritProperties( this, attribute, node );\r\n\t\tnode.addEventListener( 'change', updateModel, false );\r\n\r\n\t\tvalueFromModel = this.root.get( this.keypath );\r\n\r\n\t\tif ( valueFromModel === undefined ) {\r\n\t\t\t// get value from DOM, if possible\r\n\t\t\tthis.update();\r\n\t\t}\r\n\t};\r\n\r\n\tMultipleSelectBinding.prototype = {\r\n\t\tvalue: function () {\r\n\t\t\tvar value, options, i, len;\r\n\r\n\t\t\tvalue = [];\r\n\t\t\toptions = this.node.options;\r\n\t\t\tlen = options.length;\r\n\t\t\t\r\n\t\t\tfor ( i=0; i<len; i+=1 ) {\r\n\t\t\t\tif ( options[i].selected ) {\r\n\t\t\t\t\tvalue[ value.length ] = options[i]._ractive.value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn value;\r\n\t\t},\r\n\r\n\t\tupdate: function () {\r\n\t\t\tvar attribute, previousValue, value;\r\n\r\n\t\t\tattribute = this.attr;\r\n\t\t\tpreviousValue = attribute.value;\r\n\r\n\t\t\tvalue = this.value();\r\n\t\t\t\r\n\t\t\tif ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {\r\n\t\t\t\t// either length or contents have changed, so we update the model\r\n\t\t\t\tattribute.receiving = true;\r\n\t\t\t\tattribute.value = value;\r\n\t\t\t\tthis.root.set( this.keypath, value );\r\n\t\t\t\tattribute.receiving = false;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tteardown: function () {\r\n\t\t\tthis.node.removeEventListener( 'change', updateModel, false );\r\n\t\t}\r\n\t};\r\n\r\n\tSelectBinding = function ( attribute, node ) {\r\n\t\tvar valueFromModel;\r\n\r\n\t\tinheritProperties( this, attribute, node );\r\n\t\tnode.addEventListener( 'change', updateModel, false );\r\n\r\n\t\tvalueFromModel = this.root.get( this.keypath );\r\n\r\n\t\tif ( valueFromModel === undefined ) {\r\n\t\t\t// get value from DOM, if possible\r\n\t\t\tthis.update();\r\n\t\t}\r\n\t};\r\n\r\n\tSelectBinding.prototype = {\r\n\t\tvalue: function () {\r\n\t\t\tvar options, i, len;\r\n\r\n\t\t\toptions = this.node.options;\r\n\t\t\tlen = options.length;\r\n\r\n\t\t\tfor ( i=0; i<len; i+=1 ) {\r\n\t\t\t\tif ( options[i].selected ) {\r\n\t\t\t\t\treturn options[i]._ractive.value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tupdate: function () {\r\n\t\t\tvar value = this.value();\r\n\r\n\t\t\tthis.attr.receiving = true;\r\n\t\t\tthis.attr.value = value;\r\n\t\t\tthis.root.set( this.keypath, value );\r\n\t\t\tthis.attr.receiving = false;\r\n\t\t},\r\n\r\n\t\tteardown: function () {\r\n\t\t\tthis.node.removeEventListener( 'change', updateModel, false );\r\n\t\t}\r\n\t};\r\n\r\n\tRadioNameBinding = function ( attribute, node ) {\r\n\t\tvar valueFromModel;\r\n\r\n\t\tthis.radioName = true; // so that updateModel knows what to do with this\r\n\r\n\t\tinheritProperties( this, attribute, node );\r\n\r\n\t\tnode.name = '{{' + attribute.keypath + '}}';\r\n\r\n\t\tnode.addEventListener( 'change', updateModel, false );\r\n\r\n\t\tif ( node.attachEvent ) {\r\n\t\t\tnode.addEventListener( 'click', updateModel, false );\r\n\t\t}\r\n\r\n\t\tvalueFromModel = this.root.get( this.keypath );\r\n\t\tif ( valueFromModel !== undefined ) {\r\n\t\t\tnode.checked = ( valueFromModel === node._ractive.value );\r\n\t\t} else {\r\n\t\t\tthis.root._defRadios[ this.root._defRadios.length ] = this;\r\n\t\t}\r\n\t};\r\n\r\n\tRadioNameBinding.prototype = {\r\n\t\tvalue: function () {\r\n\t\t\treturn this.node._ractive ? this.node._ractive.value : this.node.value;\r\n\t\t},\r\n\r\n\t\tupdate: function () {\r\n\t\t\tvar node = this.node;\r\n\r\n\t\t\tif ( node.checked ) {\r\n\t\t\t\tthis.attr.receiving = true;\r\n\t\t\t\tthis.root.set( this.keypath, this.value() );\r\n\t\t\t\tthis.attr.receiving = false;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tteardown: function () {\r\n\t\t\tthis.node.removeEventListener( 'change', updateModel, false );\r\n\t\t\tthis.node.removeEventListener( 'click', updateModel, false );\r\n\t\t}\r\n\t};\r\n\r\n\tCheckboxNameBinding = function ( attribute, node ) {\r\n\t\tvar valueFromModel, checked;\r\n\r\n\t\tthis.checkboxName = true; // so that updateModel knows what to do with this\r\n\r\n\t\tinheritProperties( this, attribute, node );\r\n\r\n\t\tnode.name = '{{' + this.keypath + '}}';\r\n\r\n\t\tnode.addEventListener( 'change', updateModel, false );\r\n\r\n\t\t// in case of IE emergency, bind to click event as well\r\n\t\tif ( node.attachEvent ) {\r\n\t\t\tnode.addEventListener( 'click', updateModel, false );\r\n\t\t}\r\n\r\n\t\tvalueFromModel = this.root.get( this.keypath );\r\n\r\n\t\t// if the model already specifies this value, check/uncheck accordingly\r\n\t\tif ( valueFromModel !== undefined ) {\r\n\t\t\tchecked = valueFromModel.indexOf( node._ractive.value ) !== -1;\r\n\t\t\tnode.checked = checked;\r\n\t\t}\r\n\r\n\t\t// otherwise make a note that we will need to update the model later\r\n\t\telse {\r\n\t\t\tif ( this.root._defCheckboxes.indexOf( this.keypath ) === -1 ) {\r\n\t\t\t\tthis.root._defCheckboxes[ this.root._defCheckboxes.length ] = this.keypath;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tCheckboxNameBinding.prototype = {\r\n\t\tchanged: function () {\r\n\t\t\treturn this.node.checked !== !!this.checked;\r\n\t\t},\r\n\r\n\t\tupdate: function () {\r\n\t\t\tthis.checked = this.node.checked;\r\n\r\n\t\t\tthis.attr.receiving = true;\r\n\t\t\tthis.root.set( this.keypath, getValueFromCheckboxes( this.root, this.keypath ) );\r\n\t\t\tthis.attr.receiving = false;\r\n\t\t},\r\n\r\n\t\tteardown: function () {\r\n\t\t\tthis.node.removeEventListener( 'change', updateModel, false );\r\n\t\t\tthis.node.removeEventListener( 'click', updateModel, false );\r\n\t\t}\r\n\t};\r\n\r\n\tCheckedBinding = function ( attribute, node ) {\r\n\t\tinheritProperties( this, attribute, node );\r\n\r\n\t\tnode.addEventListener( 'change', updateModel, false );\r\n\r\n\t\tif ( node.attachEvent ) {\r\n\t\t\tnode.addEventListener( 'click', updateModel, false );\r\n\t\t}\r\n\t};\r\n\r\n\tCheckedBinding.prototype = {\r\n\t\tvalue: function () {\r\n\t\t\treturn this.node.checked;\r\n\t\t},\r\n\r\n\t\tupdate: function () {\r\n\t\t\tthis.attr.receiving = true;\r\n\t\t\tthis.root.set( this.keypath, this.value() );\r\n\t\t\tthis.attr.receiving = false;\r\n\t\t},\r\n\r\n\t\tteardown: function () {\r\n\t\t\tthis.node.removeEventListener( 'change', updateModel, false );\r\n\t\t\tthis.node.removeEventListener( 'click', updateModel, false );\r\n\t\t}\r\n\t};\r\n\r\n\tFileListBinding = function ( attribute, node ) {\r\n\t\tinheritProperties( this, attribute, node );\r\n\r\n\t\tnode.addEventListener( 'change', updateModel, false );\r\n\t};\r\n\r\n\tFileListBinding.prototype = {\r\n\t\tvalue: function () {\r\n\t\t\treturn this.attr.parentNode.files;\r\n\t\t},\r\n\r\n\t\tupdate: function () {\r\n\t\t\tthis.attr.root.set( this.attr.keypath, this.value() );\r\n\t\t},\r\n\r\n\t\tteardown: function () {\r\n\t\t\tthis.node.removeEventListener( 'change', updateModel, false );\r\n\t\t}\r\n\t};\r\n\r\n\tGenericBinding = function ( attribute, node ) {\r\n\t\tinheritProperties( this, attribute, node );\r\n\r\n\t\tnode.addEventListener( 'change', updateModel, false );\r\n\r\n\t\tif ( !this.root.lazy ) {\r\n\t\t\tnode.addEventListener( 'input', updateModel, false );\r\n\r\n\t\t\tif ( node.attachEvent ) {\r\n\t\t\t\tnode.addEventListener( 'keyup', updateModel, false );\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tGenericBinding.prototype = {\r\n\t\tvalue: function () {\r\n\t\t\tvar value = this.attr.parentNode.value;\r\n\r\n\t\t\t// if the value is numeric, treat it as a number. otherwise don't\r\n\t\t\tif ( ( +value + '' === value ) && value.indexOf( 'e' ) === -1 ) {\r\n\t\t\t\tvalue = +value;\r\n\t\t\t}\r\n\r\n\t\t\treturn value;\r\n\t\t},\r\n\r\n\t\tupdate: function () {\r\n\t\t\tvar attribute = this.attr, value = this.value();\r\n\r\n\t\t\tattribute.receiving = true;\r\n\t\t\tattribute.root.set( attribute.keypath, value );\r\n\t\t\tattribute.receiving = false;\r\n\t\t},\r\n\r\n\t\tteardown: function () {\r\n\t\t\tthis.node.removeEventListener( 'change', updateModel, false );\r\n\t\t\tthis.node.removeEventListener( 'input', updateModel, false );\r\n\t\t\tthis.node.removeEventListener( 'keyup', updateModel, false );\r\n\t\t}\r\n\t};\r\n\r\n\tinheritProperties = function ( binding, attribute, node ) {\r\n\t\tbinding.attr = attribute;\r\n\t\tbinding.node = node;\r\n\t\tbinding.root = attribute.root;\r\n\t\tbinding.keypath = attribute.keypath;\r\n\t};\r\n\r\n}());\r\n(function () {\r\n\r\n\tvar updateFileInputValue, deferSelect, initSelect, updateSelect, updateMultipleSelect, updateRadioName, updateCheckboxName, updateEverythingElse;\r\n\r\n\t// There are a few special cases when it comes to updating attributes. For this reason,\r\n\t// the prototype .update() method points to updateAttribute, which waits until the\r\n\t// attribute has finished initialising, then replaces the prototype method with a more\r\n\t// suitable one. That way, we save ourselves doing a bunch of tests on each call\r\n\tupdateAttribute = function () {\r\n\t\tvar node;\r\n\r\n\t\tif ( !this.ready ) {\r\n\t\t\treturn this; // avoid items bubbling to the surface when we're still initialising\r\n\t\t}\r\n\r\n\t\tnode = this.parentNode;\r\n\r\n\t\t// special case - selects\r\n\t\tif ( node.tagName === 'SELECT' && this.name === 'value' ) {\r\n\t\t\tthis.update = deferSelect;\r\n\t\t\tthis.deferredUpdate = initSelect; // we don't know yet if it's a select-one or select-multiple\r\n\r\n\t\t\treturn this.update();\r\n\t\t}\r\n\r\n\t\t// special case - <input type='file' value='{{fileList}}'>\r\n\t\tif ( this.isFileInputValue ) {\r\n\t\t\tthis.update = updateFileInputValue; // save ourselves the trouble next time\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\t// special case - <input type='radio' name='{{twoway}}' value='foo'>\r\n\t\tif ( this.twoway && this.name === 'name' ) {\r\n\t\t\tif ( node.type === 'radio' ) {\r\n\t\t\t\tthis.update = updateRadioName;\r\n\t\t\t\treturn this.update();\r\n\t\t\t}\r\n\r\n\t\t\tif ( node.type === 'checkbox' ) {\r\n\t\t\t\tthis.update = updateCheckboxName;\r\n\t\t\t\treturn this.update();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.update = updateEverythingElse;\r\n\t\treturn this.update();\r\n\t};\r\n\r\n\tupdateFileInputValue = function () {\r\n\t\treturn this; // noop - file inputs are readonly\r\n\t};\r\n\r\n\tinitSelect = function () {\r\n\t\t// we're now in a position to decide whether this is a select-one or select-multiple\r\n\t\tthis.deferredUpdate = ( this.parentNode.multiple ? updateMultipleSelect : updateSelect );\r\n\t\tthis.deferredUpdate();\r\n\t};\r\n\r\n\tdeferSelect = function () {\r\n\t\t// because select values depend partly on the values of their children, and their\r\n\t\t// children may be entering and leaving the DOM, we wait until updates are\r\n\t\t// complete before updating\r\n\t\tthis.root._defSelectValues.push( this );\r\n\t\treturn this;\r\n\t};\r\n\r\n\tupdateSelect = function () {\r\n\t\tvar value = this.fragment.getValue(), options, option, i;\r\n\r\n\t\tthis.value = value;\r\n\r\n\t\toptions = this.parentNode.options;\r\n\t\ti = options.length;\r\n\r\n\t\twhile ( i-- ) {\r\n\t\t\toption = options[i];\r\n\r\n\t\t\tif ( option._ractive.value === value ) {\r\n\t\t\t\toption.selected = true;\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// if we're still here, it means the new value didn't match any of the options...\r\n\t\t// TODO figure out what to do in this situation\r\n\t\t\r\n\t\treturn this;\r\n\t};\r\n\r\n\tupdateMultipleSelect = function () {\r\n\t\tvar value = this.fragment.getValue(), options, i;\r\n\r\n\t\tif ( !isArray( value ) ) {\r\n\t\t\tvalue = [ value ];\r\n\t\t}\r\n\r\n\t\toptions = this.parentNode.options;\r\n\t\ti = options.length;\r\n\r\n\t\twhile ( i-- ) {\r\n\t\t\toptions[i].selected = ( value.indexOf( options[i]._ractive.value ) !== -1 );\r\n\t\t}\r\n\r\n\t\tthis.value = value;\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\tupdateRadioName = function () {\r\n\t\tvar node, value;\r\n\r\n\t\tnode = this.parentNode;\r\n\t\tvalue = this.fragment.getValue();\r\n\r\n\t\tnode.checked = ( value === node._ractive.value );\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\tupdateCheckboxName = function () {\r\n\t\tvar node, value;\r\n\r\n\t\tnode = this.parentNode;\r\n\t\tvalue = this.fragment.getValue();\r\n\r\n\t\tif ( !isArray( value ) ) {\r\n\t\t\tnode.checked = ( value === node._ractive.value );\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tnode.checked = ( value.indexOf( node._ractive.value ) !== -1 );\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\tupdateEverythingElse = function () {\r\n\t\tvar node, value;\r\n\r\n\t\tnode = this.parentNode;\r\n\t\tvalue = this.fragment.getValue();\r\n\r\n\t\t// store actual value, so it doesn't get coerced to a string\r\n\t\tif ( this.isValueAttribute ) {\r\n\t\t\tnode._ractive.value = value;\r\n\t\t}\r\n\r\n\t\tif ( value === undefined ) {\r\n\t\t\tvalue = '';\r\n\t\t}\r\n\r\n\t\tif ( value !== this.value ) {\r\n\t\t\tif ( this.useProperty ) {\r\n\r\n\t\t\t\t// with two-way binding, only update if the change wasn't initiated by the user\r\n\t\t\t\t// otherwise the cursor will often be sent to the wrong place\r\n\t\t\t\tif ( !this.receiving ) {\r\n\t\t\t\t\tnode[ this.propertyName ] = value;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tthis.value = value;\r\n\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.namespace ) {\r\n\t\t\t\tnode.setAttributeNS( this.namespace, this.name, value );\r\n\t\t\t\tthis.value = value;\r\n\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.name === 'id' ) {\r\n\t\t\t\tif ( this.value !== undefined ) {\r\n\t\t\t\t\tthis.root.nodes[ this.value ] = undefined;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.root.nodes[ value ] = node;\r\n\t\t\t}\r\n\r\n\t\t\tnode.setAttribute( this.name, value );\r\n\r\n\t\t\tthis.value = value;\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n}());\r\naddEventProxies = function ( element, proxies ) {\r\n\tvar i, eventName, eventNames;\r\n\r\n\tfor ( eventName in proxies ) {\r\n\t\tif ( hasOwn.call( proxies, eventName ) ) {\r\n\t\t\teventNames = eventName.split( '-' );\r\n\t\t\ti = eventNames.length;\r\n\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\taddEventProxy( element, eventNames[i], proxies[ eventName ], element.parentFragment.contextStack );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n(function () {\r\n\r\n\tvar MasterEventHandler,\r\n\t\tProxyEvent,\r\n\t\tfirePlainEvent,\r\n\t\tfireEventWithArgs,\r\n\t\tfireEventWithDynamicArgs,\r\n\t\tcustomHandlers,\r\n\t\tgenericHandler,\r\n\t\tgetCustomHandler;\r\n\r\n\taddEventProxy = function ( element, triggerEventName, proxyDescriptor, contextStack, indexRefs ) {\r\n\t\tvar events, master;\r\n\r\n\t\tevents = element.ractify().events;\r\n\t\tmaster = events[ triggerEventName ] || ( events[ triggerEventName ] = new MasterEventHandler( element, triggerEventName, contextStack, indexRefs ) );\r\n\r\n\t\tmaster.add( proxyDescriptor );\r\n\t};\r\n\r\n\tMasterEventHandler = function ( element, eventName, contextStack ) {\r\n\t\tvar definition;\r\n\r\n\t\tthis.element = element;\r\n\t\tthis.root = element.root;\r\n\t\tthis.node = element.node;\r\n\t\tthis.name = eventName;\r\n\t\tthis.contextStack = contextStack; // TODO do we need to pass contextStack down everywhere? Doesn't it belong to the parentFragment?\r\n\t\tthis.proxies = [];\r\n\r\n\t\tif ( definition = ( this.root.eventDefinitions[ eventName ] || Ractive.eventDefinitions[ eventName ] ) ) {\r\n\t\t\tthis.custom = definition( this.node, getCustomHandler( eventName ) );\r\n\t\t} else {\r\n\t\t\tthis.node.addEventListener( eventName, genericHandler, false );\r\n\t\t}\r\n\t};\r\n\r\n\tMasterEventHandler.prototype = {\r\n\t\tadd: function ( proxy ) {\r\n\t\t\tthis.proxies[ this.proxies.length ] = new ProxyEvent( this.element, this.root, proxy, this.contextStack );\r\n\t\t},\r\n\r\n\t\t// TODO teardown when element torn down\r\n\t\tteardown: function () {\r\n\t\t\tvar i;\r\n\r\n\t\t\tif ( this.custom ) {\r\n\t\t\t\tthis.custom.teardown();\r\n\t\t\t} else {\r\n\t\t\t\tthis.node.removeEventListener( this.name, genericHandler, false );\r\n\t\t\t}\r\n\r\n\t\t\ti = this.proxies.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tthis.proxies[i].teardown();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tfire: function ( event ) {\r\n\t\t\tvar i = this.proxies.length;\r\n\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tthis.proxies[i].fire( event );\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tProxyEvent = function ( element, ractive, descriptor, contextStack ) {\r\n\t\tvar name;\r\n\r\n\t\tthis.root = ractive;\r\n\r\n\t\tname = descriptor.n || descriptor;\r\n\r\n\t\tif ( typeof name === 'string' ) {\r\n\t\t\tthis.n = name;\r\n\t\t} else {\r\n\t\t\tthis.n = new StringFragment({\r\n\t\t\t\tdescriptor:   descriptor.n,\r\n\t\t\t\troot:         this.root,\r\n\t\t\t\towner:        element,\r\n\t\t\t\tcontextStack: contextStack\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif ( descriptor.a ) {\r\n\t\t\tthis.a = descriptor.a;\r\n\t\t\tthis.fire = fireEventWithArgs;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif ( descriptor.d ) {\r\n\t\t\tthis.d = new StringFragment({\r\n\t\t\t\tdescriptor:   descriptor.d,\r\n\t\t\t\troot:         this.root,\r\n\t\t\t\towner:        element,\r\n\t\t\t\tcontextStack: contextStack\r\n\t\t\t});\r\n\t\t\tthis.fire = fireEventWithDynamicArgs;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.fire = firePlainEvent;\r\n\t};\r\n\r\n\tProxyEvent.prototype = {\r\n\t\tteardown: function () {\r\n\t\t\tif ( this.n.teardown) {\r\n\t\t\t\tthis.n.teardown();\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.d ) {\r\n\t\t\t\tthis.d.teardown();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tbubble: noop // TODO can we get rid of this?\r\n\t};\r\n\r\n\t// the ProxyEvent instance fire method could be any of these\r\n\tfirePlainEvent = function ( event ) {\r\n\t\tthis.root.fire( this.n.toString(), event );\r\n\t};\r\n\r\n\tfireEventWithArgs = function ( event ) {\r\n\t\tthis.root.fire( this.n.toString(), event, this.a );\r\n\t};\r\n\r\n\tfireEventWithDynamicArgs = function ( event ) {\r\n\t\tthis.root.fire( this.n.toString(), event, this.d.toJSON() );\r\n\t};\r\n\r\n\t// all native DOM events dealt with by Ractive share a single handler\r\n\tgenericHandler = function ( event ) {\r\n\t\tvar storage = this._ractive;\r\n\r\n\t\tstorage.events[ event.type ].fire({\r\n\t\t\tnode: this,\r\n\t\t\toriginal: event,\r\n\t\t\tindex: storage.index,\r\n\t\t\tkeypath: storage.keypath,\r\n\t\t\tcontext: storage.root.get( storage.keypath )\r\n\t\t});\r\n\t};\r\n\r\n\tcustomHandlers = {};\r\n\r\n\tgetCustomHandler = function ( eventName ) {\r\n\t\tif ( customHandlers[ eventName ] ) {\r\n\t\t\treturn customHandlers[ eventName ];\r\n\t\t}\r\n\r\n\t\treturn customHandlers[ eventName ] = function ( event ) {\r\n\t\t\tvar storage = event.node._ractive;\r\n\r\n\t\t\tevent.index = storage.index;\r\n\t\t\tevent.keypath = storage.keypath;\r\n\t\t\tevent.context = storage.root.get( storage.keypath );\r\n\r\n\t\t\tstorage.events[ eventName ].fire( event );\r\n\t\t};\r\n\t};\r\n\r\n}());\r\nappendElementChildren = function ( element, node, descriptor, docFrag ) {\r\n\tif ( typeof descriptor.f === 'string' && ( !node || ( !node.namespaceURI || node.namespaceURI === namespaces.html ) ) ) {\r\n\t\t// great! we can use innerHTML\r\n\t\telement.html = descriptor.f;\r\n\r\n\t\tif ( docFrag ) {\r\n\t\t\tnode.innerHTML = element.html;\r\n\t\t}\r\n\t}\r\n\r\n\telse {\r\n\t\t// once again, everyone has to suffer because of IE bloody 8\r\n\t\tif ( descriptor.e === 'style' && node.styleSheet !== undefined ) {\r\n\t\t\telement.fragment = new StringFragment({\r\n\t\t\t\tdescriptor:   descriptor.f,\r\n\t\t\t\troot:         element.root,\r\n\t\t\t\tcontextStack: element.parentFragment.contextStack,\r\n\t\t\t\towner:        element\r\n\t\t\t});\r\n\r\n\t\t\tif ( docFrag ) {\r\n\t\t\t\telement.bubble = function () {\r\n\t\t\t\t\tnode.styleSheet.cssText = element.fragment.toString();\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\telse {\r\n\t\t\telement.fragment = new DomFragment({\r\n\t\t\t\tdescriptor:   descriptor.f,\r\n\t\t\t\troot:         element.root,\r\n\t\t\t\tparentNode:   node,\r\n\t\t\t\tcontextStack: element.parentFragment.contextStack,\r\n\t\t\t\towner:        element\r\n\t\t\t});\r\n\r\n\t\t\tif ( docFrag ) {\r\n\t\t\t\tnode.appendChild( element.fragment.docFrag );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\nbindElement = function ( element, attributes ) {\r\n\telement.ractify();\r\n\r\n\t// an element can only have one two-way attribute\r\n\tswitch ( element.descriptor.e ) {\r\n\t\tcase 'select':\r\n\t\tcase 'textarea':\r\n\t\tif ( attributes.value ) {\r\n\t\t\tattributes.value.bind();\r\n\t\t}\r\n\t\treturn;\r\n\r\n\t\tcase 'input':\r\n\r\n\t\tif ( element.node.type === 'radio' || element.node.type === 'checkbox' ) {\r\n\t\t\t// we can either bind the name attribute, or the checked attribute - not both\r\n\t\t\tif ( attributes.name && attributes.name.bind() ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif ( attributes.checked && attributes.checked.bind() ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( attributes.value && attributes.value.bind() ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n};\r\ncreateElementAttributes = function ( element, attributes ) {\r\n\tvar attrName, attrValue, attr;\r\n\r\n\telement.attributes = [];\r\n\r\n\tfor ( attrName in attributes ) {\r\n\t\tif ( hasOwn.call( attributes, attrName ) ) {\r\n\t\t\tattrValue = attributes[ attrName ];\r\n\r\n\t\t\tattr = new DomAttribute({\r\n\t\t\t\telement:      element,\r\n\t\t\t\tname:         attrName,\r\n\t\t\t\tvalue:        attrValue,\r\n\t\t\t\troot:         element.root,\r\n\t\t\t\tparentNode:   element.node,\r\n\t\t\t\tcontextStack: element.parentFragment.contextStack\r\n\t\t\t});\r\n\r\n\t\t\telement.attributes[ element.attributes.length ] = attr;\r\n\r\n\t\t\t// name, value and checked attributes are potentially bindable\r\n\t\t\tif ( attrName === 'value' || attrName === 'name' || attrName === 'checked' ) {\r\n\t\t\t\telement.attributes[ attrName ] = attr;\r\n\t\t\t}\r\n\r\n\t\t\t// The name attribute is a special case - it is the only two-way attribute that updates\r\n\t\t\t// the viewmodel based on the value of another attribute. For that reason it must wait\r\n\t\t\t// until the node has been initialised, and the viewmodel has had its first two-way\r\n\t\t\t// update, before updating itself (otherwise it may disable a checkbox or radio that\r\n\t\t\t// was enabled in the template)\r\n\t\t\tif ( attrName !== 'name' ) {\r\n\t\t\t\tattr.update();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn element.attributes;\r\n};\r\ngetElementNamespace = function ( descriptor, parentNode ) {\r\n\t// if the element has an xmlns attribute, use that\r\n\tif ( descriptor.a && descriptor.a.xmlns ) {\r\n\t\treturn descriptor.a.xmlns;\r\n\t}\r\n\r\n\t// otherwise, use the svg namespace if this is an svg element, or inherit namespace from parent\r\n\treturn ( descriptor.e.toLowerCase() === 'svg' ? namespaces.svg : parentNode.namespaceURI );\r\n};\r\nexecuteTransition = function ( descriptor, root, owner, contextStack, isIntro ) {\r\n\tvar transitionName, transitionParams, fragment, transitionManager, transition;\r\n\r\n\tif ( !root.transitionsEnabled ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tif ( typeof descriptor === 'string' ) {\r\n\t\ttransitionName = descriptor;\r\n\t} else {\r\n\t\ttransitionName = descriptor.n;\r\n\r\n\t\tif ( descriptor.a ) {\r\n\t\t\ttransitionParams = descriptor.a;\r\n\t\t} else if ( descriptor.d ) {\r\n\t\t\tfragment = new StringFragment({\r\n\t\t\t\tdescriptor:   descriptor.d,\r\n\t\t\t\troot:         root,\r\n\t\t\t\towner:        owner,\r\n\t\t\t\tcontextStack: owner.parentFragment.contextStack\r\n\t\t\t});\r\n\r\n\t\t\ttransitionParams = fragment.toJSON();\r\n\t\t\tfragment.teardown();\r\n\t\t}\r\n\t}\r\n\r\n\ttransition = root.transitions[ transitionName ] || Ractive.transitions[ transitionName ];\r\n\r\n\tif ( transition ) {\r\n\t\ttransitionManager = root._transitionManager;\r\n\r\n\t\ttransitionManager.push( owner.node );\r\n\t\ttransition.call( root, owner.node, function () {\r\n\t\t\ttransitionManager.pop( owner.node );\r\n\t\t}, transitionParams, isIntro );\r\n\t}\r\n};\r\ngetComponentConstructor = function ( root, name ) {\r\n\t// TODO... write this properly!\r\n\treturn root.components[ name ];\r\n};\r\n(function () {\r\n\r\n\tvar elementCache = {};\r\n\r\n\tinsertHtml = function ( html, tagName, docFrag ) {\r\n\t\tvar container, nodes = [];\r\n\r\n\t\tcontainer = elementCache[ tagName ] || ( elementCache[ tagName ] = doc.createElement( tagName ) );\r\n\t\tcontainer.innerHTML = html;\r\n\r\n\t\twhile ( container.firstChild ) {\r\n\t\t\tnodes[ nodes.length ] = container.firstChild;\r\n\t\t\tdocFrag.appendChild( container.firstChild );\r\n\t\t}\r\n\r\n\t\treturn nodes;\r\n\t};\r\n\r\n}());\r\n(function () {\r\n\r\n\tvar reassignFragment, reassignElement, reassignMustache;\r\n\r\n\treassignFragments = function ( root, section, start, end, by ) {\r\n\t\tvar i, fragment, indexRef, oldIndex, newIndex, oldKeypath, newKeypath;\r\n\r\n\t\tindexRef = section.descriptor.i;\r\n\r\n\t\tfor ( i=start; i<end; i+=1 ) {\r\n\t\t\tfragment = section.fragments[i];\r\n\r\n\t\t\toldIndex = i - by;\r\n\t\t\tnewIndex = i;\r\n\r\n\t\t\toldKeypath = section.keypath + '.' + ( i - by );\r\n\t\t\tnewKeypath = section.keypath + '.' + i;\r\n\r\n\t\t\t// change the fragment index\r\n\t\t\tfragment.index += by;\r\n\r\n\t\t\treassignFragment( fragment, indexRef, oldIndex, newIndex, by, oldKeypath, newKeypath );\r\n\t\t}\r\n\r\n\t\tprocessDeferredUpdates( root );\r\n\t};\r\n\r\n\treassignFragment = function ( fragment, indexRef, oldIndex, newIndex, by, oldKeypath, newKeypath ) {\r\n\t\tvar i, item, context;\r\n\r\n\t\tif ( fragment.indexRefs && fragment.indexRefs[ indexRef ] !== undefined ) {\r\n\t\t\tfragment.indexRefs[ indexRef ] = newIndex;\r\n\t\t}\r\n\r\n\t\t// fix context stack\r\n\t\ti = fragment.contextStack.length;\r\n\t\twhile ( i-- ) {\r\n\t\t\tcontext = fragment.contextStack[i];\r\n\t\t\tif ( context.substr( 0, oldKeypath.length ) === oldKeypath ) {\r\n\t\t\t\tfragment.contextStack[i] = context.replace( oldKeypath, newKeypath );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\ti = fragment.items.length;\r\n\t\twhile ( i-- ) {\r\n\t\t\titem = fragment.items[i];\r\n\r\n\t\t\tswitch ( item.type ) {\r\n\t\t\t\tcase ELEMENT:\r\n\t\t\t\treassignElement( item, indexRef, oldIndex, newIndex, by, oldKeypath, newKeypath );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase PARTIAL:\r\n\t\t\t\treassignFragment( item.fragment, indexRef, oldIndex, newIndex, by, oldKeypath, newKeypath );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase SECTION:\r\n\t\t\t\tcase INTERPOLATOR:\r\n\t\t\t\tcase TRIPLE:\r\n\t\t\t\treassignMustache( item, indexRef, oldIndex, newIndex, by, oldKeypath, newKeypath );\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\treassignElement = function ( element, indexRef, oldIndex, newIndex, by, oldKeypath, newKeypath ) {\r\n\t\tvar i, attribute, storage, masterEventName, proxies, proxy;\r\n\r\n\t\ti = element.attributes.length;\r\n\t\twhile ( i-- ) {\r\n\t\t\tattribute = element.attributes[i];\r\n\r\n\t\t\tif ( attribute.fragment ) {\r\n\t\t\t\treassignFragment( attribute.fragment, indexRef, oldIndex, newIndex, by, oldKeypath, newKeypath );\r\n\r\n\t\t\t\tif ( attribute.twoway ) {\r\n\t\t\t\t\tattribute.updateBindings();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( storage = element.node._ractive ) {\r\n\t\t\tif ( storage.keypath.substr( 0, oldKeypath.length ) === oldKeypath ) {\r\n\t\t\t\tstorage.keypath = storage.keypath.replace( oldKeypath, newKeypath );\r\n\t\t\t}\r\n\r\n\t\t\tif ( indexRef !== undefined ) {\r\n\t\t\t\tstorage.index[ indexRef ] = newIndex;\r\n\t\t\t}\r\n\r\n\t\t\tfor ( masterEventName in storage.events ) {\r\n\t\t\t\tproxies = storage.events[ masterEventName ].proxies;\r\n\t\t\t\ti = proxies.length;\r\n\r\n\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\tproxy = proxies[i];\r\n\r\n\t\t\t\t\tif ( typeof proxy.n === 'object' ) {\r\n\t\t\t\t\t\treassignFragment( proxy.a, indexRef, oldIndex, newIndex, by, oldKeypath, newKeypath );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( proxy.d ) {\r\n\t\t\t\t\t\treassignFragment( proxy.d, indexRef, oldIndex, newIndex, by, oldKeypath, newKeypath );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( storage.binding ) {\r\n\t\t\t\tif ( storage.binding.keypath.substr( 0, oldKeypath.length ) === oldKeypath ) {\r\n\t\t\t\t\tstorage.binding.keypath = storage.binding.keypath.replace( oldKeypath, newKeypath );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// reassign children\r\n\t\tif ( element.fragment ) {\r\n\t\t\treassignFragment( element.fragment, indexRef, oldIndex, newIndex, by, oldKeypath, newKeypath );\r\n\t\t}\r\n\t};\r\n\r\n\treassignMustache = function ( mustache, indexRef, oldIndex, newIndex, by, oldKeypath, newKeypath ) {\r\n\t\tvar i;\r\n\r\n\t\t// expression mustache?\r\n\t\tif ( mustache.descriptor.x ) {\r\n\t\t\tif ( mustache.keypath ) {\r\n\t\t\t\tunregisterDependant( mustache );\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif ( mustache.expressionResolver ) {\r\n\t\t\t\tmustache.expressionResolver.teardown();\r\n\t\t\t}\r\n\r\n\t\t\tmustache.expressionResolver = new ExpressionResolver( mustache );\r\n\t\t}\r\n\r\n\t\t// normal keypath mustache?\r\n\t\tif ( mustache.keypath ) {\r\n\t\t\tif ( mustache.keypath.substr( 0, oldKeypath.length ) === oldKeypath ) {\r\n\t\t\t\tmustache.resolve( mustache.keypath.replace( oldKeypath, newKeypath ) );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// index ref mustache?\r\n\t\telse if ( mustache.indexRef === indexRef ) {\r\n\t\t\tmustache.value = newIndex;\r\n\t\t\tmustache.render( newIndex );\r\n\t\t}\r\n\r\n\t\t// otherwise, it's an unresolved reference. the context stack has been updated\r\n\t\t// so it will take care of itself\r\n\r\n\t\t// if it's a section mustache, we need to go through any children\r\n\t\tif ( mustache.fragments ) {\r\n\t\t\ti = mustache.fragments.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\treassignFragment( mustache.fragments[i], indexRef, oldIndex, newIndex, by, oldKeypath, newKeypath );\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n}());\r\n(function ( cache ) {\r\n\r\n\tvar Reference, SoftReference, getFunctionFromString, thisPattern, wrapFunction;\r\n\r\n\tEvaluator = function ( root, keypath, functionStr, args, priority ) {\r\n\t\tvar i, arg;\r\n\r\n\t\tthis.root = root;\r\n\t\tthis.keypath = keypath;\r\n\t\tthis.priority = priority;\r\n\r\n\t\tthis.dependants = 0;\r\n\r\n\t\tthis.fn = getFunctionFromString( functionStr, args.length );\r\n\t\tthis.values = [];\r\n\t\tthis.refs = [];\r\n\r\n\t\ti = args.length;\r\n\t\twhile ( i-- ) {\r\n\t\t\tif ( arg = args[i] ) {\r\n\t\t\t\tif ( arg[0] ) {\r\n\t\t\t\t\t// this is an index ref... we don't need to register a dependant\r\n\t\t\t\t\tthis.values[i] = arg[1];\r\n\t\t\t\t}\r\n\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.refs[ this.refs.length ] = new Reference( root, arg[1], this, i, priority );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\telse {\r\n\t\t\t\tthis.values[i] = undefined;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.selfUpdating = ( this.refs.length <= 1 );\r\n\t};\r\n\r\n\tEvaluator.prototype = {\r\n\t\twake: function () {\r\n\t\t\tthis.awake = true;\r\n\t\t\tthis.update();\r\n\t\t},\r\n\r\n\t\tsleep: function () {\r\n\t\t\tthis.awake = false;\r\n\t\t},\r\n\r\n\t\tbubble: function () {\r\n\t\t\tif ( !this.awake ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// If we only have one reference, we can update immediately...\r\n\t\t\tif ( this.selfUpdating ) {\r\n\t\t\t\tthis.update();\r\n\t\t\t}\r\n\r\n\t\t\t// ...otherwise we want to register it as a deferred item, to be\r\n\t\t\t// updated once all the information is in, to prevent unnecessary\r\n\t\t\t// cascading. Only if we're already resolved, obviously\r\n\t\t\telse if ( !this.deferred ) {\r\n\t\t\t\tthis.root._defEvals[ this.root._defEvals.length ] = this;\r\n\t\t\t\tthis.deferred = true;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tupdate: function () {\r\n\t\t\tvar value;\r\n\r\n\t\t\t// prevent infinite loops\r\n\t\t\tif ( this.evaluating ) {\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\r\n\t\t\tthis.evaluating = true;\r\n\t\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\tvalue = this.fn.apply( null, this.values );\r\n\t\t\t} catch ( err ) {\r\n\t\t\t\tif ( this.root.debug ) {\r\n\t\t\t\t\tthrow err;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvalue = undefined;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( !isEqual( value, this.value ) ) {\r\n\t\t\t\tclearCache( this.root, this.keypath );\r\n\t\t\t\tthis.root._cache[ this.keypath ] = value;\r\n\t\t\t\tnotifyDependants( this.root, this.keypath );\r\n\r\n\t\t\t\tthis.value = value;\r\n\t\t\t}\r\n\r\n\t\t\tthis.evaluating = false;\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t// TODO should evaluators ever get torn down? At present, they don't...\r\n\t\tteardown: function () {\r\n\t\t\twhile ( this.refs.length ) {\r\n\t\t\t\tthis.refs.pop().teardown();\r\n\t\t\t}\r\n\r\n\t\t\tclearCache( this.root, this.keypath );\r\n\t\t\tthis.root._evaluators[ this.keypath ] = null;\r\n\t\t},\r\n\r\n\t\t// This method forces the evaluator to sync with the current model\r\n\t\t// in the case of a smart update\r\n\t\trefresh: function () {\r\n\t\t\tif ( !this.selfUpdating ) {\r\n\t\t\t\tthis.deferred = true;\r\n\t\t\t}\r\n\r\n\t\t\tvar i = this.refs.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tthis.refs[i].update();\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.deferred ) {\r\n\t\t\t\tthis.update();\r\n\t\t\t\tthis.deferred = false;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tupdateSoftDependencies: function ( softDeps ) {\r\n\t\t\tvar i, keypath, ref;\r\n\r\n\t\t\tif ( !this.softRefs ) {\r\n\t\t\t\tthis.softRefs = [];\r\n\t\t\t}\r\n\r\n\t\t\t// teardown any references that are no longer relevant\r\n\t\t\ti = this.softRefs.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tref = this.softRefs[i];\r\n\t\t\t\tif ( !softDeps[ ref.keypath ] ) {\r\n\t\t\t\t\tthis.softRefs.splice( i, 1 );\r\n\t\t\t\t\tthis.softRefs[ ref.keypath ] = false;\r\n\t\t\t\t\tref.teardown();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// add references for any new soft dependencies\r\n\t\t\ti = softDeps.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tkeypath = softDeps[i];\r\n\t\t\t\tif ( !this.softRefs[ keypath ] ) {\r\n\t\t\t\t\tref = new SoftReference( this.root, keypath, this );\r\n\t\t\t\t\tthis.softRefs[ this.softRefs.length ] = ref;\r\n\t\t\t\t\tthis.softRefs[ keypath ] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.selfUpdating = ( this.refs.length + this.softRefs.length <= 1 );\r\n\t\t}\r\n\t};\r\n\r\n\r\n\tReference = function ( root, keypath, evaluator, argNum, priority ) {\r\n\t\tvar value;\r\n\r\n\t\tthis.evaluator = evaluator;\r\n\t\tthis.keypath = keypath;\r\n\t\tthis.root = root;\r\n\t\tthis.argNum = argNum;\r\n\t\tthis.type = REFERENCE;\r\n\t\tthis.priority = priority;\r\n\r\n\t\tvalue = root.get( keypath );\r\n\r\n\t\tif ( typeof value === 'function' ) {\r\n\t\t\tvalue = value._wrapped || wrapFunction( value, root, evaluator );\r\n\t\t}\r\n\r\n\t\tthis.value = evaluator.values[ argNum ] = value;\r\n\r\n\t\tregisterDependant( this );\r\n\t};\r\n\r\n\tReference.prototype = {\r\n\t\tupdate: function () {\r\n\t\t\tvar value = this.root.get( this.keypath );\r\n\r\n\t\t\tif ( typeof value === 'function' && !value._nowrap ) {\r\n\t\t\t\tvalue = value[ '_' + this.root._guid ] || wrapFunction( value, this.root, this.evaluator );\r\n\t\t\t}\r\n\r\n\t\t\tif ( !isEqual( value, this.value ) ) {\r\n\t\t\t\tthis.evaluator.values[ this.argNum ] = value;\r\n\t\t\t\tthis.evaluator.bubble();\r\n\r\n\t\t\t\tthis.value = value;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tteardown: function () {\r\n\t\t\tunregisterDependant( this );\r\n\t\t}\r\n\t};\r\n\r\n\tSoftReference = function ( root, keypath, evaluator ) {\r\n\t\tthis.root = root;\r\n\t\tthis.keypath = keypath;\r\n\t\tthis.priority = evaluator.priority;\r\n\r\n\t\tthis.evaluator = evaluator;\r\n\r\n\t\tregisterDependant( this );\r\n\t};\r\n\r\n\tSoftReference.prototype = {\r\n\t\tupdate: function () {\r\n\t\t\tvar value = this.root.get( this.keypath );\r\n\r\n\t\t\tif ( !isEqual( value, this.value ) ) {\r\n\t\t\t\tthis.evaluator.bubble();\r\n\t\t\t\tthis.value = value;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tteardown: function () {\r\n\t\t\tunregisterDependant( this );\r\n\t\t}\r\n\t};\r\n\r\n\r\n\tgetFunctionFromString = function ( str, i ) {\r\n\t\tvar fn, args;\r\n\r\n\t\tstr = str.replace( /\\$\\{([0-9]+)\\}/g, '_$1' );\r\n\r\n\t\tif ( cache[ str ] ) {\r\n\t\t\treturn cache[ str ];\r\n\t\t}\r\n\r\n\t\targs = [];\r\n\t\twhile ( i-- ) {\r\n\t\t\targs[i] = '_' + i;\r\n\t\t}\r\n\r\n\t\tfn = new Function( args.join( ',' ), 'return(' + str + ')' );\r\n\r\n\t\tcache[ str ] = fn;\r\n\t\treturn fn;\r\n\t};\r\n\r\n\tthisPattern = /this/;\r\n\r\n\twrapFunction = function ( fn, ractive, evaluator ) {\r\n\t\tvar prop;\r\n\r\n\t\t// if the function doesn't refer to `this`, we don't need\r\n\t\t// to set the context\r\n\t\tif ( !thisPattern.test( fn.toString() ) ) {\r\n\t\t\tdefineProperty( fn, '_nowrap', { // no point doing this every time\r\n\t\t\t\tvalue: true\r\n\t\t\t});\r\n\t\t\treturn fn;\r\n\t\t}\r\n\r\n\t\t// otherwise, we do\r\n\t\tdefineProperty( fn, '_' + ractive._guid, {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tvar originalGet, result, softDependencies;\r\n\r\n\t\t\t\toriginalGet = ractive.get;\r\n\t\t\t\tractive.get = function ( keypath ) {\r\n\t\t\t\t\tif ( !softDependencies ) {\r\n\t\t\t\t\t\tsoftDependencies = [];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( !softDependencies[ keypath ] ) {\r\n\t\t\t\t\t\tsoftDependencies[ softDependencies.length ] = keypath;\r\n\t\t\t\t\t\tsoftDependencies[ keypath ] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn originalGet.call( ractive, keypath );\r\n\t\t\t\t};\r\n\t\t\t\t\r\n\t\t\t\tresult = fn.apply( ractive, arguments );\r\n\t\t\t\t\r\n\t\t\t\tif ( softDependencies ) {\r\n\t\t\t\t\tevaluator.updateSoftDependencies( softDependencies );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// reset\r\n\t\t\t\tractive.get = originalGet;\r\n\t\t\t\t\r\n\t\t\t\treturn result;\r\n\t\t\t},\r\n\t\t\twritable: true\r\n\t\t});\r\n\r\n\t\tfor ( prop in fn ) {\r\n\t\t\tif ( hasOwn.call( fn, prop ) ) {\r\n\t\t\t\tfn[ '_' + ractive._guid ][ prop ] = fn[ prop ];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn fn[ '_' + ractive._guid ];\r\n\t};\r\n\r\n}({}));\r\n(function () {\r\n\r\n\tvar ReferenceScout, getKeypath;\r\n\r\n\tExpressionResolver = function ( mustache ) {\r\n\r\n\t\tvar expression, i, len, ref, indexRefs;\r\n\r\n\t\tthis.root = mustache.root;\r\n\t\tthis.mustache = mustache;\r\n\t\tthis.args = [];\r\n\t\tthis.scouts = [];\r\n\r\n\t\texpression = mustache.descriptor.x;\r\n\t\tindexRefs = mustache.parentFragment.indexRefs;\r\n\r\n\t\tthis.str = expression.s;\r\n\r\n\t\t// send out scouts for each reference\r\n\t\tlen = this.unresolved = this.args.length = ( expression.r ? expression.r.length : 0 );\r\n\r\n\t\tif ( !len ) {\r\n\t\t\tthis.resolved = this.ready = true;\r\n\t\t\tthis.bubble(); // some expressions don't have references. edge case, but, yeah.\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfor ( i=0; i<len; i+=1 ) {\r\n\t\t\tref = expression.r[i];\r\n\t\t\t\r\n\t\t\t// is this an index ref?\r\n\t\t\tif ( indexRefs && indexRefs[ ref ] !== undefined ) {\r\n\t\t\t\tthis.resolveRef( i, true, indexRefs[ ref ] );\r\n\t\t\t}\r\n\r\n\t\t\telse {\r\n\t\t\t\tthis.scouts[ this.scouts.length ] = new ReferenceScout( this, ref, mustache.contextStack, i );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.ready = true;\r\n\t\tthis.bubble();\r\n\t};\r\n\r\n\tExpressionResolver.prototype = {\r\n\t\tbubble: function () {\r\n\t\t\tif ( !this.ready ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.keypath = getKeypath( this.str, this.args );\r\n\t\t\tthis.createEvaluator();\r\n\r\n\t\t\tthis.mustache.resolve( this.keypath );\r\n\t\t},\r\n\r\n\t\tteardown: function () {\r\n\t\t\twhile ( this.scouts.length ) {\r\n\t\t\t\tthis.scouts.pop().teardown();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tresolveRef: function ( argNum, isIndexRef, value ) {\r\n\t\t\tthis.args[ argNum ] = [ isIndexRef, value ];\r\n\t\t\tthis.bubble();\r\n\r\n\t\t\t// when all references have been resolved, we can flag the entire expression\r\n\t\t\t// as having been resolved\r\n\t\t\tthis.resolved = !( --this.unresolved );\r\n\t\t},\r\n\r\n\t\tcreateEvaluator: function () {\r\n\t\t\t// only if it doesn't exist yet!\r\n\t\t\tif ( !this.root._evaluators[ this.keypath ] ) {\r\n\t\t\t\tthis.root._evaluators[ this.keypath ] = new Evaluator( this.root, this.keypath, this.str, this.args, this.mustache.priority );\r\n\t\t\t}\r\n\r\n\t\t\telse {\r\n\t\t\t\t// we need to trigger a refresh of the evaluator, since it\r\n\t\t\t\t// will have become de-synced from the model if we're in a\r\n\t\t\t\t// reassignment cycle\r\n\t\t\t\tthis.root._evaluators[ this.keypath ].refresh();\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\r\n\tReferenceScout = function ( resolver, ref, contextStack, argNum ) {\r\n\t\tvar keypath, root;\r\n\r\n\t\troot = this.root = resolver.root;\r\n\r\n\t\tkeypath = resolveRef( root, ref, contextStack );\r\n\t\tif ( keypath ) {\r\n\t\t\tresolver.resolveRef( argNum, false, keypath );\r\n\t\t} else {\r\n\t\t\tthis.ref = ref;\r\n\t\t\tthis.argNum = argNum;\r\n\t\t\tthis.resolver = resolver;\r\n\t\t\tthis.contextStack = contextStack;\r\n\r\n\t\t\troot._pendingResolution[ root._pendingResolution.length ] = this;\r\n\t\t}\r\n\t};\r\n\r\n\tReferenceScout.prototype = {\r\n\t\tresolve: function ( keypath ) {\r\n\t\t\tthis.keypath = keypath;\r\n\t\t\tthis.resolver.resolveRef( this.argNum, false, keypath );\r\n\t\t},\r\n\r\n\t\tteardown: function () {\r\n\t\t\t// if we haven't found a keypath yet, we can\r\n\t\t\t// stop the search now\r\n\t\t\tif ( !this.keypath ) {\r\n\t\t\t\tteardown( this );\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tgetKeypath = function ( str, args ) {\r\n\t\tvar unique;\r\n\r\n\t\t// get string that is unique to this expression\r\n\t\tunique = str.replace( /\\$\\{([0-9]+)\\}/g, function ( match, $1 ) {\r\n\t\t\treturn args[ $1 ] ? args[ $1 ][1] : 'undefined';\r\n\t\t});\r\n\r\n\t\t// then sanitize by removing any periods or square brackets. Otherwise\r\n\t\t// we can't split the keypath into keys!\r\n\t\treturn '(' + unique.replace( /[\\.\\[\\]]/g, '-' ) + ')';\r\n\t};\r\n\r\n}());\r\n(function () {\r\n\r\n\tvar getPartialFromRegistry, unpack;\r\n\r\n\tgetPartialDescriptor = function ( root, name ) {\r\n\t\tvar el, partial;\r\n\r\n\t\t// If the partial was specified on this instance, great\r\n\t\tif ( partial = getPartialFromRegistry( root, name ) ) {\r\n\t\t\treturn partial;\r\n\t\t}\r\n\r\n\t\t// If not, is it a global partial?\r\n\t\tif ( partial = getPartialFromRegistry( Ractive, name ) ) {\r\n\t\t\treturn partial;\r\n\t\t}\r\n\r\n\t\t// Does it exist on the page as a script tag?\r\n\t\tif ( doc ) {\r\n\t\t\tel = doc.getElementById( name );\r\n\t\t\tif ( el && el.tagName === 'SCRIPT' ) {\r\n\t\t\t\tif ( !Ractive.parse ) {\r\n\t\t\t\t\tthrow new Error( missingParser );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tRactive.partials[ name ] = Ractive.parse( el.innerHTML );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpartial = Ractive.partials[ name ];\r\n\r\n\t\t// No match? Return an empty array\r\n\t\tif ( !partial ) {\r\n\t\t\tif ( root.debug && console && console.warn ) {\r\n\t\t\t\tconsole.warn( 'Could not find descriptor for partial \"' + name + '\"' );\r\n\t\t\t}\r\n\r\n\t\t\treturn [];\r\n\t\t}\r\n\r\n\t\treturn unpack( partial );\r\n\t};\r\n\r\n\tgetPartialFromRegistry = function ( registry, name ) {\r\n\t\tvar partial, key;\r\n\r\n\t\tif ( registry.partials[ name ] ) {\r\n\t\t\t\r\n\t\t\t// If this was added manually to the registry, but hasn't been parsed,\r\n\t\t\t// parse it now\r\n\t\t\tif ( typeof registry.partials[ name ] === 'string' ) {\r\n\t\t\t\tif ( !Ractive.parse ) {\r\n\t\t\t\t\tthrow new Error( missingParser );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpartial = Ractive.parse( registry.partials[ name ], registry.parseOptions );\r\n\r\n\t\t\t\tif ( isObject( partial ) ) {\r\n\t\t\t\t\tregistry.partials[ name ] = partial.main;\r\n\r\n\t\t\t\t\tfor ( key in partial.partials ) {\r\n\t\t\t\t\t\tif ( partial.partials.hasOwnProperty( key ) ) {\r\n\t\t\t\t\t\t\tregistry.partials[ key ] = partial.partials[ key ];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tregistry.partials[ name ] = partial;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn unpack( registry.partials[ name ] );\r\n\t\t}\r\n\t};\r\n\r\n\tunpack = function ( partial ) {\r\n\t\t// Unpack string, if necessary\r\n\t\tif ( partial.length === 1 && typeof partial[0] === 'string' ) {\r\n\t\t\treturn partial[0];\r\n\t\t}\r\n\r\n\t\treturn partial;\r\n\t};\r\n\r\n}());\r\ninitFragment = function ( fragment, options ) {\r\n\r\n\tvar numItems, i, parentFragment, parentRefs, ref;\r\n\r\n\t// The item that owns this fragment - an element, section, partial, or attribute\r\n\tfragment.owner = options.owner;\r\n\tparentFragment = fragment.owner.parentFragment;\r\n\r\n\t// inherited properties\r\n\tfragment.root = options.root;\r\n\tfragment.parentNode = options.parentNode;\r\n\tfragment.contextStack = options.contextStack || [];\r\n\r\n\t// If parent item is a section, this may not be the only fragment\r\n\t// that belongs to it - we need to make a note of the index\r\n\tif ( fragment.owner.type === SECTION ) {\r\n\t\tfragment.index = options.index;\r\n\t}\r\n\r\n\t// index references (the 'i' in {{#section:i}}<!-- -->{{/section}}) need to cascade\r\n\t// down the tree\r\n\tif ( parentFragment ) {\r\n\t\tparentRefs = parentFragment.indexRefs;\r\n\r\n\t\tif ( parentRefs ) {\r\n\t\t\tfragment.indexRefs = createFromNull(); // avoids need for hasOwnProperty\r\n\r\n\t\t\tfor ( ref in parentRefs ) {\r\n\t\t\t\tfragment.indexRefs[ ref ] = parentRefs[ ref ];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// inherit priority\r\n\tfragment.priority = ( parentFragment ? parentFragment.priority + 1 : 1 );\r\n\r\n\tif ( options.indexRef ) {\r\n\t\tif ( !fragment.indexRefs ) {\r\n\t\t\tfragment.indexRefs = {};\r\n\t\t}\r\n\r\n\t\tfragment.indexRefs[ options.indexRef ] = options.index;\r\n\t}\r\n\r\n\t// Time to create this fragment's child items;\r\n\tfragment.items = [];\r\n\r\n\tnumItems = ( options.descriptor ? options.descriptor.length : 0 );\r\n\tfor ( i=0; i<numItems; i+=1 ) {\r\n\t\tfragment.items[ fragment.items.length ] = fragment.createItem({\r\n\t\t\tparentFragment: fragment,\r\n\t\t\tdescriptor: options.descriptor[i],\r\n\t\t\tindex: i\r\n\t\t});\r\n\t}\r\n\r\n};\r\nisStringFragmentSimple = function ( fragment ) {\r\n\tvar i, item, containsInterpolator;\r\n\r\n\ti = fragment.items.length;\r\n\twhile ( i-- ) {\r\n\t\titem = fragment.items[i];\r\n\t\tif ( item.type === TEXT ) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t// we can only have one interpolator and still be self-updating\r\n\t\tif ( item.type === INTERPOLATOR ) {\r\n\t\t\tif ( containsInterpolator ) {\r\n\t\t\t\treturn false;\r\n\t\t\t} else {\r\n\t\t\t\tcontainsInterpolator = true;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// anything that isn't text or an interpolator (i.e. a section)\r\n\t\t// and we can't self-update\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n};\r\ninitMustache = function ( mustache, options ) {\r\n\r\n\tvar keypath, indexRef, parentFragment;\r\n\r\n\tparentFragment = mustache.parentFragment = options.parentFragment;\r\n\r\n\tmustache.root           = parentFragment.root;\r\n\tmustache.contextStack   = parentFragment.contextStack;\r\n\t\r\n\tmustache.descriptor     = options.descriptor;\r\n\tmustache.index          = options.index || 0;\r\n\tmustache.priority       = parentFragment.priority;\r\n\r\n\t// DOM only\r\n\tif ( parentFragment.parentNode ) {\r\n\t\tmustache.parentNode = parentFragment.parentNode;\r\n\t}\r\n\r\n\tmustache.type = options.descriptor.t;\r\n\r\n\r\n\t// if this is a simple mustache, with a reference, we just need to resolve\r\n\t// the reference to a keypath\r\n\tif ( options.descriptor.r ) {\r\n\t\tif ( parentFragment.indexRefs && parentFragment.indexRefs[ options.descriptor.r ] !== undefined ) {\r\n\t\t\tindexRef = parentFragment.indexRefs[ options.descriptor.r ];\r\n\r\n\t\t\tmustache.indexRef = options.descriptor.r;\r\n\t\t\tmustache.value = indexRef;\r\n\t\t\tmustache.render( mustache.value );\r\n\t\t}\r\n\r\n\t\telse {\r\n\t\t\tkeypath = resolveRef( mustache.root, options.descriptor.r, mustache.contextStack );\r\n\t\t\tif ( keypath ) {\r\n\t\t\t\tmustache.resolve( keypath );\r\n\t\t\t} else {\r\n\t\t\t\tmustache.ref = options.descriptor.r;\r\n\t\t\t\tmustache.root._pendingResolution[ mustache.root._pendingResolution.length ] = mustache;\r\n\r\n\t\t\t\t// inverted section? initialise\r\n\t\t\t\tif ( mustache.descriptor.n ) {\r\n\t\t\t\t\tmustache.render( false );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// if it's an expression, we have a bit more work to do\r\n\tif ( options.descriptor.x ) {\r\n\t\tmustache.expressionResolver = new ExpressionResolver( mustache );\r\n\t}\r\n\r\n};\r\n\r\n\r\n// methods to add to individual mustache prototypes\r\nupdateMustache = function () {\r\n\tvar value = this.root.get( this.keypath, true );\r\n\r\n\tif ( !isEqual( value, this.value ) ) {\r\n\t\tthis.render( value );\r\n\t\tthis.value = value;\r\n\t}\r\n};\r\n\r\nresolveMustache = function ( keypath ) {\r\n\t// if we resolved previously, we need to unregister\r\n\tif ( this.resolved ) {\r\n\t\tunregisterDependant( this );\r\n\t}\r\n\r\n\tthis.keypath = keypath;\r\n\tregisterDependant( this );\r\n\t\r\n\tthis.update();\r\n\r\n\t// TODO is there any need for this?\r\n\tif ( this.expressionResolver && this.expressionResolver.resolved ) {\r\n\t\tthis.expressionResolver = null;\r\n\t}\r\n\r\n\tthis.resolved = true;\r\n};\r\n(function () {\r\n\r\n\tvar updateListSection, updateListObjectSection, updateContextSection, updateConditionalSection;\r\n\r\n\tupdateSection = function ( section, value ) {\r\n\t\tvar fragmentOptions;\r\n\r\n\t\tfragmentOptions = {\r\n\t\t\tdescriptor: section.descriptor.f,\r\n\t\t\troot:       section.root,\r\n\t\t\tparentNode: section.parentNode,\r\n\t\t\towner:      section\r\n\t\t};\r\n\r\n\t\t// if section is inverted, only check for truthiness/falsiness\r\n\t\tif ( section.descriptor.n ) {\r\n\t\t\tupdateConditionalSection( section, value, true, fragmentOptions );\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// otherwise we need to work out what sort of section we're dealing with\r\n\r\n\t\t// if value is an array, or an object with an index reference, iterate through\r\n\t\tif ( isArray( value ) ) {\r\n\t\t\tupdateListSection( section, value, fragmentOptions );\r\n\t\t}\r\n\r\n\r\n\t\t// if value is a hash...\r\n\t\telse if ( isObject( value ) ) {\r\n\t\t\tif ( section.descriptor.i ) {\r\n\t\t\t\tupdateListObjectSection( section, value, fragmentOptions );\r\n\t\t\t} else {\r\n\t\t\t\tupdateContextSection( section, fragmentOptions );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\t// otherwise render if value is truthy, unrender if falsy\r\n\t\telse {\r\n\t\t\tupdateConditionalSection( section, value, false, fragmentOptions );\r\n\t\t}\r\n\t};\r\n\r\n\tupdateListSection = function ( section, value, fragmentOptions ) {\r\n\t\tvar i, length, fragmentsToRemove;\r\n\r\n\t\tlength = value.length;\r\n\r\n\t\t// if the array is shorter than it was previously, remove items\r\n\t\tif ( length < section.length ) {\r\n\t\t\tfragmentsToRemove = section.fragments.splice( length, section.length - length );\r\n\r\n\t\t\twhile ( fragmentsToRemove.length ) {\r\n\t\t\t\tfragmentsToRemove.pop().teardown( true );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// otherwise...\r\n\t\telse {\r\n\r\n\t\t\tif ( length > section.length ) {\r\n\t\t\t\t// add any new ones\r\n\t\t\t\tfor ( i=section.length; i<length; i+=1 ) {\r\n\t\t\t\t\t// append list item to context stack\r\n\t\t\t\t\tfragmentOptions.contextStack = section.contextStack.concat( section.keypath + '.' + i );\r\n\t\t\t\t\tfragmentOptions.index = i;\r\n\r\n\t\t\t\t\tif ( section.descriptor.i ) {\r\n\t\t\t\t\t\tfragmentOptions.indexRef = section.descriptor.i;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tsection.fragments[i] = section.createFragment( fragmentOptions );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsection.length = length;\r\n\t};\r\n\r\n\tupdateListObjectSection = function ( section, value, fragmentOptions ) {\r\n\t\tvar id, fragmentsById;\r\n\r\n\t\tfragmentsById = section.fragmentsById || ( section.fragmentsById = createFromNull() );\r\n\r\n\t\t// remove any fragments that should no longer exist\r\n\t\tfor ( id in fragmentsById ) {\r\n\t\t\tif ( value[ id ] === undefined && fragmentsById[ id ] ) {\r\n\t\t\t\tfragmentsById[ id ].teardown( true );\r\n\t\t\t\tfragmentsById[ id ] = null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// add any that haven't been created yet\r\n\t\tfor ( id in value ) {\r\n\t\t\tif ( value[ id ] !== undefined && !fragmentsById[ id ] ) {\r\n\t\t\t\tfragmentOptions.contextStack = section.contextStack.concat( section.keypath + '.' + id );\r\n\t\t\t\tfragmentOptions.index = id;\r\n\r\n\t\t\t\tif ( section.descriptor.i ) {\r\n\t\t\t\t\tfragmentOptions.indexRef = section.descriptor.i;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfragmentsById[ id ] = section.createFragment( fragmentOptions );\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tupdateContextSection = function ( section, fragmentOptions ) {\r\n\t\t// ...then if it isn't rendered, render it, adding section.keypath to the context stack\r\n\t\t// (if it is already rendered, then any children dependent on the context stack\r\n\t\t// will update themselves without any prompting)\r\n\t\tif ( !section.length ) {\r\n\t\t\t// append this section to the context stack\r\n\t\t\tfragmentOptions.contextStack = section.contextStack.concat( section.keypath );\r\n\t\t\tfragmentOptions.index = 0;\r\n\r\n\t\t\tsection.fragments[0] = section.createFragment( fragmentOptions );\r\n\t\t\tsection.length = 1;\r\n\t\t}\r\n\t};\r\n\r\n\tupdateConditionalSection = function ( section, value, inverted, fragmentOptions ) {\r\n\t\tvar doRender, emptyArray, fragmentsToRemove;\r\n\r\n\t\temptyArray = ( isArray( value ) && value.length === 0 );\r\n\r\n\t\tif ( inverted ) {\r\n\t\t\tdoRender = emptyArray || !value;\r\n\t\t} else {\r\n\t\t\tdoRender = value && !emptyArray;\r\n\t\t}\r\n\r\n\t\tif ( doRender ) {\r\n\t\t\tif ( !section.length ) {\r\n\t\t\t\t// no change to context stack\r\n\t\t\t\tfragmentOptions.contextStack = section.contextStack;\r\n\t\t\t\tfragmentOptions.index = 0;\r\n\r\n\t\t\t\tsection.fragments[0] = section.createFragment( fragmentOptions );\r\n\t\t\t\tsection.length = 1;\r\n\t\t\t}\r\n\r\n\t\t\tif ( section.length > 1 ) {\r\n\t\t\t\tfragmentsToRemove = section.fragments.splice( 1 );\r\n\t\t\t\t\r\n\t\t\t\twhile ( fragmentsToRemove.length ) {\r\n\t\t\t\t\tfragmentsToRemove.pop().teardown( true );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\telse if ( section.length ) {\r\n\t\t\tsection.teardownFragments( true );\r\n\t\t\tsection.length = 0;\r\n\t\t}\r\n\t};\r\n\r\n}());\r\nvar getItem;\r\n\r\n(function () {\r\n\r\n\tvar getText, getMustache, getElement;\r\n\r\n\tgetItem = function ( parser, preserveWhitespace ) {\r\n\t\tif ( !parser.next() ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn getText( parser, preserveWhitespace )\r\n\t\t    || getMustache( parser, preserveWhitespace )\r\n\t\t    || getElement( parser, preserveWhitespace );\r\n\t};\r\n\r\n\tgetText = function ( parser, preserveWhitespace ) {\r\n\t\tvar next = parser.next();\r\n\r\n\t\tif ( next.type === TEXT ) {\r\n\t\t\tparser.pos += 1;\r\n\t\t\treturn new TextStub( next, preserveWhitespace );\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t};\r\n\r\n\tgetMustache = function ( parser, preserveWhitespace ) {\r\n\t\tvar next = parser.next();\r\n\r\n\t\tif ( next.type === MUSTACHE || next.type === TRIPLE ) {\r\n\t\t\tif ( next.mustacheType === SECTION || next.mustacheType === INVERTED ) {\r\n\t\t\t\treturn new SectionStub( next, parser, preserveWhitespace );\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t\treturn new MustacheStub( next, parser );\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t};\r\n\r\n\tgetElement = function ( parser, preserveWhitespace ) {\r\n\t\tvar next = parser.next(), stub;\r\n\r\n\t\tif ( next.type === TAG ) {\r\n\t\t\tstub = new ElementStub( next, parser, preserveWhitespace );\r\n\r\n\t\t\t// sanitize\t\t\t\r\n\t\t\tif ( parser.options.sanitize && parser.options.sanitize.elements ) {\r\n\t\t\t\tif ( parser.options.sanitize.elements.indexOf( stub.lcTag ) !== -1 ) {\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn stub;\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t};\r\n\r\n}());\r\nvar jsonifyStubs = function ( items, noStringify ) {\r\n\tvar str, json;\r\n\r\n\tif ( !noStringify ) {\r\n\t\tstr = stringifyStubs( items );\r\n\t\tif ( str !== false ) {\r\n\t\t\treturn str;\r\n\t\t}\r\n\t}\r\n\r\n\tjson = items.map( function ( item ) {\r\n\t\treturn item.toJSON( noStringify );\r\n\t});\r\n\r\n\treturn json;\r\n};\r\nvar stringifyStubs = function ( items ) {\r\n\tvar str = '', itemStr, i, len;\r\n\r\n\tif ( !items ) {\r\n\t\treturn '';\r\n\t}\r\n\r\n\tfor ( i=0, len=items.length; i<len; i+=1 ) {\r\n\t\titemStr = items[i].toString();\r\n\t\t\r\n\t\tif ( itemStr === false ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tstr += itemStr;\r\n\t}\r\n\r\n\treturn str;\r\n};\r\nvar allowWhitespace = function ( tokenizer ) {\r\n\tvar match = leadingWhitespace.exec( tokenizer.str.substring( tokenizer.pos ) );\r\n\r\n\tif ( !match ) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\ttokenizer.pos += match[0].length;\r\n\treturn match[0];\r\n};\r\n// TODO give this a less conflicty name\r\nvar fail = function ( tokenizer, expected ) {\r\n\tvar remaining = tokenizer.remaining().substr( 0, 40 );\r\n\tif ( remaining.length === 40 ) {\r\n\t\tremaining += '...';\r\n\t}\r\n\tthrow new Error( 'Tokenizer failed: unexpected string \"' + remaining + '\" (expected ' + expected + ')' );\r\n};\r\nvar getRegexMatcher = function ( regex ) {\r\n\treturn function ( tokenizer ) {\r\n\t\tvar match = regex.exec( tokenizer.str.substring( tokenizer.pos ) );\r\n\r\n\t\tif ( !match ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\ttokenizer.pos += match[0].length;\r\n\t\treturn match[1] || match[0];\r\n\t};\r\n};\r\nvar getStringMatch = function ( tokenizer, string ) {\r\n\tvar substr;\r\n\r\n\tsubstr = tokenizer.str.substr( tokenizer.pos, string.length );\r\n\r\n\tif ( substr === string ) {\r\n\t\ttokenizer.pos += string.length;\r\n\t\treturn string;\r\n\t}\r\n\r\n\treturn null;\r\n};\r\nstripCommentTokens = function ( tokens ) {\r\n\tvar i, current, previous, next;\r\n\r\n\tfor ( i=0; i<tokens.length; i+=1 ) {\r\n\t\tcurrent = tokens[i];\r\n\t\tprevious = tokens[i-1];\r\n\t\tnext = tokens[i+1];\r\n\r\n\t\t// if the current token is a comment or a delimiter change, remove it...\r\n\t\tif ( current.mustacheType === COMMENT || current.mustacheType === DELIMCHANGE ) {\r\n\t\t\t\r\n\t\t\ttokens.splice( i, 1 ); // remove comment token\r\n\r\n\t\t\t// ... and see if it has text nodes either side, in which case\r\n\t\t\t// they can be concatenated\r\n\t\t\tif ( previous && next ) {\r\n\t\t\t\tif ( previous.type === TEXT && next.type === TEXT ) {\r\n\t\t\t\t\tprevious.value += next.value;\r\n\t\t\t\t\t\r\n\t\t\t\t\ttokens.splice( i, 1 ); // remove next token\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ti -= 1; // decrement i to account for the splice(s)\r\n\t\t}\r\n\t}\r\n\r\n\treturn tokens;\r\n};\r\nstripHtmlComments = function ( html ) {\r\n\tvar commentStart, commentEnd, processed;\r\n\r\n\tprocessed = '';\r\n\r\n\twhile ( html.length ) {\r\n\t\tcommentStart = html.indexOf( '<!--' );\r\n\t\tcommentEnd = html.indexOf( '-->' );\r\n\r\n\t\t// no comments? great\r\n\t\tif ( commentStart === -1 && commentEnd === -1 ) {\r\n\t\t\tprocessed += html;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// comment start but no comment end\r\n\t\tif ( commentStart !== -1 && commentEnd === -1 ) {\r\n\t\t\tthrow 'Illegal HTML - expected closing comment sequence (\\'-->\\')';\r\n\t\t}\r\n\r\n\t\t// comment end but no comment start, or comment end before comment start\r\n\t\tif ( ( commentEnd !== -1 && commentStart === -1 ) || ( commentEnd < commentStart ) ) {\r\n\t\t\tthrow 'Illegal HTML - unexpected closing comment sequence (\\'-->\\')';\r\n\t\t}\r\n\r\n\t\tprocessed += html.substr( 0, commentStart );\r\n\t\thtml = html.substring( commentEnd + 3 );\r\n\t}\r\n\r\n\treturn processed;\r\n};\r\nstripStandalones = function ( tokens ) {\r\n\tvar i, current, backOne, backTwo, leadingLinebreak, trailingLinebreak;\r\n\r\n\tleadingLinebreak = /^\\s*\\r?\\n/;\r\n\ttrailingLinebreak = /\\r?\\n\\s*$/;\r\n\r\n\tfor ( i=2; i<tokens.length; i+=1 ) {\r\n\t\tcurrent = tokens[i];\r\n\t\tbackOne = tokens[i-1];\r\n\t\tbackTwo = tokens[i-2];\r\n\r\n\t\t// if we're at the end of a [text][mustache][text] sequence...\r\n\t\tif ( current.type === TEXT && ( backOne.type === MUSTACHE ) && backTwo.type === TEXT ) {\r\n\r\n\t\t\t// ... and the mustache is a standalone (i.e. line breaks either side)...\r\n\t\t\tif ( trailingLinebreak.test( backTwo.value ) && leadingLinebreak.test( current.value ) ) {\r\n\r\n\t\t\t\t// ... then we want to remove the whitespace after the first line break\r\n\t\t\t\t// if the mustache wasn't a triple or interpolator or partial\r\n\t\t\t\tif ( backOne.mustacheType !== INTERPOLATOR && backOne.mustacheType !== TRIPLE ) {\r\n\t\t\t\t\tbackTwo.value = backTwo.value.replace( trailingLinebreak, '\\n' );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// and the leading line break of the second text token\r\n\t\t\t\tcurrent.value = current.value.replace( leadingLinebreak, '' );\r\n\r\n\t\t\t\t// if that means the current token is now empty, we should remove it\r\n\t\t\t\tif ( current.value === '' ) {\r\n\t\t\t\t\ttokens.splice( i--, 1 ); // splice and decrement\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn tokens;\r\n};\r\n(function ( proto ) {\r\n\r\n\tvar add = function ( root, keypath, d ) {\r\n\t\tvar value;\r\n\r\n\t\tif ( typeof keypath !== 'string' || !isNumeric( d ) ) {\r\n\t\t\tif ( root.debug ) {\r\n\t\t\t\tthrow new Error( 'Bad arguments' );\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvalue = root.get( keypath );\r\n\r\n\t\tif ( value === undefined ) {\r\n\t\t\tvalue = 0;\r\n\t\t}\r\n\r\n\t\tif ( !isNumeric( value ) ) {\r\n\t\t\tif ( root.debug ) {\r\n\t\t\t\tthrow new Error( 'Cannot add to a non-numeric value' );\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\troot.set( keypath, value + d );\r\n\t};\r\n\r\n\tproto.add = function ( keypath, d ) {\r\n\t\tadd( this, keypath, ( d === undefined ? 1 : d ) );\r\n\t};\r\n\r\n\tproto.subtract = function ( keypath, d ) {\r\n\t\tadd( this, keypath, ( d === undefined ? -1 : -d ) );\r\n\t};\r\n\r\n\tproto.toggle = function ( keypath ) {\r\n\t\tvar value;\r\n\r\n\t\tif ( typeof keypath !== 'string' ) {\r\n\t\t\tif ( this.debug ) {\r\n\t\t\t\tthrow new Error( 'Bad arguments' );\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvalue = this.get( keypath );\r\n\t\tthis.set( keypath, !value );\r\n\t};\r\n\r\n}( proto ));\r\n(function ( proto ) {\r\n\r\n\tvar animate, noAnimation;\r\n\r\n\tproto.animate = function ( keypath, to, options ) {\r\n\t\t\r\n\t\tvar k, animation, animations;\r\n\r\n\t\t// animate multiple keypaths\r\n\t\tif ( typeof keypath === 'object' ) {\r\n\t\t\toptions = to || {};\r\n\t\t\tanimations = [];\r\n\r\n\t\t\tfor ( k in keypath ) {\r\n\t\t\t\tif ( hasOwn.call( keypath, k ) ) {\r\n\t\t\t\t\tanimations[ animations.length ] = animate( this, k, keypath[k], options );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\tstop: function () {\r\n\t\t\t\t\twhile ( animations.length ) {\r\n\t\t\t\t\t\tanimations.pop().stop();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// animate a single keypath\r\n\t\toptions = options || {};\r\n\r\n\t\tanimation = animate( this, keypath, to, options );\r\n\r\n\t\treturn {\r\n\t\t\tstop: function () {\r\n\t\t\t\tanimation.stop();\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n\r\n\tnoAnimation = {\r\n\t\tstop: noop\r\n\t};\r\n\r\n\tanimate = function ( root, keypath, to, options ) {\r\n\t\tvar easing, duration, animation, i, from;\r\n\r\n\t\tfrom = root.get( keypath );\r\n\t\t\r\n\t\t// cancel any existing animation\r\n\t\t// TODO what about upstream/downstream keypaths?\r\n\t\ti = animationCollection.animations.length;\r\n\t\twhile ( i-- ) {\r\n\t\t\tanimation = animationCollection.animations[i];\r\n\r\n\t\t\tif ( animation.root === root && animation.keypath === keypath ) {\r\n\t\t\t\tanimation.stop();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// don't bother animating values that stay the same\r\n\t\tif ( isEqual( from, to ) ) {\r\n\t\t\tif ( options.complete ) {\r\n\t\t\t\toptions.complete( 1, options.to );\r\n\t\t\t}\r\n\r\n\t\t\treturn noAnimation;\r\n\t\t}\r\n\r\n\t\t// easing function\r\n\t\tif ( options.easing ) {\r\n\t\t\tif ( typeof options.easing === 'function' ) {\r\n\t\t\t\teasing = options.easing;\r\n\t\t\t}\r\n\r\n\t\t\telse {\r\n\t\t\t\tif ( root.easing && root.easing[ options.easing ] ) {\r\n\t\t\t\t\t// use instance easing function first\r\n\t\t\t\t\teasing = root.easing[ options.easing ];\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// fallback to global easing functions\r\n\t\t\t\t\teasing = Ractive.easing[ options.easing ];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( typeof easing !== 'function' ) {\r\n\t\t\t\teasing = null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// duration\r\n\t\tduration = ( options.duration === undefined ? 400 : options.duration );\r\n\r\n\t\t// TODO store keys, use an internal set method\r\n\t\tanimation = new Animation({\r\n\t\t\tkeypath: keypath,\r\n\t\t\tfrom: from,\r\n\t\t\tto: to,\r\n\t\t\troot: root,\r\n\t\t\tduration: duration,\r\n\t\t\teasing: easing,\r\n\t\t\tstep: options.step,\r\n\t\t\tcomplete: options.complete\r\n\t\t});\r\n\r\n\t\tanimationCollection.push( animation );\r\n\t\troot._animations[ root._animations.length ] = animation;\r\n\r\n\t\treturn animation;\r\n\t};\r\n\r\n}( proto ));\r\nproto.cancelFullscreen = function () {\r\n\tRactive.cancelFullscreen( this.el );\r\n};\r\n// TODO can fail badly with { append: true }\r\nproto.find = function ( selector ) {\r\n\tif ( !this.el ) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\treturn this.el.querySelector( selector );\r\n};\r\n// TODO can fail badly with { append: true }\r\n(function () {\r\n\r\n\tvar tagSelector, classSelector;\r\n\r\n\tproto.findAll = function ( selector, live ) {\r\n\t\tvar errorMessage;\r\n\r\n\t\tif ( !this.el ) {\r\n\t\t\treturn [];\r\n\t\t}\r\n\r\n\t\t// If the selector is a tag name or a class name, we can (optionally)\r\n\t\t// return a live nodelist (querySelector returns a static list)\r\n\t\tif ( live ) {\r\n\t\t\tif ( tagSelector.test( selector ) ) {\r\n\t\t\t\treturn this.el.getElementsByTagName( selector );\r\n\t\t\t}\r\n\r\n\t\t\tif ( classSelector.test( selector ) ) {\r\n\t\t\t\treturn this.el.getElementsByClassName( selector.substring( 1 ) );\r\n\t\t\t}\r\n\r\n\t\t\terrorMessage = 'Could not generate live nodelist from \"' + selector + '\" selector';\r\n\r\n\t\t\tif ( this.debug ) {\r\n\t\t\t\tthrow new Error( errorMessage );\r\n\t\t\t} else if ( console && console.warn ) {\r\n\t\t\t\tconsole.warn( errorMessage );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.el.querySelectorAll( selector );\r\n\t};\r\n\r\n\ttagSelector = /^[a-zA-Z][a-zA-Z0-9\\-]*$/;\r\n\tclassSelector = /^\\.[^\\s]+$/g;\r\n\r\n}());\r\nproto.fire = function ( eventName ) {\r\n\tvar args, i, len, subscribers = this._subs[ eventName ];\r\n\r\n\tif ( !subscribers ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\targs = Array.prototype.slice.call( arguments, 1 );\r\n\r\n\tfor ( i=0, len=subscribers.length; i<len; i+=1 ) {\r\n\t\tsubscribers[i].apply( this, args );\r\n\t}\r\n};\r\n(function ( proto ) {\r\n\r\n\tvar get,\r\n\t\tprefix,\r\n\t\tgetPrefixer,\r\n\t\tprefixers = {},\r\n\t\tadaptIfNecessary;\r\n\r\n\tproto.get = function ( keypath ) {\r\n\t\tvar cache,\r\n\t\t\tcached,\r\n\t\t\tvalue,\r\n\t\t\twrapped,\r\n\t\t\tevaluator;\r\n\r\n\t\t// Normalise the keypath (i.e. list[0].foo -> list.0.foo)\r\n\t\tkeypath = normaliseKeypath( keypath || '' );\r\n\r\n\t\tcache = this._cache;\r\n\r\n\t\tif ( ( cached = cache[ keypath ] ) !== undefined ) {\r\n\t\t\treturn cached;\r\n\t\t}\r\n\r\n\t\t// Is this a wrapped property?\r\n\t\tif ( wrapped = this._wrapped[ keypath ] ) {\r\n\t\t\tvalue = wrapped.value;\r\n\t\t}\r\n\r\n\t\t// Is it the root?\r\n\t\telse if ( !keypath ) {\r\n\t\t\tadaptIfNecessary( this, '', this.data );\r\n\t\t\tvalue = this.data;\r\n\t\t}\r\n\r\n\t\t// Is this an uncached evaluator value?\r\n\t\telse if ( evaluator = this._evaluators[ keypath ] ) {\r\n\t\t\tvalue = evaluator.value;\r\n\t\t}\r\n\r\n\t\t// No? Then we need to retrieve the value one key at a time\r\n\t\telse {\r\n\t\t\tvalue = get( this, keypath );\r\n\t\t}\r\n\t\t\r\n\t\tcache[ keypath ] = value;\r\n\t\treturn value;\r\n\t};\r\n\r\n\r\n\r\n\tget = function ( ractive, keypath ) {\r\n\t\tvar keys, key, parentKeypath, parentValue, cacheMap, value, adaptor, wrapped;\r\n\r\n\t\tkeys = keypath.split( '.' );\r\n\t\tkey = keys.pop();\r\n\t\tparentKeypath = keys.join( '.' );\r\n\r\n\t\tparentValue = ractive.get( parentKeypath );\r\n\r\n\t\tif ( wrapped = ractive._wrapped[ parentKeypath ] ) {\r\n\t\t\tparentValue = wrapped.get();\r\n\t\t}\r\n\r\n\t\tif ( parentValue === null || parentValue === undefined ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// update cache map\r\n\t\tif ( !( cacheMap = ractive._cacheMap[ parentKeypath ] ) ) {\r\n\t\t\tractive._cacheMap[ parentKeypath ] = [ keypath ];\r\n\t\t} else {\r\n\t\t\tif ( cacheMap.indexOf( keypath ) === -1 ) {\r\n\t\t\t\tcacheMap[ cacheMap.length ] = keypath;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tvalue = parentValue[ key ];\r\n\r\n\r\n\t\t// Do we have an adaptor for this value?\r\n\t\tif ( adaptIfNecessary( ractive, keypath, value ) ) {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\r\n\t\t// If we're in 'magic' mode, wrap this object\r\n\t\tif ( ractive.magic ) {\r\n\t\t\tractive._wrapped[ keypath ] = Ractive.adaptors.magic.wrap( ractive, value, keypath );\r\n\t\t}\r\n\r\n\t\t// Should we use the in-built adaptor for plain arrays?\r\n\t\tif ( ractive.modifyArrays ) {\r\n\t\t\tadaptor = Ractive.adaptors.array;\r\n\r\n\t\t\tif ( adaptor.filter( ractive, value, keypath ) ) {\r\n\t\t\t\tractive._wrapped[ keypath ] = adaptor.wrap( ractive, value, keypath );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Update cache\r\n\t\tractive._cache[ keypath ] = value;\r\n\t\treturn value;\r\n\t};\r\n\t\r\n\r\n\tprefix = function ( obj, prefix ) {\r\n\t\tvar prefixed = {}, key;\r\n\r\n\t\tif ( !prefix ) {\r\n\t\t\treturn obj;\r\n\t\t}\r\n\r\n\t\tprefix += '.';\r\n\r\n\t\tfor ( key in obj ) {\r\n\t\t\tif ( hasOwn.call( obj, key ) ) {\r\n\t\t\t\tprefixed[ prefix + key ] = obj[ key ];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn prefixed;\r\n\t};\r\n\r\n\tgetPrefixer = function ( rootKeypath ) {\r\n\t\tvar rootDot;\r\n\r\n\t\tif ( !prefixers[ rootKeypath ] ) {\r\n\t\t\trootDot = rootKeypath ? rootKeypath + '.' : '';\r\n\r\n\t\t\tprefixers[ rootKeypath ] = function ( relativeKeypath, value ) {\r\n\t\t\t\tvar obj;\r\n\r\n\t\t\t\tif ( typeof relativeKeypath === 'string' ) {\r\n\t\t\t\t\tobj = {};\r\n\t\t\t\t\tobj[ rootDot + relativeKeypath ] = value;\r\n\t\t\t\t\treturn obj;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( typeof relativeKeypath === 'object' ) {\r\n\t\t\t\t\t// 'relativeKeypath' is in fact a hash, not a keypath\r\n\t\t\t\t\treturn rootDot ? prefix( relativeKeypath, rootKeypath ) : relativeKeypath;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn prefixers[ rootKeypath ];\r\n\t};\r\n\r\n\tadaptIfNecessary = function ( ractive, keypath, value ) {\r\n\t\tvar i, adaptor, wrapped;\r\n\r\n\t\t// Do we have an adaptor for this value?\r\n\t\ti = ractive.adaptors.length;\r\n\t\twhile ( i-- ) {\r\n\t\t\tadaptor = ractive.adaptors[i];\r\n\t\t\t\r\n\t\t\t// Adaptors can be specified as e.g. [ 'Backbone.Model', 'Backbone.Collection' ] -\r\n\t\t\t// we need to get the actual adaptor if that's the case\r\n\t\t\tif ( typeof adaptor === 'string' ) {\r\n\t\t\t\tif ( !Ractive.adaptors[ adaptor ] ) {\r\n\t\t\t\t\tthrow new Error( 'Missing adaptor \"' + adaptor + '\"' );\r\n\t\t\t\t}\r\n\t\t\t\tadaptor = ractive.adaptors[i] = Ractive.adaptors[ adaptor ];\r\n\t\t\t}\r\n\r\n\t\t\tif ( adaptor.filter( value, keypath, ractive ) ) {\r\n\t\t\t\twrapped = ractive._wrapped[ keypath ] = adaptor.wrap( ractive, value, keypath, getPrefixer( keypath ) );\r\n\t\t\t\tractive._cache[ keypath ] = value;\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n}( proto ));\r\nvar attemptKeypathResolution = function ( root ) {\r\n\tvar i, unresolved, keypath;\r\n\r\n\t// See if we can resolve any of the unresolved keypaths (if such there be)\r\n\ti = root._pendingResolution.length;\r\n\twhile ( i-- ) { // Work backwards, so we don't go in circles!\r\n\t\tunresolved = root._pendingResolution.splice( i, 1 )[0];\r\n\r\n\t\tkeypath = resolveRef( root, unresolved.ref, unresolved.contextStack );\r\n\t\tif ( keypath !== undefined ) {\r\n\t\t\t// If we've resolved the keypath, we can initialise this item\r\n\t\t\tunresolved.resolve( keypath );\r\n\r\n\t\t} else {\r\n\t\t\t// If we can't resolve the reference, add to the back of\r\n\t\t\t// the queue (this is why we're working backwards)\r\n\t\t\troot._pendingResolution[ root._pendingResolution.length ] = unresolved;\r\n\t\t}\r\n\t}\r\n};\r\nclearCache = function ( ractive, keypath ) {\r\n\tvar cacheMap, wrappedProperty;\r\n\r\n\t// Is there a wrapped property at this keypath?\r\n\tif ( wrappedProperty = ractive._wrapped[ keypath ] ) {\r\n\t\t// Did we unwrap it?\r\n\t\tif ( wrappedProperty.teardown() !== false ) {\r\n\t\t\tractive._wrapped[ keypath ] = null;\r\n\t\t}\r\n\t}\r\n\t\r\n\tractive._cache[ keypath ] = undefined;\r\n\r\n\tif ( cacheMap = ractive._cacheMap[ keypath ] ) {\r\n\t\twhile ( cacheMap.length ) {\r\n\t\t\tclearCache( ractive, cacheMap.pop() );\r\n\t\t}\r\n\t}\r\n};\r\nvar getValueFromCheckboxes = function ( ractive, keypath ) {\r\n\tvar value, checkboxes, checkbox, len, i, rootEl;\r\n\r\n\tvalue = [];\r\n\r\n\t// TODO in edge cases involving components with inputs bound to the same keypath, this\r\n\t// could get messy\r\n\t\r\n\t// if we're still in the initial render, we need to find the inputs from the as-yet off-DOM\r\n\t// document fragment. otherwise, the root element\r\n\trootEl = ractive.rendered ? ractive.el : ractive.fragment.docFrag;\r\n\tcheckboxes = rootEl.querySelectorAll( 'input[type=\"checkbox\"][name=\"{{' + keypath + '}}\"]' );\r\n\t\r\n\tlen = checkboxes.length;\r\n\r\n\tfor ( i=0; i<len; i+=1 ) {\r\n\t\tcheckbox = checkboxes[i];\r\n\r\n\t\tif ( checkbox.hasAttribute( 'checked' ) || checkbox.checked ) {\r\n\t\t\tvalue[ value.length ] = checkbox._ractive.value;\r\n\t\t}\r\n\t}\r\n\r\n\treturn value;\r\n};\r\nnotifyDependants = function ( ractive, keypath, onlyDirect ) {\r\n\tvar i;\r\n\r\n\tfor ( i=0; i<ractive._deps.length; i+=1 ) { // can't cache ractive._deps.length, it may change\r\n\t\tnotifyDependantsByPriority( ractive, keypath, i, onlyDirect );\r\n\t}\r\n};\r\nnotifyDependantsByPriority = function ( ractive, keypath, priority, onlyDirect ) {\r\n\tvar depsByKeypath, deps, i, childDeps;\r\n\r\n\tdepsByKeypath = ractive._deps[ priority ];\r\n\r\n\tif ( !depsByKeypath ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tdeps = depsByKeypath[ keypath ];\r\n\r\n\tif ( deps ) {\r\n\t\ti = deps.length;\r\n\t\twhile ( i-- ) {\r\n\t\t\tdeps[i].update();\r\n\t\t}\r\n\t}\r\n\r\n\t// If we're only notifying direct dependants, not dependants\r\n\t// of downstream keypaths, then YOU SHALL NOT PASS\r\n\tif ( onlyDirect ) {\r\n\t\treturn;\r\n\t}\r\n\t\r\n\r\n\t// cascade\r\n\tchildDeps = ractive._depsMap[ keypath ];\r\n\t\r\n\tif ( childDeps ) {\r\n\t\ti = childDeps.length;\r\n\t\twhile ( i-- ) {\r\n\t\t\tnotifyDependantsByPriority( ractive, childDeps[i], priority );\r\n\t\t}\r\n\t}\r\n};\r\nnotifyMultipleDependants = function ( ractive, keypaths, onlyDirect ) {\r\n\tvar  i, j, len;\r\n\r\n\tlen = keypaths.length;\r\n\r\n\tfor ( i=0; i<ractive._deps.length; i+=1 ) {\r\n\t\tif ( ractive._deps[i] ) {\r\n\t\t\tj = len;\r\n\t\t\twhile ( j-- ) {\r\n\t\t\t\tnotifyDependantsByPriority( ractive, keypaths[j], i, onlyDirect );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\nprocessDeferredUpdates = function ( ractive ) {\r\n\tvar evaluator, attribute, keypath;\r\n\r\n\twhile ( ractive._defEvals.length ) {\r\n\t\t evaluator = ractive._defEvals.pop();\r\n\t\t evaluator.update().deferred = false;\r\n\t}\r\n\r\n\twhile ( ractive._defAttrs.length ) {\r\n\t\tattribute = ractive._defAttrs.pop();\r\n\t\tattribute.update().deferred = false;\r\n\t}\r\n\r\n\twhile ( ractive._defSelectValues.length ) {\r\n\t\tractive._defSelectValues.pop().deferredUpdate();\r\n\t}\r\n\r\n\twhile ( ractive._defCheckboxes.length ) {\r\n\t\tkeypath = ractive._defCheckboxes.pop();\r\n\t\tractive.set( keypath, getValueFromCheckboxes( ractive, keypath ) );\r\n\t}\r\n\r\n\twhile ( ractive._defRadios.length ) {\r\n\t\tractive._defRadios.pop().update();\r\n\t}\r\n\r\n\twhile ( ractive._defObservers.length ) {\r\n\t\tractive._defObservers.pop().update( true );\r\n\t}\r\n};\r\nregisterDependant = function ( dependant ) {\r\n\tvar depsByKeypath, deps, keys, parentKeypath, map, ractive, keypath, priority, evaluator;\r\n\r\n\tractive = dependant.root;\r\n\tkeypath = dependant.keypath;\r\n\tpriority = dependant.priority;\r\n\r\n\tdepsByKeypath = ractive._deps[ priority ] || ( ractive._deps[ priority ] = {} );\r\n\tdeps = depsByKeypath[ keypath ] || ( depsByKeypath[ keypath ] = [] );\r\n\r\n\tdeps[ deps.length ] = dependant;\r\n\r\n\t// If this keypath is an evaluator, note the dependency. If the evaluator didn't\r\n\t// previously exist, or it used to have dependants, then didn't, and now does again,\r\n\t// we can wake it up\r\n\tif ( evaluator = ractive._evaluators[ keypath ] ) {\r\n\t\tif ( !evaluator.dependants ) {\r\n\t\t\tevaluator.wake();\r\n\t\t}\r\n\r\n\t\tevaluator.dependants += 1;\r\n\t}\r\n\r\n\t// update dependants map\r\n\tkeys = keypath.split( '.' );\r\n\t\r\n\twhile ( keys.length ) {\r\n\t\tkeys.pop();\r\n\t\tparentKeypath = keys.join( '.' );\r\n\t\r\n\t\tmap = ractive._depsMap[ parentKeypath ] || ( ractive._depsMap[ parentKeypath ] = [] );\r\n\r\n\t\tif ( map[ keypath ] === undefined ) {\r\n\t\t\tmap[ keypath ] = 0;\r\n\t\t\tmap[ map.length ] = keypath;\r\n\t\t}\r\n\r\n\t\tmap[ keypath ] += 1;\r\n\r\n\t\tkeypath = parentKeypath;\r\n\t}\r\n};\r\n// Render instance to element specified here or at initialization\r\nrender = function ( ractive, options ) {\r\n\tvar el, transitionManager;\r\n\r\n\tel = ( options.el ? getEl( options.el ) : ractive.el );\r\n\r\n\t// Clear the element, unless `append` is `true`\r\n\tif ( el && !options.append ) {\r\n\t\tel.innerHTML = '';\r\n\t}\r\n\r\n\tractive._transitionManager = transitionManager = makeTransitionManager( ractive, options.complete );\r\n\r\n\t// Render our *root fragment*\r\n\tractive.fragment = new DomFragment({\r\n\t\tdescriptor: ractive.template,\r\n\t\troot: ractive,\r\n\t\towner: ractive, // saves doing `if ( ractive.parent ) { /*...*/ }` later on\r\n\t\tparentNode: el\r\n\t});\r\n\r\n\tprocessDeferredUpdates( ractive );\r\n\r\n\tif ( el ) {\r\n\t\tel.appendChild( ractive.fragment.docFrag );\r\n\t}\r\n\r\n\t// transition manager has finished its work\r\n\tractive._transitionManager = null;\r\n\ttransitionManager.ready();\r\n\r\n\tractive.rendered = true;\r\n};\r\n// Resolve a full keypath from `ref` within the given `contextStack` (e.g.\r\n// `'bar.baz'` within the context stack `['foo']` might resolve to `'foo.bar.baz'`\r\nresolveRef = function ( ractive, ref, contextStack ) {\r\n\r\n\tvar keys, lastKey, contextKeys, innerMostContext, postfix, parentKeypath, parentValue, wrapped, keypath, context, ancestorErrorMessage;\r\n\r\n\tancestorErrorMessage = 'Could not resolve reference - too many \"../\" prefixes';\r\n\r\n\t// Implicit iterators - i.e. {{.}} - are a special case\r\n\tif ( ref === '.' ) {\r\n\t\tif ( !contextStack.length ) {\r\n\t\t\treturn '';\r\n\t\t}\r\n\r\n\t\treturn contextStack[ contextStack.length - 1 ];\r\n\t}\r\n\r\n\t// If a reference begins with '.', it's either a restricted reference or\r\n\t// an ancestor reference...\r\n\tif ( ref.charAt( 0 ) === '.' ) {\r\n\t\t\r\n\t\t// ...either way we need to get the innermost context\r\n\t\tcontext = contextStack[ contextStack.length - 1 ];\r\n\t\tcontextKeys = context ? context.split( '.' ) : [];\r\n\r\n\t\t// ancestor references (starting \"../\") go up the tree\r\n\t\tif ( ref.substr( 0, 3 ) === '../' ) {\r\n\t\t\twhile ( ref.substr( 0, 3 ) === '../' ) {\r\n\t\t\t\tif ( !contextKeys.length ) {\r\n\t\t\t\t\tthrow new Error( ancestorErrorMessage );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcontextKeys.pop();\r\n\t\t\t\tref = ref.substring( 3 );\r\n\t\t\t}\r\n\r\n\t\t\tcontextKeys.push( ref );\r\n\t\t\treturn contextKeys.join( '.' );\r\n\t\t}\r\n\r\n\t\t// not an ancestor reference - must be a restricted reference (prepended with \".\")\r\n\t\tif ( !context ) {\r\n\t\t\treturn ref.substring( 1 );\r\n\t\t}\r\n\t\t\r\n\t\treturn context + ref;\r\n\t}\r\n\r\n\tkeys = ref.split( '.' );\r\n\tlastKey = keys.pop();\r\n\tpostfix = keys.length ? '.' + keys.join( '.' ) : '';\r\n\r\n\t// Clone the context stack, so we don't mutate the original\r\n\tcontextStack = contextStack.concat();\r\n\r\n\t// Take each context from the stack, working backwards from the innermost context\r\n\twhile ( contextStack.length ) {\r\n\r\n\t\tinnerMostContext = contextStack.pop();\r\n\t\tparentKeypath = innerMostContext + postfix;\r\n\r\n\t\tparentValue = ractive.get( parentKeypath );\r\n\r\n\t\tif ( wrapped = ractive._wrapped[ parentKeypath ] ) {\r\n\t\t\tparentValue = wrapped.get();\r\n\t\t}\r\n\r\n\t\tif ( typeof parentValue === 'object' && parentValue !== null && hasOwn.call( parentValue, lastKey ) ) {\r\n\t\t\tkeypath = innerMostContext + '.' + ref;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tif ( !keypath && ractive.get( ref ) !== undefined ) {\r\n\t\tkeypath = ref;\r\n\t}\r\n\r\n\treturn keypath;\r\n};\r\nteardown = function ( thing ) {\r\n\tif ( !thing.keypath ) {\r\n\t\t// this was on the 'unresolved' list, we need to remove it\r\n\t\tvar index = thing.root._pendingResolution.indexOf( thing );\r\n\r\n\t\tif ( index !== -1 ) {\r\n\t\t\tthing.root._pendingResolution.splice( index, 1 );\r\n\t\t}\r\n\r\n\t} else {\r\n\t\t// this was registered as a dependant\r\n\t\tunregisterDependant( thing );\r\n\t}\r\n};\r\nunregisterDependant = function ( dependant ) {\r\n\tvar deps, keys, parentKeypath, map, ractive, keypath, priority, evaluator;\r\n\r\n\tractive = dependant.root;\r\n\tkeypath = dependant.keypath;\r\n\tpriority = dependant.priority;\r\n\r\n\tdeps = ractive._deps[ priority ][ keypath ];\r\n\tdeps.splice( deps.indexOf( dependant ), 1 );\r\n\r\n\t// update dependants map\r\n\tkeys = keypath.split( '.' );\r\n\r\n\t// If this keypath is an evaluator, decrement its dependants property.\r\n\t// That way, if an evaluator doesn't have any remaining dependants (temporarily\r\n\t// or permanently) we can put it to sleep, preventing unnecessary work\r\n\tif ( evaluator = ractive._evaluators[ keypath ] ) {\r\n\t\tevaluator.dependants -= 1;\r\n\t\t\r\n\t\tif ( !evaluator.dependants ) {\r\n\t\t\tevaluator.sleep();\r\n\t\t}\r\n\t}\r\n\t\r\n\twhile ( keys.length ) {\r\n\t\tkeys.pop();\r\n\t\tparentKeypath = keys.join( '.' );\r\n\t\r\n\t\tmap = ractive._depsMap[ parentKeypath ];\r\n\r\n\t\tmap[ keypath ] -= 1;\r\n\r\n\t\tif ( !map[ keypath ] ) {\r\n\t\t\t// remove from parent deps map\r\n\t\t\tmap.splice( map.indexOf( keypath ), 1 );\r\n\t\t\tmap[ keypath ] = undefined;\r\n\t\t}\r\n\r\n\t\tkeypath = parentKeypath;\r\n\t}\r\n};\r\nproto.link = function ( keypath ) {\r\n\tvar self = this;\r\n\r\n\treturn function ( value ) {\r\n\t\tself.set( keypath, value );\r\n\t};\r\n};\r\n(function ( proto ) {\r\n\r\n\tvar observe, Observer;\r\n\r\n\tproto.observe = function ( keypath, callback, options ) {\r\n\r\n\t\tvar observers = [], k;\r\n\r\n\t\tif ( typeof keypath === 'object' ) {\r\n\t\t\toptions = callback || {};\r\n\r\n\t\t\tfor ( k in keypath ) {\r\n\t\t\t\tif ( hasOwn.call( keypath, k ) ) {\r\n\t\t\t\t\tcallback = keypath[k];\r\n\t\t\t\t\tobservers[ observers.length ] = observe( this, k, callback, options );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\tcancel: function () {\r\n\t\t\t\t\twhile ( observers.length ) {\r\n\t\t\t\t\t\tobservers.pop().cancel();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn observe( this, keypath, callback, options || {} );\r\n\t};\r\n\r\n\tobserve = function ( root, keypath, callback, options ) {\r\n\t\tvar observer;\r\n\r\n\t\tobserver = new Observer( root, keypath, callback, options );\r\n\r\n\t\tif ( options.init !== false ) {\r\n\t\t\tobserver.update();\r\n\t\t}\r\n\r\n\t\tobserver.ready = true;\r\n\t\tregisterDependant( observer );\r\n\r\n\t\treturn {\r\n\t\t\tcancel: function () {\r\n\t\t\t\tunregisterDependant( observer );\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n\r\n\tObserver = function ( root, keypath, callback, options ) {\r\n\t\tthis.root = root;\r\n\t\tthis.keypath = keypath;\r\n\t\tthis.callback = callback;\r\n\t\tthis.defer = options.defer;\r\n\t\t\r\n\t\t// Observers are notified before any DOM changes take place (though\r\n\t\t// they can defer execution until afterwards)\r\n\t\tthis.priority = 0;\r\n\r\n\t\t// default to root as context, but allow it to be overridden\r\n\t\tthis.context = options.context || root;\r\n\t};\r\n\r\n\tObserver.prototype = {\r\n\t\tupdate: function ( deferred ) {\r\n\t\t\tvar value;\r\n\r\n\t\t\tif ( this.defer && !deferred && this.ready ) {\r\n\t\t\t\tthis.root._defObservers.push( this );\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Prevent infinite loops\r\n\t\t\tif ( this.updating ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tthis.updating = true;\r\n\r\n\t\t\t// TODO create, and use, an internal get method instead - we can skip checks\r\n\t\t\tvalue = this.root.get( this.keypath, true );\r\n\r\n\t\t\tif ( !isEqual( value, this.value ) || !this.ready ) {\r\n\t\t\t\t// wrap the callback in a try-catch block, and only throw error in\r\n\t\t\t\t// debug mode\r\n\t\t\t\ttry {\r\n\t\t\t\t\tthis.callback.call( this.context, value, this.value );\r\n\t\t\t\t} catch ( err ) {\r\n\t\t\t\t\tif ( this.root.debug ) {\r\n\t\t\t\t\t\tthrow err;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.value = value;\r\n\t\t\t}\r\n\r\n\t\t\tthis.updating = false;\r\n\t\t}\r\n\t};\r\n\r\n}( proto ));\r\n\r\n\r\nproto.off = function ( eventName, callback ) {\r\n\tvar subscribers, index;\r\n\r\n\t// if no callback specified, remove all callbacks\r\n\tif ( !callback ) {\r\n\t\t// if no event name specified, remove all callbacks for all events\r\n\t\tif ( !eventName ) {\r\n\t\t\tthis._subs = {};\r\n\t\t} else {\r\n\t\t\tthis._subs[ eventName ] = [];\r\n\t\t}\r\n\t}\r\n\r\n\tsubscribers = this._subs[ eventName ];\r\n\r\n\tif ( subscribers ) {\r\n\t\tindex = subscribers.indexOf( callback );\r\n\t\tif ( index !== -1 ) {\r\n\t\t\tsubscribers.splice( index, 1 );\r\n\t\t}\r\n\t}\r\n};\r\nproto.on = function ( eventName, callback ) {\r\n\tvar self = this, listeners, n;\r\n\r\n\t// allow mutliple listeners to be bound in one go\r\n\tif ( typeof eventName === 'object' ) {\r\n\t\tlisteners = [];\r\n\r\n\t\tfor ( n in eventName ) {\r\n\t\t\tif ( hasOwn.call( eventName, n ) ) {\r\n\t\t\t\tlisteners[ listeners.length ] = this.on( n, eventName[ n ] );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tcancel: function () {\r\n\t\t\t\twhile ( listeners.length ) {\r\n\t\t\t\t\tlisteners.pop().cancel();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tif ( !this._subs[ eventName ] ) {\r\n\t\tthis._subs[ eventName ] = [ callback ];\r\n\t} else {\r\n\t\tthis._subs[ eventName ].push( callback );\r\n\t}\r\n\r\n\treturn {\r\n\t\tcancel: function () {\r\n\t\t\tself.off( eventName, callback );\r\n\t\t}\r\n\t};\r\n};\r\nproto.renderHTML = function () {\r\n\treturn this.fragment.toString();\r\n};\r\nproto.requestFullscreen = function () {\r\n\tRactive.requestFullscreen( this.el );\r\n};\r\nproto.reset = function ( data, complete ) {\r\n\tvar transitionManager, previousTransitionManager;\r\n\r\n\tif ( typeof data === 'function' ) {\r\n\t\tcomplete = data;\r\n\t\tdata = {};\r\n\t}\r\n\r\n\tif ( data !== undefined && typeof data !== 'object' ) {\r\n\t\tthrow new Error( 'The reset method takes either no arguments, or an object containing new data' );\r\n\t}\r\n\r\n\t// Manage transitions\r\n\tpreviousTransitionManager = this._transitionManager;\r\n\tthis._transitionManager = transitionManager = makeTransitionManager( this, complete );\r\n\r\n\tthis.data = data || {};\r\n\r\n\t// Attempt to resolve any unresolved keypaths...\r\n\tif ( this._pendingResolution.length ) {\r\n\t\tattemptKeypathResolution( this );\r\n\t}\r\n\r\n\tclearCache( this, '' );\r\n\tnotifyDependants( this, '' );\r\n\r\n\tthis.fire( 'reset', data );\r\n\r\n\t// transition manager has finished its work\r\n\tthis._transitionManager = previousTransitionManager;\r\n\ttransitionManager.ready();\r\n};\r\n(function ( proto ) {\r\n\r\n\tvar set, getUpstreamChanges, resetWrapped;\r\n\r\n\tproto.set = function ( keypath, value, complete ) {\r\n\t\tvar map, changes, upstreamChanges, previousTransitionManager, transitionManager, i, changeHash;\r\n\r\n\t\tchanges = [];\r\n\r\n\t\tif ( isObject( keypath ) ) {\r\n\t\t\tmap = keypath;\r\n\t\t\tcomplete = value;\r\n\t\t}\r\n\r\n\t\t// Set multiple keypaths in one go\r\n\t\tif ( map ) {\r\n\t\t\tfor ( keypath in map ) {\r\n\t\t\t\tif ( hasOwn.call( map, keypath) ) {\r\n\t\t\t\t\tvalue = map[ keypath ];\r\n\t\t\t\t\tkeypath = normaliseKeypath( keypath );\r\n\r\n\t\t\t\t\tset( this, keypath, value, changes );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Set a single keypath\r\n\t\telse {\r\n\t\t\tkeypath = normaliseKeypath( keypath );\r\n\t\t\tset( this, keypath, value, changes );\r\n\t\t}\r\n\r\n\t\tif ( !changes.length ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Manage transitions\r\n\t\tpreviousTransitionManager = this._transitionManager;\r\n\t\tthis._transitionManager = transitionManager = makeTransitionManager( this, complete );\r\n\r\n\t\t// ...and notify dependants\r\n\t\tupstreamChanges = getUpstreamChanges( changes );\r\n\t\tif ( upstreamChanges.length ) {\r\n\t\t\tnotifyMultipleDependants( this, upstreamChanges, true );\r\n\t\t}\r\n\r\n\t\tnotifyMultipleDependants( this, changes );\r\n\r\n\t\t// Attempt to resolve any unresolved keypaths...\r\n\t\tif ( this._pendingResolution.length ) {\r\n\t\t\tattemptKeypathResolution( this );\r\n\t\t}\r\n\r\n\t\t// Attributes don't reflect changes automatically if there is a possibility\r\n\t\t// that they will need to change again before the .set() cycle is complete\r\n\t\t// - they defer their updates until all values have been set\r\n\t\tprocessDeferredUpdates( this );\r\n\r\n\t\t// transition manager has finished its work\r\n\t\tthis._transitionManager = previousTransitionManager;\r\n\t\ttransitionManager.ready();\r\n\r\n\t\t// Fire a change event\r\n\t\tif ( !this.firingChangeEvent ) {\r\n\t\t\tthis.firingChangeEvent = true; // short-circuit any potential infinite loops\r\n\t\t\t\r\n\t\t\tchangeHash = {};\r\n\r\n\t\t\ti = changes.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tchangeHash[ changes[i] ] = this.get( changes[i] );\r\n\t\t\t}\r\n\r\n\t\t\tthis.fire( 'change', changeHash );\r\n\r\n\t\t\tthis.firingChangeEvent = false;\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\r\n\tset = function ( ractive, keypath, value, changes ) {\r\n\t\tvar cached, keys, previous, key, obj, accumulated, currentKeypath, keypathToClear, wrapped;\r\n\r\n\t\tif ( ( wrapped = ractive._wrapped[ keypath ] ) && wrapped.reset ) {\r\n\t\t\tif ( resetWrapped( ractive, keypath, value, wrapped, changes ) !== false ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcached = ractive._cache[ keypath ];\r\n\t\tprevious = ractive.get( keypath );\r\n\r\n\t\tkeys = keypath.split( '.' );\r\n\t\taccumulated = [];\r\n\r\n\t\t// update the model, if necessary\r\n\t\tif ( previous !== value ) {\r\n\t\t\t\r\n\t\t\t// Get the root object\r\n\t\t\tif ( wrapped = ractive._wrapped[ '' ] ) {\r\n\t\t\t\tif ( wrapped.set ) {\r\n\t\t\t\t\t// Root object is wrapped, so we need to use the wrapper's\r\n\t\t\t\t\t// set() method\r\n\t\t\t\t\twrapped.set( keys.join( '.' ), value );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tobj = wrapped.get();\r\n\t\t\t} else {\r\n\t\t\t\tobj = ractive.data;\r\n\t\t\t}\r\n\r\n\t\t\t\r\n\t\t\twhile ( keys.length > 1 ) {\r\n\t\t\t\tkey = accumulated[ accumulated.length ] = keys.shift();\r\n\t\t\t\tcurrentKeypath = accumulated.join( '.' );\r\n\r\n\t\t\t\tif ( wrapped = ractive._wrapped[ currentKeypath ] ) {\r\n\t\t\t\t\tif ( wrapped.set ) {\r\n\t\t\t\t\t\twrapped.set( keys.join( '.' ), value );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tobj = wrapped.get();\r\n\t\t\t\t}\r\n\r\n\t\t\t\telse {\r\n\t\t\t\t\t// If this branch doesn't exist yet, create a new one - if the next\r\n\t\t\t\t\t// key matches /^\\s*[0-9]+\\s*$/, assume we want an array branch rather\r\n\t\t\t\t\t// than an object\r\n\t\t\t\t\tif ( !obj[ key ] ) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// if we're creating a new branch, we may need to clear the upstream\r\n\t\t\t\t\t\t// keypath\r\n\t\t\t\t\t\tif ( !keypathToClear ) {\r\n\t\t\t\t\t\t\tkeypathToClear = currentKeypath;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tobj[ key ] = ( /^\\s*[0-9]+\\s*$/.test( keys[0] ) ? [] : {} );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tobj = obj[ key ];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tkey = keys[0];\r\n\t\t\tobj[ key ] = value;\r\n\t\t}\r\n\r\n\t\telse {\r\n\t\t\t// if the value is the same as the cached value AND the value is a primitive,\r\n\t\t\t// we don't need to do anything else\r\n\t\t\tif ( value === cached && typeof value !== 'object' ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\t// Clear cache\r\n\t\tclearCache( ractive, keypathToClear || keypath );\r\n\r\n\t\t// add this keypath to the list of changes\r\n\t\tchanges[ changes.length ] = keypath;\r\n\t};\r\n\r\n\tgetUpstreamChanges = function ( changes ) {\r\n\t\tvar upstreamChanges = [ '' ], i, keypath, keys, upstreamKeypath;\r\n\r\n\t\ti = changes.length;\r\n\t\twhile ( i-- ) {\r\n\t\t\tkeypath = changes[i];\r\n\t\t\tkeys = keypath.split( '.' );\r\n\r\n\t\t\twhile ( keys.length > 1 ) {\r\n\t\t\t\tkeys.pop();\r\n\t\t\t\tupstreamKeypath = keys.join( '.' );\r\n\r\n\t\t\t\tif ( !upstreamChanges[ upstreamKeypath ] ) {\r\n\t\t\t\t\tupstreamChanges[ upstreamChanges.length ] = upstreamKeypath;\r\n\t\t\t\t\tupstreamChanges[ upstreamKeypath ] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn upstreamChanges;\r\n\t};\r\n\r\n\r\n\tresetWrapped = function ( ractive, keypath, value, wrapped, changes ) {\r\n\t\tvar previous, cached, cacheMap, i;\r\n\r\n\t\tprevious = wrapped.get();\r\n\r\n\t\tif ( !isEqual( previous, value ) ) {\r\n\t\t\tif ( wrapped.reset( value ) === false ) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvalue = wrapped.get();\r\n\t\tcached = ractive._cache[ keypath ];\r\n\r\n\t\tif ( !isEqual( cached, value ) ) {\r\n\t\t\tractive._cache[ keypath ] = value;\r\n\r\n\t\t\t// Clear downstream keypaths only. Otherwise this wrapper will be torn down!\r\n\t\t\t// TODO is there a way to intelligently detect whether a wrapper should be\r\n\t\t\t// torn down?\r\n\t\t\tcacheMap = ractive._cacheMap[ keypath ];\r\n\r\n\t\t\tif ( cacheMap ) {\r\n\t\t\t\ti = cacheMap.length;\r\n\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\tclearCache( ractive, cacheMap[i] );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tchanges[ changes.length ] = keypath;\r\n\t\t}\r\n\t};\r\n\r\n}( proto ));\r\n// Teardown. This goes through the root fragment and all its children, removing observers\r\n// and generally cleaning up after itself\r\nproto.teardown = function ( complete ) {\r\n\tvar keypath, transitionManager, previousTransitionManager;\r\n\r\n\tthis.fire( 'teardown' );\r\n\r\n\tpreviousTransitionManager = this._transitionManager;\r\n\tthis._transitionManager = transitionManager = makeTransitionManager( this, complete );\r\n\r\n\tthis.fragment.teardown( true );\r\n\r\n\t// Cancel any animations in progress\r\n\twhile ( this._animations[0] ) {\r\n\t\tthis._animations[0].stop(); // it will remove itself from the index\r\n\t}\r\n\r\n\t// Clear cache - this has the side-effect of unregistering keypaths from modified arrays.\r\n\tfor ( keypath in this._cache ) {\r\n\t\tclearCache( this, keypath );\r\n\t}\r\n\r\n\t// transition manager has finished its work\r\n\tthis._transitionManager = previousTransitionManager;\r\n\ttransitionManager.ready();\r\n};\r\nproto.toggleFullscreen = function () {\r\n\tif ( Ractive.isFullscreen( this.el ) ) {\r\n\t\tthis.cancelFullscreen();\r\n\t} else {\r\n\t\tthis.requestFullscreen();\r\n\t}\r\n};\r\nproto.update = function ( keypath, complete ) {\r\n\tvar transitionManager, previousTransitionManager;\r\n\r\n\tif ( typeof keypath === 'function' ) {\r\n\t\tcomplete = keypath;\r\n\t\tkeypath = '';\r\n\t}\r\n\r\n\t// if we're using update, it's possible that we've introduced new values, and\r\n\t// some unresolved references can be dealt with\r\n\tattemptKeypathResolution( this );\r\n\r\n\t// manage transitions\r\n\tpreviousTransitionManager = this._transitionManager;\r\n\tthis._transitionManager = transitionManager = makeTransitionManager( this, complete );\r\n\r\n\tclearCache( this, keypath || '' );\r\n\tnotifyDependants( this, keypath || '' );\r\n\r\n\tprocessDeferredUpdates( this );\r\n\r\n\t// transition manager has finished its work\r\n\tthis._transitionManager = previousTransitionManager;\r\n\ttransitionManager.ready();\r\n\r\n\tif ( typeof keypath === 'string' ) {\r\n\t\tthis.fire( 'update', keypath );\r\n\t} else {\r\n\t\tthis.fire( 'update' );\r\n\t}\r\n\r\n\treturn this;\r\n};\r\n(function ( proto ) {\r\n\r\n\tvar consolidateChangedValues;\r\n\r\n\tproto.updateModel = function ( keypath, cascade ) {\r\n\t\tvar values, deferredCheckboxes, i;\r\n\r\n\t\tif ( typeof keypath !== 'string' ) {\r\n\t\t\tkeypath = '';\r\n\t\t\tcascade = true;\r\n\t\t}\r\n\r\n\t\tconsolidateChangedValues( this, keypath, values = {}, deferredCheckboxes = [], cascade );\r\n\r\n\t\tif ( i = deferredCheckboxes.length ) {\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tkeypath = deferredCheckboxes[i];\r\n\t\t\t\tvalues[ keypath ] = getValueFromCheckboxes( this, keypath );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.set( values );\r\n\t};\r\n\r\n\tconsolidateChangedValues = function ( ractive, keypath, values, deferredCheckboxes, cascade ) {\r\n\t\tvar bindings, childDeps, i, binding, oldValue, newValue;\r\n\r\n\t\tbindings = ractive._twowayBindings[ keypath ];\r\n\r\n\t\tif ( bindings ) {\r\n\t\t\ti = bindings.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tbinding = bindings[i];\r\n\r\n\t\t\t\t// special case - radio name bindings\r\n\t\t\t\tif ( binding.radioName && !binding.node.checked ) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// special case - checkbox name bindings\r\n\t\t\t\tif ( binding.checkboxName ) {\r\n\t\t\t\t\tif ( binding.changed() && !deferredCheckboxes[ keypath ] ) {\r\n\t\t\t\t\t\t// we will need to see which checkboxes with the same name are checked,\r\n\t\t\t\t\t\t// but we only want to do so once\r\n\t\t\t\t\t\tdeferredCheckboxes[ keypath ] = true; // for quick lookup without indexOf\r\n\t\t\t\t\t\tdeferredCheckboxes[ deferredCheckboxes.length ] = keypath;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\toldValue = binding.attr.value;\r\n\t\t\t\tnewValue = binding.value();\r\n\r\n\t\t\t\tif ( arrayContentsMatch( oldValue, newValue ) ) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( !isEqual( oldValue, newValue ) ) {\r\n\t\t\t\t\tvalues[ keypath ] = newValue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( !cascade ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// cascade\r\n\t\tchildDeps = ractive._depsMap[ keypath ];\r\n\t\t\r\n\t\tif ( childDeps ) {\r\n\t\t\ti = childDeps.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tconsolidateChangedValues( ractive, childDeps[i], values, deferredCheckboxes, cascade );\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n}( proto ));\r\n(function () {\r\n\r\n\tvar notifyArrayDependants,\r\n\r\n\t\tArrayWrapper,\r\n\t\twrapArray,\r\n\t\tunwrapArray,\r\n\t\tWrappedArrayProto,\r\n\t\ttestObj,\r\n\t\tmutatorMethods;\r\n\r\n\t// TODO use the wrapper properly, i.e. having a list of wrappers on each array, rather than\r\n\t// a set of ractives and keypaths\r\n\r\n\tadaptors.array = {\r\n\t\tfilter: function ( ractive, object, keypath ) {\r\n\t\t\t// wrap the array if a) it's not generated by an evaluator, b) it's an array, and\r\n\t\t\t// c) either it hasn't been wrapped already, or the array didn't trigger the get() itself\r\n\t\t\treturn ( keypath.charAt( 0 ) !== '(' ) && isArray( object ) && ( !object._ractive || !object._ractive.setting );\r\n\t\t},\r\n\t\twrap: function ( ractive, array, keypath ) {\r\n\t\t\treturn new ArrayWrapper( ractive, array, keypath );\r\n\t\t}\r\n\t};\r\n\r\n\tArrayWrapper = function ( ractive, array, keypath ) {\r\n\t\tthis.root = ractive;\r\n\t\tthis.value = array;\r\n\t\tthis.keypath = keypath;\r\n\r\n\t\tregisterKeypathToArray( array, keypath, ractive );\r\n\t};\r\n\r\n\tArrayWrapper.prototype = {\r\n\t\tget: function () {\r\n\t\t\treturn this.value;\r\n\t\t},\r\n\t\tteardown: function () {\r\n\t\t\t// if teardown() was invoked because we're clearing the cache as a result of\r\n\t\t\t// a change that the array itself triggered, we can save ourselves the teardown\r\n\t\t\t// and immediate setup\r\n\t\t\tif ( this.value._ractive.setting ) {\r\n\t\t\t\treturn false; // so that we don't remove it from this.root._wrapped\r\n\t\t\t}\r\n\r\n\t\t\tunregisterKeypathFromArray( this.value, this.keypath, this.root );\r\n\t\t}\r\n\t};\r\n\r\n\r\n\r\n\r\n\r\n\t// Register a keypath to this array. When any of this array's mutator methods are called,\r\n\t// it will `set` that keypath on the given Ractive instance\r\n\tregisterKeypathToArray = function ( array, keypath, root ) {\r\n\t\tvar roots, keypathsByGuid, keypaths;\r\n\r\n\t\t// If this array hasn't been wrapped, we need to wrap it\r\n\t\tif ( !array._ractive ) {\r\n\t\t\tdefineProperty( array, '_ractive', {\r\n\t\t\t\tvalue: {\r\n\t\t\t\t\troots: [ root ], // there may be more than one Ractive instance depending on this\r\n\t\t\t\t\tkeypathsByGuid: {}\r\n\t\t\t\t},\r\n\t\t\t\tconfigurable: true\r\n\t\t\t});\r\n\r\n\t\t\tarray._ractive.keypathsByGuid[ root._guid ] = [ keypath ];\r\n\r\n\t\t\twrapArray( array );\r\n\t\t}\r\n\r\n\t\telse {\r\n\t\t\troots = array._ractive.roots;\r\n\t\t\tkeypathsByGuid = array._ractive.keypathsByGuid;\r\n\r\n\t\t\t// Does this Ractive instance currently depend on this array?\r\n\t\t\t// If not, associate them\r\n\t\t\tif ( !keypathsByGuid[ root._guid ] ) {\r\n\t\t\t\troots[ roots.length ] = root;\r\n\t\t\t\tkeypathsByGuid[ root._guid ] = [];\r\n\t\t\t}\r\n\r\n\t\t\tkeypaths = keypathsByGuid[ root._guid ];\r\n\r\n\t\t\t// If the current keypath isn't among them, add it\r\n\t\t\tif ( keypaths.indexOf( keypath ) === -1 ) {\r\n\t\t\t\tkeypaths[ keypaths.length ] = keypath;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\r\n\t// Unregister keypath from array\r\n\tunregisterKeypathFromArray = function ( array, keypath, root ) {\r\n\t\tvar roots, keypathsByGuid, keypaths, keypathIndex;\r\n\r\n\t\tif ( !array._ractive ) {\r\n\t\t\tthrow new Error( 'Attempted to remove keypath from non-wrapped array. This error is unexpected - please send a bug report to @rich_harris' );\r\n\t\t}\r\n\r\n\t\troots = array._ractive.roots;\r\n\t\tkeypathsByGuid = array._ractive.keypathsByGuid;\r\n\r\n\t\tif ( !keypathsByGuid[ root._guid ] ) {\r\n\t\t\tthrow new Error( 'Ractive instance was not listed as a dependent of this array. This error is unexpected - please send a bug report to @rich_harris' );\r\n\t\t}\r\n\r\n\t\tkeypaths = keypathsByGuid[ root._guid ];\r\n\t\tkeypathIndex = keypaths.indexOf( keypath );\r\n\r\n\t\tif ( keypathIndex === -1 ) {\r\n\t\t\tthrow new Error( 'Attempted to unlink non-linked keypath from array. This error is unexpected - please send a bug report to @rich_harris' );\r\n\t\t}\r\n\r\n\t\tkeypaths.splice( keypathIndex, 1 );\r\n\r\n\t\tif ( !keypaths.length ) {\r\n\t\t\troots.splice( roots.indexOf( root ), 1 );\r\n\t\t\tkeypathsByGuid[ root._guid ] = null;\r\n\t\t}\r\n\r\n\t\tif ( !roots.length ) {\r\n\t\t\tunwrapArray( array ); // It's good to clean up after ourselves\r\n\t\t}\r\n\t};\r\n\r\n\r\n\tnotifyArrayDependants = function ( array, methodName, args ) {\r\n\t\tvar processRoots,\r\n\t\t\tprocessRoot,\r\n\t\t\tprocessKeypaths,\r\n\t\t\tprocessKeypath,\r\n\t\t\tqueueDependants,\r\n\t\t\tkeypathsByGuid;\r\n\r\n\t\tkeypathsByGuid = array._ractive.keypathsByGuid;\r\n\r\n\t\tprocessRoots = function ( roots ) {\r\n\t\t\tvar i = roots.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tprocessRoot( roots[i] );\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tprocessRoot = function ( root ) {\r\n\t\t\tvar previousTransitionManager = root._transitionManager, transitionManager;\r\n\r\n\t\t\troot._transitionManager = transitionManager = makeTransitionManager( root, noop );\r\n\t\t\tprocessKeypaths( root, keypathsByGuid[ root._guid ] );\r\n\t\t\troot._transitionManager = previousTransitionManager;\r\n\r\n\t\t\ttransitionManager.ready();\r\n\t\t};\r\n\r\n\t\tprocessKeypaths = function ( root, keypaths ) {\r\n\t\t\tvar i = keypaths.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tprocessKeypath( root, keypaths[i] );\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tprocessKeypath = function ( root, keypath ) {\r\n\t\t\tvar depsByKeypath, deps, keys, upstreamQueue, smartUpdateQueue, dumbUpdateQueue, i, changed, start, end, childKeypath, lengthUnchanged;\r\n\r\n\t\t\t// If this is a sort or reverse, we just do root.set()...\r\n\t\t\tif ( methodName === 'sort' || methodName === 'reverse' ) {\r\n\t\t\t\troot.set( keypath, array );\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// otherwise we do a smart update whereby elements are added/removed\r\n\t\t\t// in the right place. But we do need to clear the cache\r\n\t\t\tclearCache( root, keypath );\r\n\r\n\t\t\t// find dependants. If any are DOM sections, we do a smart update\r\n\t\t\t// rather than a ractive.set() blunderbuss\r\n\t\t\tsmartUpdateQueue = [];\r\n\t\t\tdumbUpdateQueue = [];\r\n\r\n\t\t\tfor ( i=0; i<root._deps.length; i+=1 ) { // we can't cache root._deps.length as it may change!\r\n\t\t\t\tdepsByKeypath = root._deps[i];\r\n\r\n\t\t\t\tif ( !depsByKeypath ) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdeps = depsByKeypath[ keypath ];\r\n\t\t\t\t\r\n\t\t\t\tif ( deps ) {\r\n\t\t\t\t\tqueueDependants( root, keypath, deps, smartUpdateQueue, dumbUpdateQueue );\r\n\r\n\t\t\t\t\t// we may have some deferred evaluators to process\r\n\t\t\t\t\tprocessDeferredUpdates( root );\r\n\r\n\t\t\t\t\twhile ( smartUpdateQueue.length ) {\r\n\t\t\t\t\t\tsmartUpdateQueue.pop().smartUpdate( methodName, args );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twhile ( dumbUpdateQueue.length ) {\r\n\t\t\t\t\t\tdumbUpdateQueue.pop().update();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// if we're removing old items and adding new ones, simultaneously, we need to force an update\r\n\t\t\tif ( methodName === 'splice' && ( args.length > 2 ) && args[1] ) {\r\n\t\t\t\tchanged = Math.min( args[1], args.length - 2 );\r\n\t\t\t\tstart = args[0];\r\n\t\t\t\tend = start + changed;\r\n\r\n\t\t\t\tif ( args[1] === ( args.length - 2 ) ) {\r\n\t\t\t\t\tlengthUnchanged = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( i=start; i<end; i+=1 ) {\r\n\t\t\t\t\tchildKeypath = keypath + '.' + i;\r\n\t\t\t\t\tnotifyDependants( root, childKeypath );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// we may have some deferred attributes to process\r\n\t\t\tprocessDeferredUpdates( root );\r\n\r\n\t\t\t// Finally, notify direct dependants of upstream keypaths...\r\n\t\t\tupstreamQueue = [];\r\n\r\n\t\t\tkeys = keypath.split( '.' );\r\n\t\t\twhile ( keys.length ) {\r\n\t\t\t\tkeys.pop();\r\n\t\t\t\tupstreamQueue[ upstreamQueue.length ] = keys.join( '.' );\r\n\t\t\t}\r\n\r\n\t\t\tnotifyMultipleDependants( root, upstreamQueue, true );\r\n\r\n\t\t\t// length property has changed - notify dependants\r\n\t\t\t// TODO in some cases (e.g. todo list example, when marking all as complete, then\r\n\t\t\t// adding a new item (which should deactivate the 'all complete' checkbox\r\n\t\t\t// but doesn't) this needs to happen before other updates. But doing so causes\r\n\t\t\t// other mental problems. not sure what's going on...\r\n\t\t\tif ( !lengthUnchanged ) {\r\n\t\t\t\tnotifyDependants( root, keypath + '.length', true );\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// TODO can we get rid of this whole queueing nonsense?\r\n\t\tqueueDependants = function ( root, keypath, deps, smartUpdateQueue, dumbUpdateQueue ) {\r\n\t\t\tvar k, dependant;\r\n\r\n\t\t\tk = deps.length;\r\n\t\t\twhile ( k-- ) {\r\n\t\t\t\tdependant = deps[k];\r\n\r\n\t\t\t\t// references need to get processed before mustaches\r\n\t\t\t\tif ( dependant.type === REFERENCE ) {\r\n\t\t\t\t\tdependant.update();\r\n\t\t\t\t\t//dumbUpdateQueue[ dumbUpdateQueue.length ] = dependant;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// is this a DOM section?\r\n\t\t\t\telse if ( dependant.keypath === keypath && dependant.type === SECTION && dependant.parentNode ) {\r\n\t\t\t\t\tsmartUpdateQueue[ smartUpdateQueue.length ] = dependant;\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdumbUpdateQueue[ dumbUpdateQueue.length ] = dependant;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tprocessRoots( array._ractive.roots );\r\n\t};\r\n\r\n\r\n\r\n\r\n\r\n\t\t\r\n\tWrappedArrayProto = [];\r\n\tmutatorMethods = [ 'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift' ];\r\n\r\n\tmutatorMethods.forEach( function ( methodName ) {\r\n\t\tvar method = function () {\r\n\t\t\tvar result = Array.prototype[ methodName ].apply( this, arguments );\r\n\r\n\t\t\tthis._ractive.setting = true;\r\n\t\t\tnotifyArrayDependants( this, methodName, arguments );\r\n\t\t\tthis._ractive.setting = false;\r\n\r\n\t\t\treturn result;\r\n\t\t};\r\n\r\n\t\tdefineProperty( WrappedArrayProto, methodName, {\r\n\t\t\tvalue: method\r\n\t\t});\r\n\t});\r\n\r\n\t\r\n\t// can we use prototype chain injection?\r\n\t// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection\r\n\ttestObj = {};\r\n\tif ( testObj.__proto__ ) {\r\n\t\t// yes, we can\r\n\t\twrapArray = function ( array ) {\r\n\t\t\tarray.__proto__ = WrappedArrayProto;\r\n\t\t};\r\n\r\n\t\tunwrapArray = function ( array ) {\r\n\t\t\tdelete array._ractive;\r\n\t\t\tarray.__proto__ = Array.prototype;\r\n\t\t};\r\n\t}\r\n\r\n\telse {\r\n\t\t// no, we can't\r\n\t\twrapArray = function ( array ) {\r\n\t\t\tvar i, methodName;\r\n\r\n\t\t\ti = mutatorMethods.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tmethodName = mutatorMethods[i];\r\n\t\t\t\tdefineProperty( array, methodName, {\r\n\t\t\t\t\tvalue: WrappedArrayProto[ methodName ],\r\n\t\t\t\t\tconfigurable: true\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tunwrapArray = function ( array ) {\r\n\t\t\tvar i;\r\n\r\n\t\t\ti = mutatorMethods.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tdelete array[ mutatorMethods[i] ];\r\n\t\t\t}\r\n\r\n\t\t\tdelete array._ractive;\r\n\t\t};\r\n\t}\r\n\r\n}());\r\n(function () {\r\n\r\n\tvar MagicWrapper;\r\n\r\n\tadaptors.magic = {\r\n\t\twrap: function ( ractive, object, keypath ) {\r\n\t\t\treturn new MagicWrapper( ractive, object, keypath );\r\n\t\t}\r\n\t};\r\n\r\n\tMagicWrapper = function ( ractive, object, keypath ) {\r\n\t\tvar wrapper = this, keys, prop, objKeypath, descriptor, wrappers, oldGet, oldSet, get, set;\r\n\r\n\t\tthis.ractive = ractive;\r\n\t\tthis.keypath = keypath;\r\n\r\n\t\tkeys = keypath.split( '.' );\r\n\t\t\r\n\t\tthis.prop = keys.pop();\r\n\t\t\r\n\t\tobjKeypath = keys.join( '.' );\r\n\t\tthis.obj = ractive.get( objKeypath );\r\n\r\n\t\tdescriptor = this.originalDescriptor = Object.getOwnPropertyDescriptor( this.obj, this.prop );\r\n\r\n\t\t// Has this property already been wrapped?\r\n\t\tif ( descriptor && descriptor.set && ( wrappers = descriptor.set._ractiveWrappers ) ) {\r\n\t\t\r\n\t\t\t// Yes. Register this wrapper to this property, if it hasn't been already\r\n\t\t\tif ( wrappers.indexOf( this ) === -1 ) {\r\n\t\t\t\twrappers[ wrappers.length ] = this;\r\n\t\t\t}\r\n\r\n\t\t\treturn; // already wrapped\r\n\t\t}\r\n\r\n\r\n\t\t// No, it hasn't been wrapped. Is this descriptor configurable?\r\n\t\tif ( descriptor && !descriptor.configurable ) {\r\n\t\t\tthrow new Error( 'Cannot use magic mode with property \"' + prop + '\" - object is not configurable' );\r\n\t\t}\r\n\r\n\r\n\t\t// Time to wrap this property\r\n\t\tif ( descriptor ) {\r\n\t\t\tthis.value = descriptor.value;\r\n\r\n\t\t\toldGet = descriptor.get;\r\n\t\t\toldSet = descriptor.set;\r\n\t\t}\r\n\t\t\r\n\t\tget = oldGet || function () {\r\n\t\t\treturn wrapper.value; // whichever wrapper got there first!\r\n\t\t};\r\n\r\n\t\tset = function ( value ) {\r\n\t\t\tvar wrappers, wrapper, i;\r\n\r\n\t\t\tif ( oldSet ) {\r\n\t\t\t\toldSet( value );\r\n\t\t\t}\r\n\r\n\t\t\twrappers = set._ractiveWrappers;\r\n\r\n\t\t\ti = wrappers.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\twrapper = wrappers[i];\r\n\t\t\t\t\r\n\t\t\t\tif ( !wrapper.resetting ) {\r\n\t\t\t\t\twrapper.ractive.set( wrapper.keypath, value );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// Create an array of wrappers, in case other keypaths/ractives depend on this property.\r\n\t\t// Handily, we can store them as a property of the set function. Yay JavaScript.\r\n\t\tset._ractiveWrappers = [ this ];\r\n\r\n\t\tObject.defineProperty( this.obj, this.prop, { get: get, set: set, enumerable: true, configurable: true });\r\n\t};\r\n\r\n\tMagicWrapper.prototype = {\r\n\t\tget: function () {\r\n\t\t\treturn this.value;\r\n\t\t},\r\n\t\treset: function ( value ) {\r\n\t\t\tthis.resetting = true;\r\n\t\t\tthis.value = value;\r\n\t\t\tthis.obj[ this.prop ] = value;\r\n\t\t\tthis.resetting = false;\r\n\t\t},\r\n\t\tteardown: function () {\r\n\t\t\tvar descriptor, set, value, wrappers;\r\n\r\n\t\t\tdescriptor = Object.getOwnPropertyDescriptor( this.obj, this.prop );\r\n\t\t\tset = descriptor.set;\r\n\t\t\twrappers = set._ractiveWrappers;\r\n\r\n\t\t\twrappers.splice( wrappers.indexOf( this ), 1 );\r\n\r\n\t\t\t// Last one out, turn off the lights\r\n\t\t\tif ( !wrappers.length ) {\r\n\t\t\t\tvalue = this.obj[ this.prop ];\r\n\r\n\t\t\t\tObject.defineProperty( this.obj, this.prop, this.originalDescriptor );\r\n\t\t\t\tthis.obj[ this.prop ] = value;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n}());\r\n// These are a subset of the easing equations found at\r\n// https://raw.github.com/danro/easing-js - license info\r\n// follows:\r\n\r\n// --------------------------------------------------\r\n// easing.js v0.5.4\r\n// Generic set of easing functions with AMD support\r\n// https://github.com/danro/easing-js\r\n// This code may be freely distributed under the MIT license\r\n// http://danro.mit-license.org/\r\n// --------------------------------------------------\r\n// All functions adapted from Thomas Fuchs & Jeremy Kahn\r\n// Easing Equations (c) 2003 Robert Penner, BSD license\r\n// https://raw.github.com/danro/easing-js/master/LICENSE\r\n// --------------------------------------------------\r\n\r\n// In that library, the functions named easeIn, easeOut, and\r\n// easeInOut below are named easeInCubic, easeOutCubic, and\r\n// (you guessed it) easeInOutCubic.\r\n//\r\n// You can add additional easing functions to this list, and they\r\n// will be globally available.\r\n\r\neasing = {\r\n\tlinear: function ( pos ) { return pos; },\r\n\teaseIn: function ( pos ) { return Math.pow( pos, 3 ); },\r\n\teaseOut: function ( pos ) { return ( Math.pow( ( pos - 1 ), 3 ) + 1 ); },\r\n\teaseInOut: function ( pos ) {\r\n\t\tif ( ( pos /= 0.5 ) < 1 ) { return ( 0.5 * Math.pow( pos, 3 ) ); }\r\n\t\treturn ( 0.5 * ( Math.pow( ( pos - 2 ), 3 ) + 2 ) );\r\n\t}\r\n};\r\neventDefinitions.hover = function ( node, fire ) {\r\n\tvar mouseoverHandler, mouseoutHandler;\r\n\r\n\tmouseoverHandler = function ( event ) {\r\n\t\tif ( node.contains( event.relatedTarget ) ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfire({\r\n\t\t\tnode: node,\r\n\t\t\toriginal: event,\r\n\t\t\thover: true\r\n\t\t});\r\n\t};\r\n\r\n\tmouseoutHandler = function ( event ) {\r\n\t\tif ( node.contains( event.relatedTarget ) ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tfire({\r\n\t\t\tnode: node,\r\n\t\t\toriginal: event,\r\n\t\t\thover: false\r\n\t\t});\r\n\t};\r\n\r\n\tnode.addEventListener( 'mouseover', mouseoverHandler, false );\r\n\tnode.addEventListener( 'mouseout', mouseoutHandler, false );\r\n\r\n\treturn {\r\n\t\tteardown: function () {\r\n\t\t\tnode.removeEventListener( 'mouseover', mouseoverHandler, false );\r\n\t\t\tnode.removeEventListener( 'mouseout', mouseoutHandler, false );\r\n\t\t}\r\n\t};\r\n};\r\n(function () {\r\n\r\n\tvar makeKeyDefinition = function ( code ) {\r\n\t\treturn function ( node, fire ) {\r\n\t\t\tvar keydownHandler;\r\n\r\n\t\t\tnode.addEventListener( 'keydown', keydownHandler = function ( event ) {\r\n\t\t\t\tvar which = event.which || event.keyCode;\r\n\r\n\t\t\t\tif ( which === code ) {\r\n\t\t\t\t\tevent.preventDefault();\r\n\r\n\t\t\t\t\tfire({\r\n\t\t\t\t\t\tnode: node,\r\n\t\t\t\t\t\toriginal: event\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}, false );\r\n\r\n\t\t\treturn {\r\n\t\t\t\tteardown: function () {\r\n\t\t\t\t\tnode.removeEventListener( 'keydown', keydownHandler, false );\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t};\r\n\t};\r\n\r\n\teventDefinitions.enter = makeKeyDefinition( 13 );\r\n\teventDefinitions.tab = makeKeyDefinition( 9 );\r\n\teventDefinitions.escape = makeKeyDefinition( 27 );\r\n\teventDefinitions.space = makeKeyDefinition( 32 );\r\n\r\n\teventDefinitions.leftarrow = makeKeyDefinition( 37 );\r\n\teventDefinitions.rightarrow = makeKeyDefinition( 39 );\r\n\teventDefinitions.downarrow = makeKeyDefinition( 40 );\r\n\teventDefinitions.uparrow = makeKeyDefinition( 38 );\r\n\r\n}());\r\neventDefinitions.tap = function ( node, fire ) {\r\n\tvar mousedown, touchstart, focusHandler, distanceThreshold, timeThreshold;\r\n\r\n\tdistanceThreshold = 5; // maximum pixels pointer can move before cancel\r\n\ttimeThreshold = 400;   // maximum milliseconds between down and up before cancel\r\n\r\n\tmousedown = function ( event ) {\r\n\t\tvar currentTarget, x, y, pointerId, up, move, cancel;\r\n\r\n\t\tif ( event.which !== undefined && event.which !== 1 ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tx = event.clientX;\r\n\t\ty = event.clientY;\r\n\t\tcurrentTarget = this;\r\n\t\t// This will be null for mouse events.\r\n\t\tpointerId = event.pointerId;\r\n\r\n\t\tup = function ( event ) {\r\n\t\t\tif ( event.pointerId != pointerId ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tfire({\r\n\t\t\t\tnode: currentTarget,\r\n\t\t\t\toriginal: event\r\n\t\t\t});\r\n\r\n\t\t\tcancel();\r\n\t\t};\r\n\r\n\t\tmove = function ( event ) {\r\n\t\t\tif ( event.pointerId != pointerId ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif ( ( Math.abs( event.clientX - x ) >= distanceThreshold ) || ( Math.abs( event.clientY - y ) >= distanceThreshold ) ) {\r\n\t\t\t\tcancel();\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tcancel = function () {\r\n\t\t\tnode.removeEventListener( 'MSPointerUp', up, false );\r\n\t\t\tdoc.removeEventListener( 'MSPointerMove', move, false );\r\n\t\t\tdoc.removeEventListener( 'MSPointerCancel', cancel, false );\r\n\t\t\tnode.removeEventListener( 'pointerup', up, false );\r\n\t\t\tdoc.removeEventListener( 'pointermove', move, false );\r\n\t\t\tdoc.removeEventListener( 'pointercancel', cancel, false );\r\n\t\t\tnode.removeEventListener( 'click', up, false );\r\n\t\t\tdoc.removeEventListener( 'mousemove', move, false );\r\n\t\t};\r\n\r\n\t\tif ( window.navigator.pointerEnabled ) {\r\n\t\t\tnode.addEventListener( 'pointerup', up, false );\r\n\t\t\tdoc.addEventListener( 'pointermove', move, false );\r\n\t\t\tdoc.addEventListener( 'pointercancel', cancel, false );\r\n\t\t} else if ( window.navigator.msPointerEnabled ) {\r\n\t\t\tnode.addEventListener( 'MSPointerUp', up, false );\r\n\t\t\tdoc.addEventListener( 'MSPointerMove', move, false );\r\n\t\t\tdoc.addEventListener( 'MSPointerCancel', cancel, false );\r\n\t\t} else {\r\n\t\t\tnode.addEventListener( 'click', up, false );\r\n\t\t\tdoc.addEventListener( 'mousemove', move, false );\r\n\t\t}\r\n\r\n\t\tsetTimeout( cancel, timeThreshold );\r\n\t};\r\n\r\n\tif ( window.navigator.pointerEnabled ) {\r\n\t\tnode.addEventListener( 'pointerdown', mousedown, false );\r\n\t} else if ( window.navigator.msPointerEnabled ) {\r\n\t\tnode.addEventListener( 'MSPointerDown', mousedown, false );\r\n\t} else {\r\n\t\tnode.addEventListener( 'mousedown', mousedown, false );\r\n\t}\r\n\r\n\r\n\ttouchstart = function ( event ) {\r\n\t\tvar currentTarget, x, y, touch, finger, move, up, cancel;\r\n\r\n\t\tif ( event.touches.length !== 1 ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\ttouch = event.touches[0];\r\n\r\n\t\tx = touch.clientX;\r\n\t\ty = touch.clientY;\r\n\t\tcurrentTarget = this;\r\n\r\n\t\tfinger = touch.identifier;\r\n\r\n\t\tup = function ( event ) {\r\n\t\t\tvar touch;\r\n\r\n\t\t\ttouch = event.changedTouches[0];\r\n\t\t\tif ( touch.identifier !== finger ) {\r\n\t\t\t\tcancel();\r\n\t\t\t}\r\n\r\n\t\t\tevent.preventDefault();  // prevent compatibility mouse event\r\n\t\t\tfire({\r\n\t\t\t\tnode: currentTarget,\r\n\t\t\t\toriginal: event\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tcancel();\r\n\t\t};\r\n\r\n\t\tmove = function ( event ) {\r\n\t\t\tvar touch;\r\n\r\n\t\t\tif ( event.touches.length !== 1 || event.touches[0].identifier !== finger ) {\r\n\t\t\t\tcancel();\r\n\t\t\t}\r\n\r\n\t\t\ttouch = event.touches[0];\r\n\t\t\tif ( ( Math.abs( touch.clientX - x ) >= distanceThreshold ) || ( Math.abs( touch.clientY - y ) >= distanceThreshold ) ) {\r\n\t\t\t\tcancel();\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tcancel = function () {\r\n\t\t\tnode.removeEventListener( 'touchend', up, false );\r\n\t\t\twindow.removeEventListener( 'touchmove', move, false );\r\n\t\t\twindow.removeEventListener( 'touchcancel', cancel, false );\r\n\t\t};\r\n\r\n\t\tnode.addEventListener( 'touchend', up, false );\r\n\t\twindow.addEventListener( 'touchmove', move, false );\r\n\t\twindow.addEventListener( 'touchcancel', cancel, false );\r\n\r\n\t\tsetTimeout( cancel, timeThreshold );\r\n\t};\r\n\r\n\tnode.addEventListener( 'touchstart', touchstart, false );\r\n\r\n\r\n\t// native buttons, and <input type='button'> elements, should fire a tap event\r\n\t// when the space key is pressed\r\n\tif ( node.tagName === 'BUTTON' || node.type === 'button' ) {\r\n\t\tfocusHandler = function () {\r\n\t\t\tvar blurHandler, keydownHandler;\r\n\r\n\t\t\tkeydownHandler = function ( event ) {\r\n\t\t\t\tif ( event.which === 32 ) { // space key\r\n\t\t\t\t\tfire({\r\n\t\t\t\t\t\tnode: node,\r\n\t\t\t\t\t\toriginal: event\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tblurHandler = function () {\r\n\t\t\t\tnode.removeEventListener( 'keydown', keydownHandler, false );\r\n\t\t\t\tnode.removeEventListener( 'blur', blurHandler, false );\r\n\t\t\t};\r\n\r\n\t\t\tnode.addEventListener( 'keydown', keydownHandler, false );\r\n\t\t\tnode.addEventListener( 'blur', blurHandler, false );\r\n\t\t};\r\n\r\n\t\tnode.addEventListener( 'focus', focusHandler, false );\r\n\t}\r\n\r\n\r\n\treturn {\r\n\t\tteardown: function () {\r\n\t\t\tnode.removeEventListener( 'pointerdown', mousedown, false );\r\n\t\t\tnode.removeEventListener( 'MSPointerDown', mousedown, false );\r\n\t\t\tnode.removeEventListener( 'mousedown', mousedown, false );\r\n\t\t\tnode.removeEventListener( 'touchstart', touchstart, false );\r\n\t\t\tnode.removeEventListener( 'focus', focusHandler, false );\r\n\t\t}\r\n\t};\r\n};\r\n\r\n(function () {\r\n\r\n\tvar fillGaps,\r\n\t\tclone,\r\n\t\taugment,\r\n\r\n\t\tinheritFromParent,\r\n\t\twrapMethod,\r\n\t\tinheritFromChildProps,\r\n\t\tconditionallyParseTemplate,\r\n\t\textractInlinePartials,\r\n\t\tconditionallyParsePartials,\r\n\t\tinitChildInstance,\r\n\r\n\t\textendable,\r\n\t\tinheritable,\r\n\t\tblacklist;\r\n\r\n\textend = function ( childProps ) {\r\n\r\n\t\tvar Parent = this, Child;\r\n\r\n\t\t// create Child constructor\r\n\t\tChild = function ( options ) {\r\n\t\t\tinitChildInstance( this, Child, options || {});\r\n\t\t};\r\n\r\n\t\tChild.prototype = create( Parent.prototype );\r\n\r\n\t\t// inherit options from parent, if we're extending a subclass\r\n\t\tif ( Parent !== Ractive ) {\r\n\t\t\tinheritFromParent( Child, Parent );\r\n\t\t}\r\n\r\n\t\t// apply childProps\r\n\t\tinheritFromChildProps( Child, childProps );\r\n\r\n\t\t// parse template and any partials that need it\r\n\t\tconditionallyParseTemplate( Child );\r\n\t\textractInlinePartials( Child, childProps );\r\n\t\tconditionallyParsePartials( Child );\r\n\t\t\r\n\t\tChild.extend = Parent.extend;\r\n\r\n\t\treturn Child;\r\n\t};\r\n\r\n\textendable = [ 'data', 'partials', 'transitions', 'eventDefinitions', 'components' ];\r\n\tinheritable = [ 'el', 'template', 'complete', 'modifyArrays', 'twoway', 'lazy', 'append', 'preserveWhitespace', 'sanitize', 'noIntro', 'transitionsEnabled' ];\r\n\tblacklist = extendable.concat( inheritable );\r\n\r\n\tinheritFromParent = function ( Child, Parent ) {\r\n\t\textendable.forEach( function ( property ) {\r\n\t\t\tif ( Parent[ property ] ) {\r\n\t\t\t\tChild[ property ] = clone( Parent[ property ] );\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tinheritable.forEach( function ( property ) {\r\n\t\t\tif ( Parent[ property ] !== undefined ) {\r\n\t\t\t\tChild[ property ] = Parent[ property ];\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\r\n\twrapMethod = function ( method, superMethod ) {\r\n\t\tif ( /_super/.test( method ) ) {\r\n\t\t\treturn function () {\r\n\t\t\t\tvar _super = this._super, result;\r\n\t\t\t\tthis._super = superMethod;\r\n\r\n\t\t\t\tresult = method.apply( this, arguments );\r\n\r\n\t\t\t\tthis._super = _super;\r\n\t\t\t\treturn result;\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\telse {\r\n\t\t\treturn method;\r\n\t\t}\r\n\t};\r\n\r\n\tinheritFromChildProps = function ( Child, childProps ) {\r\n\t\tvar key, member;\r\n\r\n\t\textendable.forEach( function ( property ) {\r\n\t\t\tvar value = childProps[ property ];\r\n\r\n\t\t\tif ( value ) {\r\n\t\t\t\tif ( Child[ property ] ) {\r\n\t\t\t\t\taugment( Child[ property ], value );\r\n\t\t\t\t}\r\n\r\n\t\t\t\telse {\r\n\t\t\t\t\tChild[ property ] = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tinheritable.forEach( function ( property ) {\r\n\t\t\tif ( childProps[ property ] !== undefined ) {\r\n\t\t\t\tChild[ property ] = childProps[ property ];\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Blacklisted properties don't extend the child, as they are part of the initialisation options\r\n\t\tfor ( key in childProps ) {\r\n\t\t\tif ( hasOwn.call( childProps, key ) && !hasOwn.call( Child.prototype, key ) && blacklist.indexOf( key ) === -1 ) {\r\n\t\t\t\tmember = childProps[ key ];\r\n\r\n\t\t\t\t// if this is a method that overwrites a prototype method, we may need\r\n\t\t\t\t// to wrap it\r\n\t\t\t\tif ( typeof member === 'function' && typeof Child.prototype[ key ] === 'function' ) {\r\n\t\t\t\t\tChild.prototype[ key ] = wrapMethod( member, Child.prototype[ key ] );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tChild.prototype[ key ] = member;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tconditionallyParseTemplate = function ( Child ) {\r\n\t\tvar templateEl;\r\n\r\n\t\tif ( typeof Child.template === 'string' ) {\r\n\t\t\tif ( !Ractive.parse ) {\r\n\t\t\t\tthrow new Error( missingParser );\r\n\t\t\t}\r\n\r\n\t\t\tif ( Child.template.charAt( 0 ) === '#' && doc ) {\r\n\t\t\t\ttemplateEl = doc.getElementById( Child.template.substring( 1 ) );\r\n\t\t\t\tif ( templateEl && templateEl.tagName === 'SCRIPT' ) {\r\n\t\t\t\t\tChild.template = Ractive.parse( templateEl.innerHTML, Child );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error( 'Could not find template element (' + Child.template + ')' );\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tChild.template = Ractive.parse( Child.template, Child ); // all the relevant options are on Child\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\textractInlinePartials = function ( Child, childProps ) {\r\n\t\t// does our template contain inline partials?\r\n\t\tif ( isObject( Child.template ) ) {\r\n\t\t\tif ( !Child.partials ) {\r\n\t\t\t\tChild.partials = {};\r\n\t\t\t}\r\n\r\n\t\t\t// get those inline partials\r\n\t\t\taugment( Child.partials, Child.template.partials );\r\n\r\n\t\t\t// but we also need to ensure that any explicit partials override inline ones\r\n\t\t\tif ( childProps.partials ) {\r\n\t\t\t\taugment( Child.partials, childProps.partials );\r\n\t\t\t}\r\n\r\n\t\t\t// move template to where it belongs\r\n\t\t\tChild.template = Child.template.main;\r\n\t\t}\r\n\t};\r\n\r\n\tconditionallyParsePartials = function ( Child ) {\r\n\t\tvar key, partial;\r\n\r\n\t\t// Parse partials, if necessary\r\n\t\tif ( Child.partials ) {\r\n\t\t\tfor ( key in Child.partials ) {\r\n\t\t\t\tif ( hasOwn.call( Child.partials, key ) ) {\r\n\t\t\t\t\tif ( typeof Child.partials[ key ] === 'string' ) {\r\n\t\t\t\t\t\tif ( !Ractive.parse ) {\r\n\t\t\t\t\t\t\tthrow new Error( missingParser );\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tpartial = Ractive.parse( Child.partials[ key ], Child );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tpartial = Child.partials[ key ];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tChild.partials[ key ] = partial;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tinitChildInstance = function ( child, Child, options ) {\r\n\t\t\r\n\t\t// Add template to options, if necessary\r\n\t\tif ( !options.template && Child.template ) {\r\n\t\t\toptions.template = Child.template;\r\n\t\t}\r\n\r\n\t\textendable.forEach( function ( property ) {\r\n\t\t\tif ( !options[ property ] ) {\r\n\t\t\t\tif ( Child[ property ] ) {\r\n\t\t\t\t\toptions[ property ] = clone( Child[ property ] );\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfillGaps( options[ property ], Child[ property ] );\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\tinheritable.forEach( function ( property ) {\r\n\t\t\tif ( options[ property ] === undefined && Child[ property ] !== undefined ) {\r\n\t\t\t\toptions[ property ] = Child[ property ];\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tif ( child.beforeInit ) {\r\n\t\t\tchild.beforeInit.call( child, options );\r\n\t\t}\r\n\r\n\t\tRactive.call( child, options );\r\n\r\n\t\tif ( child.init ) {\r\n\t\t\tchild.init.call( child, options );\r\n\t\t}\r\n\t};\r\n\r\n\tfillGaps = function ( target, source ) {\r\n\t\tvar key;\r\n\r\n\t\tfor ( key in source ) {\r\n\t\t\tif ( hasOwn.call( source, key ) && !hasOwn.call( target, key ) ) {\r\n\t\t\t\ttarget[ key ] = source[ key ];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tclone = function ( source ) {\r\n\t\tvar target = {}, key;\r\n\r\n\t\tfor ( key in source ) {\r\n\t\t\tif ( hasOwn.call( source, key ) ) {\r\n\t\t\t\ttarget[ key ] = source[ key ];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn target;\r\n\t};\r\n\r\n\taugment = function ( target, source ) {\r\n\t\tvar key;\r\n\r\n\t\tfor ( key in source ) {\r\n\t\t\tif ( hasOwn.call( source, key ) ) {\r\n\t\t\t\ttarget[ key ] = source[ key ];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n}());\r\n// TODO short circuit values that stay the same\r\ninterpolate = function ( from, to ) {\r\n\tif ( isNumeric( from ) && isNumeric( to ) ) {\r\n\t\treturn Ractive.interpolators.number( +from, +to );\r\n\t}\r\n\r\n\tif ( isArray( from ) && isArray( to ) ) {\r\n\t\treturn Ractive.interpolators.array( from, to );\r\n\t}\r\n\r\n\tif ( isObject( from ) && isObject( to ) ) {\r\n\t\treturn Ractive.interpolators.object( from, to );\r\n\t}\r\n\r\n\treturn function () { return to; };\r\n};\r\ninterpolators = {\r\n\tnumber: function ( from, to ) {\r\n\t\tvar delta = to - from;\r\n\r\n\t\tif ( !delta ) {\r\n\t\t\treturn function () { return from; };\r\n\t\t}\r\n\r\n\t\treturn function ( t ) {\r\n\t\t\treturn from + ( t * delta );\r\n\t\t};\r\n\t},\r\n\r\n\tarray: function ( from, to ) {\r\n\t\tvar intermediate, interpolators, len, i;\r\n\r\n\t\tintermediate = [];\r\n\t\tinterpolators = [];\r\n\r\n\t\ti = len = Math.min( from.length, to.length );\r\n\t\twhile ( i-- ) {\r\n\t\t\tinterpolators[i] = Ractive.interpolate( from[i], to[i] );\r\n\t\t}\r\n\r\n\t\t// surplus values - don't interpolate, but don't exclude them either\r\n\t\tfor ( i=len; i<from.length; i+=1 ) {\r\n\t\t\tintermediate[i] = from[i];\r\n\t\t}\r\n\r\n\t\tfor ( i=len; i<to.length; i+=1 ) {\r\n\t\t\tintermediate[i] = to[i];\r\n\t\t}\r\n\r\n\t\treturn function ( t ) {\r\n\t\t\tvar i = len;\r\n\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tintermediate[i] = interpolators[i]( t );\r\n\t\t\t}\r\n\r\n\t\t\treturn intermediate;\r\n\t\t};\r\n\t},\r\n\r\n\tobject: function ( from, to ) {\r\n\t\tvar properties = [], len, interpolators, intermediate, prop;\r\n\r\n\t\tintermediate = {};\r\n\t\tinterpolators = {};\r\n\r\n\t\tfor ( prop in from ) {\r\n\t\t\tif ( hasOwn.call( from, prop ) ) {\r\n\t\t\t\tif ( hasOwn.call( to, prop ) ) {\r\n\t\t\t\t\tproperties[ properties.length ] = prop;\r\n\t\t\t\t\tinterpolators[ prop ] = Ractive.interpolate( from[ prop ], to[ prop ] );\r\n\t\t\t\t}\r\n\r\n\t\t\t\telse {\r\n\t\t\t\t\tintermediate[ prop ] = from[ prop ];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor ( prop in to ) {\r\n\t\t\tif ( hasOwn.call( to, prop ) && !hasOwn.call( from, prop ) ) {\r\n\t\t\t\tintermediate[ prop ] = to[ prop ];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlen = properties.length;\r\n\r\n\t\treturn function ( t ) {\r\n\t\t\tvar i = len, prop;\r\n\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tprop = properties[i];\r\n\r\n\t\t\t\tintermediate[ prop ] = interpolators[ prop ]( t );\r\n\t\t\t}\r\n\r\n\t\t\treturn intermediate;\r\n\t\t};\r\n\t}\r\n};\r\nvar defaultOptions = createFromNull(), getObject, getArray;\r\n\r\ngetObject = function () { return {}; };\r\ngetArray = function () { return []; };\r\n\r\ndefineProperties( defaultOptions, {\r\n\tpreserveWhitespace: { enumerable: true, value: false     },\r\n\tappend:             { enumerable: true, value: false     },\r\n\ttwoway:             { enumerable: true, value: true      },\r\n\tmodifyArrays:       { enumerable: true, value: true      },\r\n\tdata:               { enumerable: true, value: getObject },\r\n\tlazy:               { enumerable: true, value: false     },\r\n\tdebug:              { enumerable: true, value: false     },\r\n\ttransitions:        { enumerable: true, value: getObject },\r\n\teventDefinitions:   { enumerable: true, value: getObject },\r\n\tnoIntro:            { enumerable: true, value: false     },\r\n\ttransitionsEnabled: { enumerable: true, value: true      },\r\n\tmagic:              { enumerable: true, value: false     },\r\n\tadaptors:           { enumerable: true, value: getArray  }\r\n});\r\n\r\nRactive = function ( options ) {\r\n\r\n\tvar key, template, templateEl, parsedTemplate;\r\n\r\n\t// Options\r\n\t// -------\r\n\tfor ( key in defaultOptions ) {\r\n\t\tif ( options[ key ] === undefined ) {\r\n\t\t\toptions[ key ] = ( typeof defaultOptions[ key ] === 'function' ? defaultOptions[ key ]() : defaultOptions[ key ] );\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// Initialization\r\n\t// --------------\r\n\r\n\t// We use Object.defineProperties (where possible) as these should be read-only\r\n\tdefineProperties( this, {\r\n\t\t// Generate a unique identifier, for places where you'd use a weak map if it\r\n\t\t// existed\r\n\t\t_guid: {\r\n\t\t\tvalue: 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\r\n\t\t\t\tvar r, v;\r\n\r\n\t\t\t\tr = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\r\n\t\t\t\treturn v.toString(16);\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\t// events\r\n\t\t_subs: { value: createFromNull() },\r\n\r\n\t\t// cache\r\n\t\t_cache: { value: {} }, // we need to be able to use hasOwnProperty, so can't inherit from null\r\n\t\t_cacheMap: { value: createFromNull() },\r\n\r\n\t\t// dependency graph\r\n\t\t_deps: { value: [] },\r\n\t\t_depsMap: { value: createFromNull() },\r\n\r\n\t\t// unresolved dependants\r\n\t\t_pendingResolution: { value: [] },\r\n\r\n\t\t// Create arrays for deferred attributes and evaluators\r\n\t\t_defAttrs: { value: [] },\r\n\t\t_defEvals: { value: [] },\r\n\t\t_defSelectValues: { value: [] },\r\n\t\t_defCheckboxes: { value: [] },\r\n\t\t_defRadios: { value: [] },\r\n\t\t_defObservers: { value: [] },\r\n\r\n\t\t// Keep a list of used evaluators, so we don't duplicate them\r\n\t\t_evaluators: { value: createFromNull() },\r\n\r\n\t\t// two-way bindings\r\n\t\t_twowayBindings: { value: {} },\r\n\r\n\t\t// transition manager\r\n\t\t_transitionManager: { value: null, writable: true },\r\n\r\n\t\t// animations (so we can stop any in progress at teardown)\r\n\t\t_animations: { value: [] },\r\n\r\n\t\t// nodes registry\r\n\t\tnodes: { value: {} },\r\n\r\n\t\t// property wrappers\r\n\t\t_wrapped: { value: createFromNull() }\r\n\t});\r\n\r\n\t// options\r\n\tthis.modifyArrays = options.modifyArrays;\r\n\tthis.magic = options.magic;\r\n\tthis.twoway = options.twoway;\r\n\tthis.lazy = options.lazy;\r\n\tthis.debug = options.debug;\r\n\r\n\tif ( this.magic && noMagic ) {\r\n\t\tthrow new Error( 'Getters and setters (magic mode) are not supported in this browser' );\r\n\t}\r\n\r\n\tif ( options.el ) {\r\n\t\tthis.el = getEl( options.el );\r\n\t\tif ( !this.el && this.debug ) {\r\n\t\t\tthrow new Error( 'Could not find container element' );\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tthis.data = options.data;\r\n\t\r\n\r\n\t// Components registry\r\n\tthis.components = options.components || {};\r\n\r\n\t// Transition registry\r\n\tthis.transitions = options.transitions;\r\n\r\n\t// Instance-specific event definitions registry\r\n\tthis.eventDefinitions = options.eventDefinitions;\r\n\r\n\t// Adaptors\r\n\tthis.adaptors = options.adaptors;\r\n\r\n\r\n\t// Parse template, if necessary\r\n\ttemplate = options.template;\r\n\r\n\t\r\n\tif ( typeof template === 'string' ) {\r\n\t\tif ( !Ractive.parse ) {\r\n\t\t\tthrow new Error( missingParser );\r\n\t\t}\r\n\r\n\t\tif ( template.charAt( 0 ) === '#' && doc ) {\r\n\t\t\t// assume this is an ID of a <script type='text/ractive'> tag\r\n\t\t\ttemplateEl = doc.getElementById( template.substring( 1 ) );\r\n\t\t\tif ( templateEl ) {\r\n\t\t\t\tparsedTemplate = Ractive.parse( templateEl.innerHTML, options );\r\n\t\t\t}\r\n\r\n\t\t\telse {\r\n\t\t\t\tthrow new Error( 'Could not find template element (' + template + ')' );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\telse {\r\n\t\t\tparsedTemplate = Ractive.parse( template, options );\r\n\t\t}\r\n\t} else {\r\n\t\tparsedTemplate = template;\r\n\t}\r\n\r\n\t// deal with compound template\r\n\tif ( isObject( parsedTemplate ) ) {\r\n\t\tthis.partials = parsedTemplate.partials;\r\n\t\tparsedTemplate = parsedTemplate.main;\r\n\t} else {\r\n\t\tthis.partials = {};\r\n\t}\r\n\r\n\t// If the template was an array with a single string member, that means\r\n\t// we can use innerHTML - we just need to unpack it\r\n\tif ( parsedTemplate && ( parsedTemplate.length === 1 ) && ( typeof parsedTemplate[0] === 'string' ) ) {\r\n\t\tparsedTemplate = parsedTemplate[0];\r\n\t}\r\n\r\n\tthis.template = parsedTemplate;\r\n\r\n\t// Add partials to our registry\r\n\tif ( options.partials ) {\r\n\t\tfor ( key in options.partials ) {\r\n\t\t\tif ( hasOwn.call( options.partials, key ) ) {\r\n\t\t\t\tthis.partials[ key ] = options.partials[ key ];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tthis.parseOptions = {\r\n\t\tpreserveWhitespace: options.preserveWhitespace,\r\n\t\tsanitize: options.sanitize\r\n\t};\r\n\r\n\r\n\t\r\n\t// temporarily disable transitions, if noIntro flag is set\r\n\tthis.transitionsEnabled = ( options.noIntro ? false : options.transitionsEnabled );\r\n\r\n\trender( this, { el: this.el, append: options.append, complete: options.complete });\r\n\r\n\t// reset transitionsEnabled\r\n\tthis.transitionsEnabled = options.transitionsEnabled;\r\n};\r\n\r\n(function () {\r\n\r\n\tvar getOriginalComputedStyles, setStyle, augment, makeTransition;\r\n\r\n\t// no point executing this code on the server\r\n\tif ( !doc ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tgetOriginalComputedStyles = function ( computedStyle, properties ) {\r\n\t\tvar original = {}, i;\r\n\r\n\t\ti = properties.length;\r\n\t\twhile ( i-- ) {\r\n\t\t\toriginal[ properties[i] ] = computedStyle[ properties[i] ];\r\n\t\t}\r\n\r\n\t\treturn original;\r\n\t};\r\n\r\n\tsetStyle = function ( node, properties, map, params ) {\r\n\t\tvar i = properties.length, prop;\r\n\r\n\t\twhile ( i-- ) {\r\n\t\t\tprop = properties[i];\r\n\t\t\tif ( map && map[ prop ] ) {\r\n\t\t\t\tif ( typeof map[ prop ] === 'function' ) {\r\n\t\t\t\t\tnode.style[ prop ] = map[ prop ]( params );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnode.style[ prop ] = map[ prop ];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\telse {\r\n\t\t\t\tnode.style[ prop ] = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\taugment = function ( target, source ) {\r\n\t\tvar key;\r\n\r\n\t\tif ( !source ) {\r\n\t\t\treturn target;\r\n\t\t}\r\n\r\n\t\tfor ( key in source ) {\r\n\t\t\tif ( hasOwn.call( source, key ) ) {\r\n\t\t\t\ttarget[ key ] = source[ key ];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn target;\r\n\t};\r\n\r\n\tif ( cssTransitionsEnabled ) {\r\n\t\tmakeTransition = function ( properties, defaults, outside, inside ) {\r\n\t\t\tif ( typeof properties === 'string' ) {\r\n\t\t\t\tproperties = [ properties ];\r\n\t\t\t}\r\n\r\n\t\t\treturn function ( node, complete, params, isIntro ) {\r\n\t\t\t\tvar transitionEndHandler,\r\n\t\t\t\t\tcomputedStyle,\r\n\t\t\t\t\toriginalComputedStyles,\r\n\t\t\t\t\tstartTransition,\r\n\t\t\t\t\toriginalStyle,\r\n\t\t\t\t\tduration,\r\n\t\t\t\t\tdelay,\r\n\t\t\t\t\tstart,\r\n\t\t\t\t\tend,\r\n\t\t\t\t\tpositionStyle,\r\n\t\t\t\t\tvisibilityStyle;\r\n\r\n\t\t\t\tparams = parseTransitionParams( params );\r\n\t\t\t\t\r\n\t\t\t\tduration = params.duration || defaults.duration;\r\n\t\t\t\teasing = hyphenate( params.easing || defaults.easing );\r\n\t\t\t\tdelay = params.delay || 0;\r\n\r\n\t\t\t\tstart = ( isIntro ? outside : inside );\r\n\t\t\t\tend = ( isIntro ? inside : outside );\r\n\r\n\t\t\t\tcomputedStyle = window.getComputedStyle( node );\r\n\t\t\t\toriginalStyle = node.getAttribute( 'style' );\r\n\r\n\t\t\t\t// if this is an intro, we need to transition TO the original styles\r\n\t\t\t\tif ( isIntro ) {\r\n\t\t\t\t\t// hide, to avoid flashes\r\n\t\t\t\t\tpositionStyle = node.style.position;\r\n\t\t\t\t\tvisibilityStyle = node.style.visibility;\r\n\t\t\t\t\tnode.style.position = 'absolute';\r\n\t\t\t\t\tnode.style.visibility = 'hidden';\r\n\r\n\t\t\t\t\t// we need to wait a beat before we can actually get values from computedStyle.\r\n\t\t\t\t\t// Yeah, I know, WTF browsers\r\n\t\t\t\t\tsetTimeout( function () {\r\n\t\t\t\t\t\toriginalComputedStyles = getOriginalComputedStyles( computedStyle, properties );\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tstart = outside;\r\n\t\t\t\t\t\tend = augment( originalComputedStyles, inside );\r\n\r\n\t\t\t\t\t\t// starting style\r\n\t\t\t\t\t\tnode.style.position = positionStyle;\r\n\t\t\t\t\t\tnode.style.visibility = visibilityStyle;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tsetStyle( node, properties, start, params );\r\n\r\n\t\t\t\t\t\tsetTimeout( startTransition, 0 );\r\n\t\t\t\t\t}, delay );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// otherwise we need to transition FROM them\r\n\t\t\t\telse {\r\n\t\t\t\t\tsetTimeout( function () {\r\n\t\t\t\t\t\toriginalComputedStyles = getOriginalComputedStyles( computedStyle, properties );\r\n\r\n\t\t\t\t\t\tstart = augment( originalComputedStyles, inside );\r\n\t\t\t\t\t\tend = outside;\r\n\r\n\t\t\t\t\t\t// ending style\r\n\t\t\t\t\t\tsetStyle( node, properties, start, params );\r\n\r\n\t\t\t\t\t\tsetTimeout( startTransition, 0 );\r\n\t\t\t\t\t}, delay );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstartTransition = function () {\r\n\t\t\t\t\tnode.style[ transition + 'Duration' ] = ( duration / 1000 ) + 's';\r\n\t\t\t\t\tnode.style[ transition + 'Properties' ] = properties.map( hyphenate ).join( ',' );\r\n\t\t\t\t\tnode.style[ transition + 'TimingFunction' ] = easing;\r\n\r\n\t\t\t\t\ttransitionEndHandler = function () {\r\n\t\t\t\t\t\tnode.removeEventListener( transitionend, transitionEndHandler, false );\r\n\r\n\t\t\t\t\t\tif ( isIntro ) {\r\n\t\t\t\t\t\t\tnode.setAttribute( 'style', originalStyle || '' );\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcomplete();\r\n\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\tnode.addEventListener( transitionend, transitionEndHandler, false );\r\n\r\n\t\t\t\t\tsetStyle( node, properties, end, params );\r\n\t\t\t\t};\r\n\t\t\t};\r\n\t\t};\r\n\r\n\t\ttransitions.slide = makeTransition([\r\n\t\t\t'height',\r\n\t\t\t'borderTopWidth',\r\n\t\t\t'borderBottomWidth',\r\n\t\t\t'paddingTop',\r\n\t\t\t'paddingBottom',\r\n\t\t\t'overflowY'\r\n\t\t], { duration: 400, easing: 'easeInOut' }, { overflowY: 'hidden' }, { overflowY: 'hidden' });\r\n\r\n\t\ttransitions.fade = makeTransition( 'opacity', {\r\n\t\t\tduration: 300,\r\n\t\t\teasing: 'linear'\r\n\t\t});\r\n\r\n\t\ttransitions.fly = makeTransition([ 'opacity', 'left', 'position' ], {\r\n\t\t\tduration: 400, easing: 'easeOut'\r\n\t\t}, { position: 'relative', left: '-500px' }, { position: 'relative', left: 0 });\r\n\t}\r\n\r\n\t\r\n\r\n}());\r\nvar parseTransitionParams = function ( params ) {\r\n\tif ( params === 'fast' ) {\r\n\t\treturn { duration: 200 };\r\n\t}\r\n\r\n\tif ( params === 'slow' ) {\r\n\t\treturn { duration: 600 };\r\n\t}\r\n\r\n\tif ( isNumeric( params ) ) {\r\n\t\treturn { duration: +params };\r\n\t}\r\n\r\n\treturn params || {};\r\n};\r\n(function ( transitions ) {\r\n\r\n\tvar typewriter, typewriteNode, typewriteTextNode;\r\n\r\n\tif ( !doc ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\ttypewriteNode = function ( node, complete, interval ) {\r\n\t\tvar children, next;\r\n\r\n\t\tif ( node.nodeType === 1 ) {\r\n\t\t\tnode.style.display = node._display;\r\n\t\t}\r\n\r\n\t\tif ( node.nodeType === 3 ) {\r\n\t\t\ttypewriteTextNode( node, complete, interval );\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tchildren = Array.prototype.slice.call( node.childNodes );\r\n\r\n\t\tnext = function () {\r\n\t\t\tif ( !children.length ) {\r\n\t\t\t\tif ( node.nodeType === 1 ) {\r\n\t\t\t\t\tnode.setAttribute( 'style', node._style || '' );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcomplete();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\ttypewriteNode( children.shift(), next, interval );\r\n\t\t};\r\n\r\n\t\tnext();\r\n\t};\r\n\r\n\ttypewriteTextNode = function ( node, complete, interval ) {\r\n\t\tvar str, len, loop, i;\r\n\r\n\t\t// text node\r\n\t\tstr = node._hiddenData;\r\n\t\tlen = str.length;\r\n\r\n\t\tif ( !len ) {\r\n\t\t\tcomplete();\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\ti = 0;\r\n\r\n\t\tloop = setInterval( function () {\r\n\t\t\tvar substr, remaining, match, remainingNonWhitespace, filler;\r\n\r\n\t\t\tsubstr = str.substr( 0, i );\r\n\t\t\tremaining = str.substring( i );\r\n\r\n\t\t\tmatch = /^\\w+/.exec( remaining );\r\n\t\t\tremainingNonWhitespace = ( match ? match[0].length : 0 );\r\n\r\n\t\t\t// add some non-breaking whitespace corresponding to the remaining length of the\r\n\t\t\t// current word (only really works with monospace fonts, but better than nothing)\r\n\t\t\tfiller = new Array( remainingNonWhitespace + 1 ).join( '\\u00a0' );\r\n\r\n\t\t\tnode.data = substr + filler;\r\n\t\t\tif ( i === len ) {\r\n\t\t\t\tclearInterval( loop );\r\n\t\t\t\tdelete node._hiddenData;\r\n\t\t\t\tcomplete();\r\n\t\t\t}\r\n\r\n\t\t\ti += 1;\r\n\t\t}, interval );\r\n\t};\r\n\r\n\t// TODO differentiate between intro and outro\r\n\ttypewriter = function ( node, complete, params ) {\r\n\t\tvar interval, style, computedStyle, hide;\r\n\r\n\t\tparams = parseTransitionParams( params );\r\n\r\n\t\tinterval = params.interval || ( params.speed ? 1000 / params.speed : ( params.duration ? node.textContent.length / params.duration : 4 ) );\r\n\t\t\r\n\t\tstyle = node.getAttribute( 'style' );\r\n\t\tcomputedStyle = window.getComputedStyle( node );\r\n\r\n\t\tnode.style.visibility = 'hidden';\r\n\r\n\t\tsetTimeout( function () {\r\n\t\t\tvar computedHeight, computedWidth, computedVisibility;\r\n\r\n\t\t\tcomputedWidth = computedStyle.width;\r\n\t\t\tcomputedHeight = computedStyle.height;\r\n\t\t\tcomputedVisibility = computedStyle.visibility;\r\n\r\n\t\t\thide( node );\r\n\r\n\t\t\tsetTimeout( function () {\r\n\t\t\t\tnode.style.width = computedWidth;\r\n\t\t\t\tnode.style.height = computedHeight;\r\n\t\t\t\tnode.style.visibility = 'visible';\r\n\r\n\t\t\t\ttypewriteNode( node, function () {\r\n\t\t\t\t\tnode.setAttribute( 'style', style || '' );\r\n\t\t\t\t\tcomplete();\r\n\t\t\t\t}, interval );\r\n\t\t\t}, params.delay || 0 );\r\n\t\t});\r\n\r\n\t\thide = function ( node ) {\r\n\t\t\tvar children, i;\r\n\r\n\t\t\tif ( node.nodeType === 1 ) {\r\n\t\t\t\tnode._style = node.getAttribute( 'style' );\r\n\t\t\t\tnode._display = window.getComputedStyle( node ).display;\r\n\r\n\t\t\t\tnode.style.display = 'none';\r\n\t\t\t}\r\n\r\n\t\t\tif ( node.nodeType === 3 ) {\r\n\t\t\t\tnode._hiddenData = '' + node.data;\r\n\t\t\t\tnode.data = '';\r\n\t\t\t\t\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tchildren = Array.prototype.slice.call( node.childNodes );\r\n\t\t\ti = children.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\thide( children[i] );\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n\r\n\ttransitions.typewriter = typewriter;\r\n\r\n}( transitions ));\r\n(function ( Ractive ) {\r\n\r\n\tvar requestFullscreen, cancelFullscreen, fullscreenElement;\r\n\r\n\tif ( !doc ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tRactive.fullscreenEnabled = doc.fullscreenEnabled || doc.mozFullScreenEnabled || doc.webkitFullscreenEnabled;\r\n\r\n\tif ( !Ractive.fullscreenEnabled ) {\r\n\t\tRactive.requestFullscreen = Ractive.cancelFullscreen = noop;\r\n\t\tRactive.isFullscreen = function () { return false; };\r\n\t\treturn;\r\n\t}\r\n\r\n\t// get prefixed name of requestFullscreen method\r\n\tif ( testDiv.requestFullscreen ) {\r\n\t\trequestFullscreen = 'requestFullscreen';\r\n\t} else if ( testDiv.mozRequestFullScreen ) {\r\n\t\trequestFullscreen = 'mozRequestFullScreen';\r\n\t} else if ( testDiv.webkitRequestFullscreen ) {\r\n\t\trequestFullscreen = 'webkitRequestFullscreen';\r\n\t}\r\n\r\n\tRactive.requestFullscreen = function ( el ) {\r\n\t\tif ( el[ requestFullscreen ] ) {\r\n\t\t\tel[ requestFullscreen ]();\r\n\t\t}\r\n\t};\r\n\r\n\t// get prefixed name of cancelFullscreen method\r\n\tif ( doc.cancelFullscreen ) {\r\n\t\tcancelFullscreen = 'cancelFullscreen';\r\n\t} else if ( doc.mozCancelFullScreen ) {\r\n\t\tcancelFullscreen = 'mozCancelFullScreen';\r\n\t} else if ( doc.webkitCancelFullScreen ) {\r\n\t\tcancelFullscreen = 'webkitCancelFullScreen';\r\n\t}\r\n\r\n\tRactive.cancelFullscreen = function () {\r\n\t\tdoc[ cancelFullscreen ]();\r\n\t};\r\n\r\n\t// get prefixed name of fullscreenElement property\r\n\tif ( doc.fullscreenElement !== undefined ) {\r\n\t\tfullscreenElement = 'fullscreenElement';\r\n\t} else if ( doc.mozFullScreenElement !== undefined ) {\r\n\t\tfullscreenElement = 'mozFullScreenElement';\r\n\t} else if ( doc.webkitFullscreenElement !== undefined ) {\r\n\t\tfullscreenElement = 'webkitFullscreenElement';\r\n\t}\r\n\r\n\tRactive.isFullscreen = function ( el ) {\r\n\t\treturn el === doc[ fullscreenElement ];\r\n\t};\r\n\r\n}( Ractive ));\r\nAnimation = function ( options ) {\r\n\tvar key;\r\n\r\n\tthis.startTime = Date.now();\r\n\r\n\t// from and to\r\n\tfor ( key in options ) {\r\n\t\tif ( hasOwn.call( options, key ) ) {\r\n\t\t\tthis[ key ] = options[ key ];\r\n\t\t}\r\n\t}\r\n\r\n\tthis.interpolator = Ractive.interpolate( this.from, this.to );\r\n\tthis.running = true;\r\n};\r\n\r\nAnimation.prototype = {\r\n\ttick: function () {\r\n\t\tvar elapsed, t, value, timeNow, index;\r\n\r\n\t\tif ( this.running ) {\r\n\t\t\ttimeNow = Date.now();\r\n\t\t\telapsed = timeNow - this.startTime;\r\n\r\n\t\t\tif ( elapsed >= this.duration ) {\r\n\t\t\t\tthis.root.set( this.keypath, this.to );\r\n\r\n\t\t\t\tif ( this.step ) {\r\n\t\t\t\t\tthis.step( 1, this.to );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( this.complete ) {\r\n\t\t\t\t\tthis.complete( 1, this.to );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tindex = this.root._animations.indexOf( this );\r\n\r\n\t\t\t\t// TODO remove this check, once we're satisifed this never happens!\r\n\t\t\t\tif ( index === -1 && console && console.warn ) {\r\n\t\t\t\t\tconsole.warn( 'Animation was not found' );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.root._animations.splice( index, 1 );\r\n\r\n\t\t\t\tthis.running = false;\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tt = this.easing ? this.easing ( elapsed / this.duration ) : ( elapsed / this.duration );\r\n\t\t\tvalue = this.interpolator( t );\r\n\r\n\t\t\tthis.root.set( this.keypath, value );\r\n\r\n\t\t\tif ( this.step ) {\r\n\t\t\t\tthis.step( t, value );\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\tstop: function () {\r\n\t\tvar index;\r\n\r\n\t\tthis.running = false;\r\n\r\n\t\tindex = this.root._animations.indexOf( this );\r\n\r\n\t\t// TODO remove this check, once we're satisifed this never happens!\r\n\t\tif ( index === -1 && console && console.warn ) {\r\n\t\t\tconsole.warn( 'Animation was not found' );\r\n\t\t}\r\n\r\n\t\tthis.root._animations.splice( index, 1 );\r\n\t}\r\n};\r\nanimationCollection = {\r\n\tanimations: [],\r\n\r\n\ttick: function () {\r\n\t\tvar i, animation;\r\n\r\n\t\tfor ( i=0; i<this.animations.length; i+=1 ) {\r\n\t\t\tanimation = this.animations[i];\r\n\r\n\t\t\tif ( !animation.tick() ) {\r\n\t\t\t\t// animation is complete, remove it from the stack, and decrement i so we don't miss one\r\n\t\t\t\tthis.animations.splice( i--, 1 );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( this.animations.length ) {\r\n\t\t\trequestAnimationFrame( this.boundTick );\r\n\t\t} else {\r\n\t\t\tthis.running = false;\r\n\t\t}\r\n\t},\r\n\r\n\t// bind method to animationCollection\r\n\tboundTick: function () {\r\n\t\tanimationCollection.tick();\r\n\t},\r\n\r\n\tpush: function ( animation ) {\r\n\t\tthis.animations[ this.animations.length ] = animation;\r\n\r\n\t\tif ( !this.running ) {\r\n\t\t\tthis.running = true;\r\n\t\t\tthis.tick();\r\n\t\t}\r\n\t}\r\n};\r\n// https://gist.github.com/paulirish/1579671\r\n(function( vendors, lastTime, global ) {\r\n\t\r\n\tvar x, setTimeout;\r\n\r\n\tif ( global.requestAnimationFrame ) {\r\n\t\trequestAnimationFrame = global.requestAnimationFrame;\r\n\t\treturn;\r\n\t}\r\n\r\n\tfor ( x = 0; x < vendors.length && !requestAnimationFrame; ++x ) {\r\n\t\trequestAnimationFrame = global[vendors[x]+'RequestAnimationFrame'];\r\n\t}\r\n\r\n\tif ( !requestAnimationFrame ) {\r\n\t\tsetTimeout = global.setTimeout;\r\n\r\n\t\trequestAnimationFrame = function(callback) {\r\n\t\t\tvar currTime, timeToCall, id;\r\n\t\t\t\r\n\t\t\tcurrTime = Date.now();\r\n\t\t\ttimeToCall = Math.max( 0, 16 - (currTime - lastTime ) );\r\n\t\t\tid = setTimeout( function() { callback(currTime + timeToCall); }, timeToCall );\r\n\t\t\t\r\n\t\t\tlastTime = currTime + timeToCall;\r\n\t\t\treturn id;\r\n\t\t};\r\n\t}\r\n\t\r\n}( ['ms', 'moz', 'webkit', 'o'], 0, global ));\r\nvar arrayContentsMatch = function ( a, b ) {\r\n\tvar i;\r\n\r\n\tif ( !isArray( a ) || !isArray( b ) ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif ( a.length !== b.length ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\ti = a.length;\r\n\twhile ( i-- ) {\r\n\t\tif ( a[i] !== b[i] ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n};\r\n(function () {\r\n\r\n\tvar propertyNames, determineNameAndNamespace, setStaticAttribute, determinePropertyName;\r\n\r\n\t// the property name equivalents for element attributes, where they differ\r\n\t// from the lowercased attribute name\r\n\tpropertyNames = {\r\n\t\t'accept-charset': 'acceptCharset',\r\n\t\taccesskey: 'accessKey',\r\n\t\tbgcolor: 'bgColor',\r\n\t\t'class': 'className',\r\n\t\tcodebase: 'codeBase',\r\n\t\tcolspan: 'colSpan',\r\n\t\tcontenteditable: 'contentEditable',\r\n\t\tdatetime: 'dateTime',\r\n\t\tdirname: 'dirName',\r\n\t\t'for': 'htmlFor',\r\n\t\t'http-equiv': 'httpEquiv',\r\n\t\tismap: 'isMap',\r\n\t\tmaxlength: 'maxLength',\r\n\t\tnovalidate: 'noValidate',\r\n\t\tpubdate: 'pubDate',\r\n\t\treadonly: 'readOnly',\r\n\t\trowspan: 'rowSpan',\r\n\t\ttabindex: 'tabIndex',\r\n\t\tusemap: 'useMap'\r\n\t};\r\n\r\n\t// Attribute\r\n\tDomAttribute = function ( options ) {\r\n\r\n\t\tthis.element = options.element;\r\n\t\tdetermineNameAndNamespace( this, options.name );\r\n\r\n\t\t// if it's an empty attribute, or just a straight key-value pair, with no\r\n\t\t// mustache shenanigans, set the attribute accordingly and go home\r\n\t\tif ( options.value === null || typeof options.value === 'string' ) {\r\n\t\t\tsetStaticAttribute( this, options );\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// otherwise we need to do some work\r\n\t\tthis.root = options.root;\r\n\t\tthis.parentNode = options.parentNode;\r\n\r\n\t\t// share parentFragment with parent element\r\n\t\tthis.parentFragment = this.element.parentFragment;\r\n\r\n\t\tthis.fragment = new StringFragment({\r\n\t\t\tdescriptor:   options.value,\r\n\t\t\troot:         this.root,\r\n\t\t\towner:        this,\r\n\t\t\tcontextStack: options.contextStack\r\n\t\t});\r\n\r\n\r\n\t\t// if we're not rendering (i.e. we're just stringifying), we can stop here\r\n\t\tif ( !this.parentNode ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// special cases\r\n\t\tif ( this.name === 'value' ) {\r\n\t\t\t\r\n\t\t\t// in some cases we will need to store the node's intended value, as node.value\r\n\t\t\t// is always a string. For that, we need to add a place to store it\r\n\t\t\toptions.element.ractify();\r\n\r\n\t\t\tthis.isValueAttribute = true;\r\n\r\n\t\t\t// TODO need to wait until afterwards to determine type, in case we\r\n\t\t\t// haven't initialised that attribute yet\r\n\t\t\t// <input type='file' value='{{value}}'>\r\n\t\t\tif ( this.parentNode.tagName === 'INPUT' && this.parentNode.type === 'file' ) {\r\n\t\t\t\tthis.isFileInputValue = true;\r\n\t\t\t}\r\n\t\t} \r\n\t\t\r\n\r\n\t\t// can we establish this attribute's property name equivalent?\r\n\t\tdeterminePropertyName( this, options );\r\n\t\t\r\n\t\t// determine whether this attribute can be marked as self-updating\r\n\t\tthis.selfUpdating = isStringFragmentSimple( this.fragment );\r\n\r\n\t\t// mark as ready\r\n\t\tthis.ready = true;\r\n\t};\r\n\r\n\tDomAttribute.prototype = {\r\n\t\tbind: bindAttribute,\r\n\t\tupdate: updateAttribute,\r\n\r\n\t\tupdateBindings: function () {\r\n\t\t\t// if the fragment this attribute belongs to gets reassigned (as a result of\r\n\t\t\t// as section being updated via an array shift, unshift or splice), this\r\n\t\t\t// attribute needs to recognise that its keypath has changed\r\n\t\t\tthis.keypath = this.interpolator.keypath || this.interpolator.r; // TODO is this right? .r?\r\n\r\n\t\t\t// if we encounter the special case described above, update the name attribute\r\n\t\t\tif ( this.propertyName === 'name' ) {\r\n\t\t\t\t// replace actual name attribute\r\n\t\t\t\tthis.parentNode.name = '{{' + this.keypath + '}}';\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tteardown: function () {\r\n\t\t\tvar i;\r\n\r\n\t\t\tif ( this.boundEvents ) {\r\n\t\t\t\ti = this.boundEvents.length;\r\n\r\n\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\tthis.parentNode.removeEventListener( this.boundEvents[i], this.updateModel, false );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// ignore non-dynamic attributes\r\n\t\t\tif ( this.fragment ) {\r\n\t\t\t\tthis.fragment.teardown();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tbubble: function () {\r\n\t\t\t// If an attribute's text fragment contains a single item, we can\r\n\t\t\t// update the DOM immediately...\r\n\t\t\tif ( this.selfUpdating ) {\r\n\t\t\t\tthis.update();\r\n\t\t\t}\r\n\r\n\t\t\t// otherwise we want to register it as a deferred attribute, to be\r\n\t\t\t// updated once all the information is in, to prevent unnecessary\r\n\t\t\t// DOM manipulation\r\n\t\t\telse if ( !this.deferred && this.ready ) {\r\n\t\t\t\tthis.root._defAttrs[ this.root._defAttrs.length ] = this;\r\n\t\t\t\tthis.deferred = true;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\ttoString: function () {\r\n\t\t\tvar str;\r\n\r\n\t\t\tif ( this.value === null ) {\r\n\t\t\t\treturn this.name;\r\n\t\t\t}\r\n\r\n\t\t\t// TODO don't use JSON.stringify?\r\n\r\n\t\t\tif ( !this.fragment ) {\r\n\t\t\t\treturn this.name + '=' + JSON.stringify( this.value );\r\n\t\t\t}\r\n\r\n\t\t\t// TODO deal with boolean attributes correctly\r\n\t\t\tstr = this.fragment.toString();\r\n\t\t\t\r\n\t\t\treturn this.name + '=' + JSON.stringify( str );\r\n\t\t}\r\n\t};\r\n\r\n\r\n\t// Helper functions\r\n\tdetermineNameAndNamespace = function ( attribute, name ) {\r\n\t\tvar colonIndex, namespacePrefix;\r\n\r\n\t\t// are we dealing with a namespaced attribute, e.g. xlink:href?\r\n\t\tcolonIndex = name.indexOf( ':' );\r\n\t\tif ( colonIndex !== -1 ) {\r\n\r\n\t\t\t// looks like we are, yes...\r\n\t\t\tnamespacePrefix = name.substr( 0, colonIndex );\r\n\r\n\t\t\t// ...unless it's a namespace *declaration*, which we ignore (on the assumption\r\n\t\t\t// that only valid namespaces will be used)\r\n\t\t\tif ( namespacePrefix !== 'xmlns' ) {\r\n\t\t\t\tname = name.substring( colonIndex + 1 );\r\n\r\n\t\t\t\tattribute.name = name;\r\n\t\t\t\tattribute.namespace = namespaces[ namespacePrefix ];\r\n\r\n\t\t\t\tif ( !attribute.namespace ) {\r\n\t\t\t\t\tthrow 'Unknown namespace (\"' + namespacePrefix + '\")';\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tattribute.name = name;\r\n\t};\r\n\r\n\tsetStaticAttribute = function ( attribute, options ) {\r\n\t\tvar value = ( options.value === null ? '' : options.value );\r\n\r\n\t\tif ( options.parentNode ) {\r\n\t\t\tif ( attribute.namespace ) {\r\n\t\t\t\toptions.parentNode.setAttributeNS( attribute.namespace, options.name, value );\r\n\t\t\t} else {\r\n\t\t\t\toptions.parentNode.setAttribute( options.name, value );\r\n\t\t\t}\r\n\r\n\t\t\tif ( attribute.name === 'id' ) {\r\n\t\t\t\toptions.root.nodes[ options.value ] = options.parentNode;\r\n\t\t\t}\r\n\r\n\t\t\tif ( attribute.name === 'value' ) {\r\n\t\t\t\tattribute.element.ractify().value = options.value;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tattribute.value = options.value;\r\n\t};\r\n\r\n\tdeterminePropertyName = function ( attribute, options ) {\r\n\t\tvar propertyName;\r\n\r\n\t\tif ( attribute.parentNode && !attribute.namespace && ( !options.parentNode.namespaceURI || options.parentNode.namespaceURI === namespaces.html ) ) {\r\n\t\t\tpropertyName = propertyNames[ attribute.name ] || attribute.name;\r\n\r\n\t\t\tif ( options.parentNode[ propertyName ] !== undefined ) {\r\n\t\t\t\tattribute.propertyName = propertyName;\r\n\t\t\t}\r\n\r\n\t\t\t// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\r\n\t\t\t// node.selected = true rather than node.setAttribute( 'selected', '' )\r\n\t\t\tif ( typeof options.parentNode[ propertyName ] === 'boolean' || propertyName === 'value' ) {\r\n\t\t\t\tattribute.useProperty = true;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n}());\r\n(function () {\r\n\r\n\tvar ComponentParameter;\r\n\r\n\t// TODO support server environments\r\n\tDomComponent = function ( options, docFrag ) {\r\n\t\tvar self = this,\r\n\t\t\tparentFragment = this.parentFragment = options.parentFragment,\r\n\t\t\troot,\r\n\t\t\tComponent,\r\n\t\t\ttwoway,\r\n\t\t\tpartials,\r\n\t\t\tinstance,\r\n\t\t\tkeypath,\r\n\t\t\tdata,\r\n\t\t\tmappings,\r\n\t\t\ti,\r\n\t\t\tpair,\r\n\t\t\tobserveParent,\r\n\t\t\tobserveChild,\r\n\t\t\tsettingParent,\r\n\t\t\tsettingChild,\r\n\t\t\tkey,\r\n\t\t\tinitFalse,\r\n\t\t\tprocessKeyValuePair,\r\n\t\t\teventName,\r\n\t\t\tpropagateEvent,\r\n\t\t\titems;\r\n\r\n\t\troot = parentFragment.root;\r\n\r\n\t\tthis.type = COMPONENT;\r\n\t\tthis.name = options.descriptor.r;\r\n\r\n\t\tComponent = getComponentConstructor( parentFragment.root, options.descriptor.e );\r\n\r\n\t\tif ( !Component ) {\r\n\t\t\tthrow new Error( 'Component \"' + options.descriptor.e + '\" not found' );\r\n\t\t}\r\n\r\n\t\ttwoway = ( Component.twoway !== false );\r\n\r\n\t\tdata = {};\r\n\t\tmappings = [];\r\n\r\n\t\tthis.complexParameters = [];\r\n\r\n\t\tprocessKeyValuePair = function ( key, value ) {\r\n\t\t\tvar parameter;\r\n\r\n\t\t\t// if this is a static value, great\r\n\t\t\tif ( typeof value === 'string' ) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tdata[ key ] = JSON.parse( value );\r\n\t\t\t\t} catch ( err ) {\r\n\t\t\t\t\tdata[ key ] = value;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// if null, we treat it as a boolean attribute (i.e. true)\r\n\t\t\tif ( value === null ) {\r\n\t\t\t\tdata[ key ] = true;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// if a regular interpolator, we bind to it\r\n\t\t\tif ( value.length === 1 && value[0].t === INTERPOLATOR && value[0].r ) {\r\n\t\t\t\t\r\n\t\t\t\t// is it an index reference?\r\n\t\t\t\tif ( parentFragment.indexRefs && parentFragment.indexRefs[ value[0].r ] !== undefined ) {\r\n\t\t\t\t\tdata[ key ] = parentFragment.indexRefs[ value[0].r ];\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tkeypath = resolveRef( root, value[0].r, parentFragment.contextStack ) || value[0].r;\r\n\r\n\t\t\t\tdata[ key ] = root.get( keypath );\r\n\t\t\t\tmappings[ mappings.length ] = [ key, keypath ];\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tparameter = new ComponentParameter( root, self, key, value, parentFragment.contextStack );\r\n\t\t\tself.complexParameters[ self.complexParameters.length ] = parameter;\r\n\r\n\t\t\tdata[ key ] = parameter.value;\r\n\t\t};\r\n\r\n\t\tif ( options.descriptor.a ) {\r\n\t\t\tfor ( key in options.descriptor.a ) {\r\n\t\t\t\tif ( options.descriptor.a.hasOwnProperty( key ) ) {\r\n\t\t\t\t\tprocessKeyValuePair( key, options.descriptor.a[ key ] );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpartials = {};\r\n\t\tif ( options.descriptor.f ) {\r\n\t\t\tpartials.content = options.descriptor.f;\r\n\t\t}\r\n\r\n\t\t// TODO don't clone parent node - instead use a document fragment (and pass in the namespaceURI\r\n\t\t// of the parent node, for SVG purposes) and insert contents that way?\r\n\t\tinstance = this.instance = new Component({\r\n\t\t\tel: parentFragment.parentNode.cloneNode( false ), // to ensure correct namespaceURL\r\n\t\t\tdata: data,\r\n\t\t\tpartials: partials\r\n\t\t});\r\n\r\n\t\twhile ( instance.el.firstChild ) {\r\n\t\t\tdocFrag.appendChild( instance.el.firstChild );\r\n\t\t}\r\n\r\n\t\t// reset node references...\r\n\t\t// TODO this is a filthy hack! Need to come up with a neater solution\r\n\t\tinstance.el = parentFragment.parentNode;\r\n\t\titems = instance.fragment.items;\r\n\t\tif ( items ) {\r\n\t\t\ti = items.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tif ( items[i].parentNode ) {\r\n\t\t\t\t\titems[i].parentNode = parentFragment.parentNode;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tself.observers = [];\r\n\t\tinitFalse = { init: false };\r\n\r\n\t\tobserveParent = function ( pair ) {\r\n\t\t\tvar observer = root.observe( pair[1], function ( value ) {\r\n\t\t\t\tif ( !settingParent ) {\r\n\t\t\t\t\tsettingChild = true;\r\n\t\t\t\t\tinstance.set( pair[0], value );\r\n\t\t\t\t\tsettingChild = false;\r\n\t\t\t\t}\r\n\t\t\t}, initFalse );\r\n\r\n\t\t\tself.observers[ self.observers.length ] = observer;\r\n\t\t};\r\n\r\n\t\tif ( twoway ) {\r\n\t\t\tobserveChild = function ( pair ) {\r\n\t\t\t\tvar observer = instance.observe( pair[0], function ( value ) {\r\n\t\t\t\t\tif ( !settingChild ) {\r\n\t\t\t\t\t\tsettingParent = true;\r\n\t\t\t\t\t\troot.set( pair[1], value );\r\n\t\t\t\t\t\tsettingParent = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}, initFalse );\r\n\r\n\t\t\t\tself.observers[ self.observers.length ] = observer;\r\n\r\n\t\t\t\t// initialise\r\n\t\t\t\troot.set( pair[1], instance.get( pair[0] ) );\r\n\t\t\t};\r\n\t\t}\r\n\t\t\r\n\r\n\t\ti = mappings.length;\r\n\t\twhile ( i-- ) {\r\n\t\t\tpair = mappings[i];\r\n\r\n\t\t\tobserveParent( pair );\r\n\r\n\t\t\tif ( twoway ) {\r\n\t\t\t\tobserveChild( pair );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\t// proxy events\r\n\t\tpropagateEvent = function ( eventName, proxy ) {\r\n\t\t\tinstance.on( eventName, function () {\r\n\t\t\t\tvar args = Array.prototype.slice.call( arguments );\r\n\t\t\t\targs.unshift( proxy );\r\n\r\n\t\t\t\troot.fire.apply( root, args );\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\tif ( options.descriptor.v ) {\r\n\t\t\tfor ( eventName in options.descriptor.v ) {\r\n\t\t\t\tif ( options.descriptor.v.hasOwnProperty( eventName ) ) {\r\n\t\t\t\t\tpropagateEvent( eventName, options.descriptor.v[ eventName ] );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tDomComponent.prototype = {\r\n\t\tfirstNode: function () {\r\n\t\t\treturn this.instance.fragment.firstNode();\r\n\t\t},\r\n\r\n\t\tfindNextNode: function () {\r\n\t\t\treturn this.parentFragment.findNextNode( this );\r\n\t\t},\r\n\r\n\t\tteardown: function () {\r\n\t\t\twhile ( this.complexParameters.length ) {\r\n\t\t\t\tthis.complexParameters.pop().teardown();\r\n\t\t\t}\r\n\r\n\t\t\twhile ( this.observers.length ) {\r\n\t\t\t\tthis.observers.pop().cancel();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.instance.teardown();\r\n\t\t},\r\n\r\n\t\ttoString: function () {\r\n\t\t\treturn this.instance.fragment.toString();\r\n\t\t}\r\n\t};\r\n\r\n\r\n\tComponentParameter = function ( root, component, key, value, contextStack ) {\r\n\t\t\r\n\t\tthis.parentFragment = component.parentFragment;\r\n\t\tthis.component = component;\r\n\t\tthis.key = key;\r\n\r\n\t\tthis.fragment = new StringFragment({\r\n\t\t\tdescriptor:   value,\r\n\t\t\troot:         root,\r\n\t\t\towner:        this,\r\n\t\t\tcontextStack: contextStack\r\n\t\t});\r\n\r\n\t\tthis.selfUpdating = isStringFragmentSimple( this.fragment );\r\n\t\tthis.value = this.fragment.getValue();\r\n\t};\r\n\r\n\tComponentParameter.prototype = {\r\n\t\tbubble: function () {\r\n\t\t\t// If there's a single item, we can update the component immediately...\r\n\t\t\tif ( this.selfUpdating ) {\r\n\t\t\t\tthis.update();\r\n\t\t\t}\r\n\r\n\t\t\t// otherwise we want to register it as a deferred component, to be\r\n\t\t\t// updated once all the information is in, to prevent unnecessary\r\n\t\t\t// DOM manipulation\r\n\t\t\telse if ( !this.deferred && this.ready ) {\r\n\t\t\t\tthis.root._defAttrs[ this.root._defAttrs.length ] = this;\r\n\t\t\t\tthis.deferred = true;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tupdate: function () {\r\n\t\t\tvar value = this.fragment.getValue();\r\n\r\n\t\t\tthis.component.set( this.key, value );\r\n\t\t\tthis.value = value;\r\n\t\t}\r\n\t};\r\n\r\n\r\n}());\r\n// Element\r\nDomElement = function ( options, docFrag ) {\r\n\r\n\tvar parentFragment,\r\n\t\tdescriptor,\r\n\t\tnamespace,\r\n\t\tattributes,\r\n\t\troot;\r\n\r\n\tthis.type = ELEMENT;\r\n\r\n\t// stuff we'll need later\r\n\tparentFragment = this.parentFragment = options.parentFragment;\r\n\tdescriptor = this.descriptor = options.descriptor;\r\n\r\n\tthis.root = root = parentFragment.root;\r\n\tthis.parentNode = parentFragment.parentNode;\r\n\tthis.index = options.index;\r\n\r\n\tthis.eventListeners = [];\r\n\tthis.customEventListeners = [];\r\n\r\n\t// get namespace, if we're actually rendering (not server-side stringifying)\r\n\tif ( this.parentNode ) {\r\n\t\tnamespace = getElementNamespace( descriptor, this.parentNode );\r\n\r\n\t\t// create the DOM node\r\n\t\tthis.node = doc.createElementNS( namespace, descriptor.e );\r\n\t}\r\n\r\n\r\n\t// set attributes\r\n\tattributes = createElementAttributes( this, descriptor.a );\r\n\r\n\r\n\t// append children, if there are any\r\n\tif ( descriptor.f ) {\r\n\t\tappendElementChildren( this, this.node, descriptor, docFrag );\r\n\t}\r\n\r\n\r\n\t// create event proxies\r\n\tif ( docFrag && descriptor.v ) {\r\n\t\taddEventProxies( this, descriptor.v );\r\n\t}\r\n\r\n\t// if we're actually rendering (i.e. not server-side stringifying), proceed\r\n\tif ( docFrag ) {\r\n\t\t// deal with two-way bindings\r\n\t\tif ( root.twoway ) {\r\n\t\t\tbindElement( this, attributes );\r\n\t\t}\r\n\r\n\t\t// name attributes are deferred, because they're a special case - if two-way\r\n\t\t// binding is involved they need to update later. But if it turns out they're\r\n\t\t// not two-way we can update them now\r\n\t\tif ( attributes.name && !attributes.name.twoway ) {\r\n\t\t\tattributes.name.update();\r\n\t\t}\r\n\r\n\t\tdocFrag.appendChild( this.node );\r\n\r\n\t\t// trigger intro transition\r\n\t\t// TODO make it possible to defer execution until node is on DOM\r\n\t\tif ( descriptor.t1 ) {\r\n\t\t\texecuteTransition( descriptor.t1, root, this, parentFragment.contextStack, true );\r\n\t\t}\r\n\t}\r\n};\r\n\r\nDomElement.prototype = {\r\n\tteardown: function ( detach ) {\r\n\t\tvar eventName, binding, bindings;\r\n\r\n\t\t// Children first. that way, any transitions on child elements will be\r\n\t\t// handled by the current transitionManager\r\n\t\tif ( this.fragment ) {\r\n\t\t\tthis.fragment.teardown( false );\r\n\t\t}\r\n\r\n\t\twhile ( this.attributes.length ) {\r\n\t\t\tthis.attributes.pop().teardown();\r\n\t\t}\r\n\r\n\t\tif ( this.node._ractive ) {\r\n\t\t\tfor ( eventName in this.node._ractive.events ) {\r\n\t\t\t\tthis.node._ractive.events[ eventName ].teardown();\r\n\t\t\t}\r\n\r\n\t\t\t// tear down two-way binding, if such there be\r\n\t\t\tif ( binding = this.node._ractive.binding ) {\r\n\t\t\t\tbinding.teardown();\r\n\r\n\t\t\t\tbindings = this.root._twowayBindings[ binding.attr.keypath ];\r\n\t\t\t\tbindings.splice( bindings.indexOf( binding ), 1 );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( this.descriptor.t2 ) {\r\n\t\t\texecuteTransition( this.descriptor.t2, this.root, this, this.parentFragment.contextStack, false );\r\n\t\t}\r\n\r\n\t\tif ( detach ) {\r\n\t\t\tthis.root._transitionManager.detachWhenReady( this.node );\r\n\t\t}\r\n\t},\r\n\r\n\tfirstNode: function () {\r\n\t\treturn this.node;\r\n\t},\r\n\r\n\tfindNextNode: function () {\r\n\t\treturn null;\r\n\t},\r\n\r\n\t// TODO can we get rid of this?\r\n\tbubble: noop, // just so event proxy and transition fragments have something to call!\r\n\r\n\ttoString: function () {\r\n\t\tvar str, i, len;\r\n\r\n\t\t// TODO void tags\r\n\t\tstr = '' +\r\n\t\t\t'<' + this.descriptor.e;\r\n\r\n\t\tlen = this.attributes.length;\r\n\t\tfor ( i=0; i<len; i+=1 ) {\r\n\t\t\tstr += ' ' + this.attributes[i].toString();\r\n\t\t}\r\n\r\n\t\tstr += '>';\r\n\r\n\t\tif ( this.html ) {\r\n\t\t\tstr += this.html;\r\n\t\t} else if ( this.fragment ) {\r\n\t\t\tstr += this.fragment.toString();\r\n\t\t}\r\n\r\n\t\tstr += '</' + this.descriptor.e + '>';\r\n\r\n\t\treturn str;\r\n\t},\r\n\r\n\tractify: function () {\r\n\t\tvar contextStack = this.parentFragment.contextStack;\r\n\r\n\t\tif ( !this.node._ractive ) {\r\n\t\t\tdefineProperty( this.node, '_ractive', {\r\n\t\t\t\tvalue: {\r\n\t\t\t\t\tkeypath: ( contextStack.length ? contextStack[ contextStack.length - 1 ] : '' ),\r\n\t\t\t\t\tindex: this.parentFragment.indexRefs,\r\n\t\t\t\t\tevents: createFromNull(),\r\n\t\t\t\t\troot: this.root\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn this.node._ractive;\r\n\t}\r\n};\r\nDomFragment = function ( options ) {\r\n\tif ( options.parentNode ) {\r\n\t\tthis.docFrag = doc.createDocumentFragment();\r\n\t}\r\n\r\n\t// if we have an HTML string, our job is easy.\r\n\tif ( typeof options.descriptor === 'string' ) {\r\n\t\tthis.html = options.descriptor;\r\n\r\n\t\tif ( this.docFrag ) {\r\n\t\t\tthis.nodes = insertHtml( options.descriptor, options.parentNode.tagName, this.docFrag );\r\n\t\t}\r\n\t\t\r\n\t\treturn; // prevent the rest of the init sequence\r\n\t}\r\n\r\n\t// otherwise we need to make a proper fragment\r\n\tinitFragment( this, options );\r\n};\r\n\r\nDomFragment.prototype = {\r\n\tcreateItem: function ( options ) {\r\n\t\tif ( typeof options.descriptor === 'string' ) {\r\n\t\t\treturn new DomText( options, this.docFrag );\r\n\t\t}\r\n\r\n\t\tswitch ( options.descriptor.t ) {\r\n\t\t\tcase INTERPOLATOR: return new DomInterpolator( options, this.docFrag );\r\n\t\t\tcase SECTION:      return new DomSection( options, this.docFrag );\r\n\t\t\tcase TRIPLE:       return new DomTriple( options, this.docFrag );\r\n\r\n\t\t\tcase ELEMENT:      return new DomElement( options, this.docFrag );\r\n\t\t\tcase PARTIAL:      return new DomPartial( options, this.docFrag );\r\n\t\t\tcase COMPONENT:    return new DomComponent( options, this.docFrag );\r\n\r\n\t\t\tdefault: throw new Error( 'WTF? not sure what happened here...' );\r\n\t\t}\r\n\t},\r\n\r\n\tteardown: function ( detach ) {\r\n\t\tvar node;\r\n\r\n\t\t// if this was built from HTML, we just need to remove the nodes\r\n\t\tif ( detach && this.nodes ) {\r\n\t\t\twhile ( this.nodes.length ) {\r\n\t\t\t\tnode = this.nodes.pop();\r\n\t\t\t\tnode.parentNode.removeChild( node );\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// otherwise we need to do a proper teardown\r\n\t\tif ( !this.items ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\twhile ( this.items.length ) {\r\n\t\t\tthis.items.pop().teardown( detach );\r\n\t\t}\r\n\t},\r\n\r\n\tfirstNode: function () {\r\n\t\tif ( this.items && this.items[0] ) {\r\n\t\t\treturn this.items[0].firstNode();\r\n\t\t} else if ( this.nodes ) {\r\n\t\t\treturn this.nodes[0] || null;\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t},\r\n\r\n\tfindNextNode: function ( item ) {\r\n\t\tvar index = item.index;\r\n\r\n\t\tif ( this.items[ index + 1 ] ) {\r\n\t\t\treturn this.items[ index + 1 ].firstNode();\r\n\t\t}\r\n\r\n\t\t// if this is the root fragment, and there are no more items,\r\n\t\t// it means we're at the end\r\n\t\tif ( this.owner === this.root ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn this.owner.findNextNode( this );\r\n\t},\r\n\r\n\ttoString: function () {\r\n\t\tvar html, i, len, item;\r\n\t\t\r\n\t\tif ( this.html ) {\r\n\t\t\treturn this.html;\r\n\t\t}\r\n\r\n\t\thtml = '';\r\n\r\n\t\tif ( !this.items ) {\r\n\t\t\treturn html;\r\n\t\t}\r\n\r\n\t\tlen = this.items.length;\r\n\r\n\t\tfor ( i=0; i<len; i+=1 ) {\r\n\t\t\titem = this.items[i];\r\n\t\t\thtml += item.toString();\r\n\t\t}\r\n\r\n\t\treturn html;\r\n\t}\r\n};\r\n// Interpolator\r\nDomInterpolator = function ( options, docFrag ) {\r\n\tthis.type = INTERPOLATOR;\r\n\r\n\tif ( docFrag ) {\r\n\t\tthis.node = doc.createTextNode( '' );\r\n\t\tdocFrag.appendChild( this.node );\r\n\t}\r\n\r\n\t// extend Mustache\r\n\tinitMustache( this, options );\r\n};\r\n\r\nDomInterpolator.prototype = {\r\n\tupdate: updateMustache,\r\n\tresolve: resolveMustache,\r\n\r\n\tteardown: function ( detach ) {\r\n\t\tteardown( this );\r\n\t\t\r\n\t\tif ( detach ) {\r\n\t\t\tthis.node.parentNode.removeChild( this.node );\r\n\t\t}\r\n\t},\r\n\r\n\trender: function ( value ) {\r\n\t\tif ( this.node ) {\r\n\t\t\tthis.node.data = ( value === undefined ? '' : value );\r\n\t\t}\r\n\t},\r\n\r\n\tfirstNode: function () {\r\n\t\treturn this.node;\r\n\t},\r\n\r\n\ttoString: function () {\r\n\t\tvar value = ( this.value !== undefined ? '' + this.value : '' );\r\n\t\treturn value.replace( '<', '&lt;' ).replace( '>', '&gt;' );\r\n\t}\r\n};\r\n// Partials\r\nDomPartial = function ( options, docFrag ) {\r\n\tvar parentFragment = this.parentFragment = options.parentFragment, descriptor;\r\n\r\n\tthis.type = PARTIAL;\r\n\tthis.name = options.descriptor.r;\r\n\r\n\tdescriptor = getPartialDescriptor( parentFragment.root, options.descriptor.r );\r\n\r\n\tthis.fragment = new DomFragment({\r\n\t\tdescriptor:   descriptor,\r\n\t\troot:         parentFragment.root,\r\n\t\tparentNode:   parentFragment.parentNode,\r\n\t\tcontextStack: parentFragment.contextStack,\r\n\t\towner:        this\r\n\t});\r\n\r\n\tif ( docFrag ) {\r\n\t\tdocFrag.appendChild( this.fragment.docFrag );\r\n\t}\r\n};\r\n\r\nDomPartial.prototype = {\r\n\tfirstNode: function () {\r\n\t\treturn this.fragment.firstNode();\r\n\t},\r\n\r\n\tfindNextNode: function () {\r\n\t\treturn this.parentFragment.findNextNode( this );\r\n\t},\r\n\r\n\tteardown: function ( detach ) {\r\n\t\tthis.fragment.teardown( detach );\r\n\t},\r\n\r\n\ttoString: function () {\r\n\t\treturn this.fragment.toString();\r\n\t}\r\n};\r\n// Section\r\nDomSection = function ( options, docFrag ) {\r\n\tthis.type = SECTION;\r\n\r\n\tthis.fragments = [];\r\n\tthis.length = 0; // number of times this section is rendered\r\n\r\n\tif ( docFrag ) {\r\n\t\tthis.docFrag = doc.createDocumentFragment();\r\n\t}\r\n\t\r\n\tthis.initialising = true;\r\n\tinitMustache( this, options );\r\n\r\n\tif ( docFrag ) {\r\n\t\tdocFrag.appendChild( this.docFrag );\r\n\t}\r\n\r\n\tthis.initialising = false;\r\n};\r\n\r\nDomSection.prototype = {\r\n\tupdate: updateMustache,\r\n\tresolve: resolveMustache,\r\n\r\n\tsmartUpdate: function ( methodName, args ) {\r\n\t\tvar fragmentOptions;\r\n\r\n\t\tif ( methodName === 'push' || methodName === 'unshift' || methodName === 'splice' ) {\r\n\t\t\tfragmentOptions = {\r\n\t\t\t\tdescriptor: this.descriptor.f,\r\n\t\t\t\troot:       this.root,\r\n\t\t\t\tparentNode: this.parentNode,\r\n\t\t\t\towner:      this\r\n\t\t\t};\r\n\r\n\t\t\tif ( this.descriptor.i ) {\r\n\t\t\t\tfragmentOptions.indexRef = this.descriptor.i;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( this[ methodName ] ) { // if not, it's sort or reverse, which doesn't affect us (i.e. our length)\r\n\t\t\tthis[ methodName ]( fragmentOptions, args );\r\n\t\t}\r\n\t},\r\n\r\n\tpop: function () {\r\n\t\t// teardown last fragment\r\n\t\tif ( this.length ) {\r\n\t\t\tthis.fragments.pop().teardown( true );\r\n\t\t\tthis.length -= 1;\r\n\t\t}\r\n\t},\r\n\r\n\tpush: function ( fragmentOptions, args ) {\r\n\t\tvar start, end, i;\r\n\r\n\t\t// append list item to context stack\r\n\t\tstart = this.length;\r\n\t\tend = start + args.length;\r\n\r\n\t\tfor ( i=start; i<end; i+=1 ) {\r\n\t\t\tfragmentOptions.contextStack = this.contextStack.concat( this.keypath + '.' + i );\r\n\t\t\tfragmentOptions.index = i;\r\n\r\n\t\t\tthis.fragments[i] = this.createFragment( fragmentOptions );\r\n\t\t}\r\n\t\t\r\n\t\tthis.length += args.length;\r\n\r\n\t\t// append docfrag in front of next node\r\n\t\tthis.parentNode.insertBefore( this.docFrag, this.parentFragment.findNextNode( this ) );\r\n\t},\r\n\r\n\tshift: function () {\r\n\t\tthis.splice( null, [ 0, 1 ] );\r\n\t},\r\n\r\n\tunshift: function ( fragmentOptions, args ) {\r\n\t\tthis.splice( fragmentOptions, [ 0, 0 ].concat( new Array( args.length ) ) );\r\n\t},\r\n\r\n\tsplice: function ( fragmentOptions, args ) {\r\n\t\tvar insertionPoint, addedItems, removedItems, balance, i, start, end, spliceArgs, reassignStart;\r\n\r\n\t\tif ( !args.length ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// figure out where the changes started...\r\n\t\tstart = +( args[0] < 0 ? this.length + args[0] : args[0] );\r\n\r\n\t\t// ...and how many items were added to or removed from the array\r\n\t\taddedItems = Math.max( 0, args.length - 2 );\r\n\t\tremovedItems = ( args[1] !== undefined ? args[1] : this.length - start );\r\n\r\n\t\tbalance = addedItems - removedItems;\r\n\r\n\t\tif ( !balance ) {\r\n\t\t\t// The array length hasn't changed - we don't need to add or remove anything\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// If more items were removed than added, we need to remove some things from the DOM\r\n\t\tif ( balance < 0 ) {\r\n\t\t\tend = start - balance;\r\n\r\n\t\t\tfor ( i=start; i<end; i+=1 ) {\r\n\t\t\t\tthis.fragments[i].teardown( true );\r\n\t\t\t}\r\n\r\n\t\t\t// Keep in sync\r\n\t\t\tthis.fragments.splice( start, -balance );\r\n\t\t}\r\n\r\n\t\t// Otherwise we need to add some things to the DOM\r\n\t\telse {\r\n\t\t\tend = start + balance;\r\n\r\n\t\t\t// Figure out where these new nodes need to be inserted\r\n\t\t\tinsertionPoint = ( this.fragments[ start ] ? this.fragments[ start ].firstNode() : this.parentFragment.findNextNode( this ) );\r\n\r\n\t\t\t// Make room for the new fragments. (Just trust me, this works...)\r\n\t\t\tspliceArgs = [ start, 0 ].concat( new Array( balance ) );\r\n\t\t\tthis.fragments.splice.apply( this.fragments, spliceArgs );\r\n\r\n\t\t\tfor ( i=start; i<end; i+=1 ) {\r\n\t\t\t\tfragmentOptions.contextStack = this.contextStack.concat( this.keypath + '.' + i );\r\n\t\t\t\tfragmentOptions.index = i;\r\n\r\n\t\t\t\tthis.fragments[i] = this.createFragment( fragmentOptions );\r\n\t\t\t}\r\n\r\n\t\t\t// Append docfrag in front of insertion point\r\n\t\t\tthis.parentNode.insertBefore( this.docFrag, insertionPoint );\r\n\t\t}\r\n\r\n\t\tthis.length += balance;\r\n\r\n\r\n\t\t// Now we need to reassign existing fragments (e.g. items.4 -> items.3 - the keypaths,\r\n\t\t// context stacks and index refs will have changed)\r\n\t\treassignStart = ( start + addedItems );\r\n\r\n\t\treassignFragments( this.root, this, reassignStart, this.length, balance );\r\n\t},\r\n\r\n\tteardown: function ( detach ) {\r\n\t\tthis.teardownFragments( detach );\r\n\r\n\t\tteardown( this );\r\n\t},\r\n\r\n\tfirstNode: function () {\r\n\t\tif ( this.fragments[0] ) {\r\n\t\t\treturn this.fragments[0].firstNode();\r\n\t\t}\r\n\r\n\t\treturn this.parentFragment.findNextNode( this );\r\n\t},\r\n\r\n\tfindNextNode: function ( fragment ) {\r\n\t\tif ( this.fragments[ fragment.index + 1 ] ) {\r\n\t\t\treturn this.fragments[ fragment.index + 1 ].firstNode();\r\n\t\t}\r\n\r\n\t\treturn this.parentFragment.findNextNode( this );\r\n\t},\r\n\r\n\tteardownFragments: function ( detach ) {\r\n\t\tvar id;\r\n\r\n\t\twhile ( this.fragments.length ) {\r\n\t\t\tthis.fragments.shift().teardown( detach );\r\n\t\t}\r\n\r\n\t\tif ( this.fragmentsById ) {\r\n\t\t\tfor ( id in this.fragmentsById ) {\r\n\t\t\t\tif ( this.fragments[ id ] ) {\r\n\t\t\t\t\tthis.fragmentsById[ id ].teardown();\r\n\t\t\t\t\tthis.fragmentsById[ id ] = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\trender: function ( value ) {\r\n\t\tvar next, wrapped;\r\n\r\n\t\t// with sections, we need to get the fake value if we have a wrapped object\r\n\t\tif ( wrapped = this.root._wrapped[ this.keypath ] ) {\r\n\t\t\tvalue = wrapped.get();\r\n\t\t}\r\n\r\n\t\t// prevent sections from rendering multiple times (happens if\r\n\t\t// evaluators evaluate while update is happening)\r\n\t\tif ( this.rendering ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.rendering = true;\r\n\t\tupdateSection( this, value );\r\n\t\tthis.rendering = false;\r\n\r\n\t\t// if we have no new nodes to insert (i.e. the section length stayed the\r\n\t\t// same, or shrank), we don't need to go any further\r\n\t\tif ( this.docFrag && !this.docFrag.childNodes.length ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// if this isn't the initial render, we need to insert any new nodes in\r\n\t\t// the right place\r\n\t\tif ( !this.initialising ) {\r\n\t\t\t\r\n\t\t\t// Normally this is just a case of finding the next node, and inserting\r\n\t\t\t// items before it...\r\n\t\t\tnext = this.parentFragment.findNextNode( this );\r\n\r\n\t\t\tif ( next && ( next.parentNode === this.parentNode ) ) {\r\n\t\t\t\tthis.parentNode.insertBefore( this.docFrag, next );\r\n\t\t\t}\r\n\r\n\t\t\t// ...but in some edge cases the next node will not have been attached to\r\n\t\t\t// the DOM yet, in which case we append to the end of the parent node\r\n\t\t\telse {\r\n\t\t\t\t// TODO could there be a situation in which later nodes could have\r\n\t\t\t\t// been attached to the parent node, i.e. we need to find a sibling\r\n\t\t\t\t// to insert before?\r\n\t\t\t\tthis.parentNode.appendChild( this.docFrag );\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tcreateFragment: function ( options ) {\r\n\t\tvar fragment = new DomFragment( options );\r\n\t\t\r\n\t\tif ( this.docFrag ) {\r\n\t\t\tthis.docFrag.appendChild( fragment.docFrag );\r\n\t\t}\r\n\r\n\t\treturn fragment;\r\n\t},\r\n\r\n\ttoString: function () {\r\n\t\tvar str, i, len;\r\n\r\n\t\tstr = '';\r\n\r\n\t\ti = 0;\r\n\t\tlen = this.length;\r\n\r\n\t\tfor ( i=0; i<len; i+=1 ) {\r\n\t\t\tstr += this.fragments[i].toString();\r\n\t\t}\r\n\r\n\t\treturn str;\r\n\t}\r\n};\r\n// Plain text\r\nDomText = function ( options, docFrag ) {\r\n\tthis.type = TEXT;\r\n\tthis.descriptor = options.descriptor;\r\n\r\n\tif ( docFrag ) {\r\n\t\tthis.node = doc.createTextNode( options.descriptor );\r\n\t\tthis.parentNode = options.parentFragment.parentNode;\r\n\r\n\t\tdocFrag.appendChild( this.node );\r\n\t}\r\n};\r\n\r\nDomText.prototype = {\r\n\tteardown: function ( detach ) {\r\n\t\tif ( detach ) {\r\n\t\t\tthis.node.parentNode.removeChild( this.node );\r\n\t\t}\r\n\t},\r\n\r\n\tfirstNode: function () {\r\n\t\treturn this.node;\r\n\t},\r\n\r\n\ttoString: function () {\r\n\t\treturn ( '' + this.descriptor ).replace( '<', '&lt;' ).replace( '>', '&gt;' );\r\n\t}\r\n};\r\n// Triple\r\nDomTriple = function ( options, docFrag ) {\r\n\tthis.type = TRIPLE;\r\n\r\n\tif ( docFrag ) {\r\n\t\tthis.nodes = [];\r\n\t\tthis.docFrag = doc.createDocumentFragment();\r\n\t}\r\n\r\n\tthis.initialising = true;\r\n\tinitMustache( this, options );\r\n\tif ( docFrag ) {\r\n\t\tdocFrag.appendChild( this.docFrag );\r\n\t}\r\n\tthis.initialising = false;\r\n};\r\n\r\nDomTriple.prototype = {\r\n\tupdate: updateMustache,\r\n\tresolve: resolveMustache,\r\n\r\n\tteardown: function ( detach ) {\r\n\t\tvar node;\r\n\r\n\t\t// remove child nodes from DOM\r\n\t\tif ( detach ) {\r\n\t\t\twhile ( this.nodes.length ) {\r\n\t\t\t\tnode = this.nodes.pop();\r\n\t\t\t\tnode.parentNode.removeChild( node );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tteardown( this );\r\n\t},\r\n\r\n\tfirstNode: function () {\r\n\t\tif ( this.nodes[0] ) {\r\n\t\t\treturn this.nodes[0];\r\n\t\t}\r\n\r\n\t\treturn this.parentFragment.findNextNode( this );\r\n\t},\r\n\r\n\trender: function ( html ) {\r\n\t\tvar node;\r\n\r\n\t\tif ( !this.nodes ) {\r\n\t\t\t// looks like we're in a server environment...\r\n\t\t\t// nothing to see here, move along\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// remove existing nodes\r\n\t\twhile ( this.nodes.length ) {\r\n\t\t\tnode = this.nodes.pop();\r\n\t\t\tnode.parentNode.removeChild( node );\r\n\t\t}\r\n\r\n\t\tif ( html === undefined ) {\r\n\t\t\tthis.nodes = [];\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// get new nodes\r\n\t\tthis.nodes = insertHtml( html, this.parentNode.tagName, this.docFrag );\r\n\r\n\t\tif ( !this.initialising ) {\r\n\t\t\tthis.parentNode.insertBefore( this.docFrag, this.parentFragment.findNextNode( this ) );\r\n\t\t}\r\n\t},\r\n\r\n\ttoString: function () {\r\n\t\treturn ( this.value !== undefined ? this.value : '' );\r\n\t}\r\n};\r\nStringFragment = function ( options ) {\r\n\tinitFragment( this, options );\r\n};\r\n\r\nStringFragment.prototype = {\r\n\tcreateItem: function ( options ) {\r\n\t\tif ( typeof options.descriptor === 'string' ) {\r\n\t\t\treturn new StringText( options.descriptor );\r\n\t\t}\r\n\r\n\t\tswitch ( options.descriptor.t ) {\r\n\t\t\tcase INTERPOLATOR: return new StringInterpolator( options );\r\n\t\t\tcase TRIPLE: return new StringInterpolator( options );\r\n\t\t\tcase SECTION: return new StringSection( options );\r\n\r\n\t\t\tdefault: throw 'Something went wrong in a rather interesting way';\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tbubble: function () {\r\n\t\tthis.owner.bubble();\r\n\t},\r\n\r\n\tteardown: function () {\r\n\t\tvar numItems, i;\r\n\r\n\t\tnumItems = this.items.length;\r\n\t\tfor ( i=0; i<numItems; i+=1 ) {\r\n\t\t\tthis.items[i].teardown();\r\n\t\t}\r\n\t},\r\n\r\n\tgetValue: function () {\r\n\t\tvar value;\r\n\t\t\r\n\t\t// Accommodate boolean attributes\r\n\t\tif ( this.items.length === 1 && this.items[0].type === INTERPOLATOR ) {\r\n\t\t\tvalue = this.items[0].value;\r\n\t\t\tif ( value !== undefined ) {\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn this.toString();\r\n\t},\r\n\r\n\ttoString: function () {\r\n\t\treturn this.items.join( '' );\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\t\tvar value = this.getValue();\r\n\r\n\t\tif ( typeof value === 'string' ) {\r\n\t\t\ttry {\r\n\t\t\t\tvalue = JSON.parse( value );\r\n\t\t\t} catch ( err ) {\r\n\t\t\t\t// value = value\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn value;\r\n\t}\r\n};\r\n// Interpolator or Triple\r\nStringInterpolator = function ( options ) {\r\n\tthis.type = INTERPOLATOR;\r\n\tinitMustache( this, options );\r\n};\r\n\r\nStringInterpolator.prototype = {\r\n\tupdate: updateMustache,\r\n\tresolve: resolveMustache,\r\n\r\n\trender: function ( value ) {\r\n\t\tthis.value = value;\r\n\t\tthis.parentFragment.bubble();\r\n\t},\r\n\r\n\tteardown: function () {\r\n\t\tteardown( this );\r\n\t},\r\n\r\n\ttoString: function () {\r\n\t\treturn ( this.value === undefined ? '' : this.value );\r\n\t}\r\n};\r\n// Section\r\nStringSection = function ( options ) {\r\n\tthis.type = SECTION;\r\n\tthis.fragments = [];\r\n\tthis.length = 0;\r\n\r\n\tinitMustache( this, options );\r\n};\r\n\r\nStringSection.prototype = {\r\n\tupdate: updateMustache,\r\n\tresolve: resolveMustache,\r\n\r\n\tteardown: function () {\r\n\t\tthis.teardownFragments();\r\n\r\n\t\tteardown( this );\r\n\t},\r\n\r\n\tteardownFragments: function () {\r\n\t\twhile ( this.fragments.length ) {\r\n\t\t\tthis.fragments.shift().teardown();\r\n\t\t}\r\n\t\tthis.length = 0;\r\n\t},\r\n\r\n\tbubble: function () {\r\n\t\tthis.value = this.fragments.join( '' );\r\n\t\tthis.parentFragment.bubble();\r\n\t},\r\n\r\n\trender: function ( value ) {\r\n\t\tvar wrapped;\r\n\r\n\t\t// with sections, we need to get the fake value if we have a wrapped object\r\n\t\tif ( wrapped = this.root._wrapped[ this.keypath ] ) {\r\n\t\t\tvalue = wrapped.get();\r\n\t\t}\r\n\r\n\t\tupdateSection( this, value );\r\n\t\tthis.parentFragment.bubble();\r\n\t},\r\n\r\n\tcreateFragment: function ( options ) {\r\n\t\treturn new StringFragment( options );\r\n\t},\r\n\r\n\ttoString: function () {\r\n\t\treturn this.fragments.join( '' );\r\n\t}\r\n};\r\n// Plain text\r\nStringText = function ( text ) {\r\n\tthis.type = TEXT;\r\n\tthis.text = text;\r\n};\r\n\r\nStringText.prototype = {\r\n\ttoString: function () {\r\n\t\treturn this.text;\r\n\t},\r\n\r\n\tteardown: function () {} // no-op\r\n};\r\ngetEl = function ( input ) {\r\n\tvar output;\r\n\r\n\tif ( typeof window === 'undefined' || !doc || !input ) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// We already have a DOM node - no work to do. (Duck typing alert!)\r\n\tif ( input.nodeType ) {\r\n\t\treturn input;\r\n\t}\r\n\r\n\t// Get node from string\r\n\tif ( typeof input === 'string' ) {\r\n\t\t// try ID first\r\n\t\toutput = doc.getElementById( input );\r\n\r\n\t\t// then as selector, if possible\r\n\t\tif ( !output && doc.querySelector ) {\r\n\t\t\toutput = doc.querySelector( input );\r\n\t\t}\r\n\r\n\t\t// did it work?\r\n\t\tif ( output.nodeType ) {\r\n\t\t\treturn output;\r\n\t\t}\r\n\t}\r\n\r\n\t// If we've been given a collection (jQuery, Zepto etc), extract the first item\r\n\tif ( input[0] && input[0].nodeType ) {\r\n\t\treturn input[0];\r\n\t}\r\n\r\n\treturn null;\r\n};\r\ntoString = Object.prototype.toString;\r\n\r\n// thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\r\nisArray = function ( obj ) {\r\n\treturn toString.call( obj ) === '[object Array]';\r\n};\r\n\r\nisEqual = function ( a, b ) {\r\n\tif ( a === null && b === null ) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\tif ( typeof a === 'object' || typeof b === 'object' ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn a === b;\r\n};\r\n\r\n// http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric\r\nisNumeric = function ( n ) {\r\n\treturn !isNaN( parseFloat( n ) ) && isFinite( n );\r\n};\r\n\r\nisObject = function ( obj ) {\r\n\treturn ( typeof obj === 'object' && toString.call( obj ) === '[object Object]' );\r\n};\r\n// We're not using a constructor here because it's convenient (and more\r\n// efficient) to pass e.g. transitionManager.pop as a callback, rather\r\n// than wrapping a prototype method in an anonymous function each time\r\nmakeTransitionManager = function ( root, callback ) {\r\n\tvar transitionManager, nodesToDetach, detachNodes, nodeHasNoTransitioningChildren;\r\n\r\n\tnodesToDetach = [];\r\n\r\n\t// detach any nodes which a) need to be detached and b) have no child nodes\r\n\t// which are actively transitioning. This will be called each time a\r\n\t// transition completes\r\n\tdetachNodes = function () {\r\n\t\tvar i, node;\r\n\r\n\t\ti = nodesToDetach.length;\r\n\t\twhile ( i-- ) {\r\n\t\t\tnode = nodesToDetach[i];\r\n\r\n\t\t\t// see if this node can be detached yet\r\n\t\t\tif ( nodeHasNoTransitioningChildren( node ) ) {\r\n\t\t\t\tnode.parentNode.removeChild( node );\r\n\t\t\t\tnodesToDetach.splice( i, 1 );\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tnodeHasNoTransitioningChildren = function ( node ) {\r\n\t\tvar i, candidate;\r\n\r\n\t\ti = transitionManager.active.length;\r\n\t\twhile ( i-- ) {\r\n\t\t\tcandidate = transitionManager.active[i];\r\n\r\n\t\t\tif ( node.contains( candidate ) ) {\r\n\t\t\t\t// fail as soon as possible\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t};\r\n\r\n\ttransitionManager = {\r\n\t\tactive: [],\r\n\t\tpush: function ( node ) {\r\n\t\t\ttransitionManager.active[ transitionManager.active.length ] = node;\r\n\t\t},\r\n\t\tpop: function ( node ) {\r\n\t\t\ttransitionManager.active.splice( transitionManager.active.indexOf( node ), 1 );\r\n\t\t\t\r\n\t\t\tdetachNodes();\r\n\r\n\t\t\tif ( !transitionManager.active.length && transitionManager._ready ) {\r\n\t\t\t\ttransitionManager.complete();\r\n\t\t\t}\r\n\t\t},\r\n\t\tcomplete: function () {\r\n\t\t\tif ( callback ) {\r\n\t\t\t\tcallback.call( root );\r\n\t\t\t}\r\n\t\t},\r\n\t\tready: function () {\r\n\t\t\tdetachNodes();\r\n\r\n\t\t\ttransitionManager._ready = true;\r\n\t\t\tif ( !transitionManager.active.length ) {\r\n\t\t\t\ttransitionManager.complete();\r\n\t\t\t}\r\n\t\t},\r\n\t\tdetachWhenReady: function ( node ) {\r\n\t\t\tnodesToDetach[ nodesToDetach.length ] = node;\r\n\t\t}\r\n\t};\r\n\r\n\treturn transitionManager;\r\n};\r\nvar normaliseKeypath;\r\n\r\n(function () {\r\n\r\n\tvar pattern = /\\[\\s*([0-9]|[1-9][0-9]+)\\s*\\]/g;\r\n\r\n\tnormaliseKeypath = function ( keypath ) {\r\n\t\treturn keypath.replace( pattern, '.$1' );\r\n\t};\r\n\r\n}());\r\n\r\nvar ElementStub;\r\n\r\n(function () {\r\n\r\n\tvar voidElementNames,\r\n\t\tallElementNames,\r\n\t\tmapToLowerCase,\r\n\t\tsvgCamelCaseElements,\r\n\t\tsvgCamelCaseElementsMap,\r\n\t\tsvgCamelCaseAttributes,\r\n\t\tsvgCamelCaseAttributesMap,\r\n\t\tclosedByParentClose,\r\n\t\tsiblingsByTagName,\r\n\t\tonPattern,\r\n\t\tsanitize,\r\n\t\tfilterAttrs,\r\n\t\tgetFrag,\r\n\t\tprocessProxy,\r\n\t\tjsonifyProxy,\r\n\t\tcamelCase;\r\n\r\n\tElementStub = function ( firstToken, parser, preserveWhitespace ) {\r\n\t\tvar next, attrs, filtered, proxies, item, i, attr;\r\n\r\n\t\tthis.lcTag = firstToken.name.toLowerCase();\r\n\r\n\t\tparser.pos += 1;\r\n\r\n\t\t// TODO is this the right way to deal with component naming?\r\n\t\tif ( this.lcTag.substr( 0, 3 ) === 'rv-' ) {\r\n\t\t\tthis.component = camelCase( firstToken.name.substring( 3 ) );\r\n\r\n\t\t\tif ( firstToken.attrs ) {\r\n\t\t\t\tthis.attributes = [];\r\n\t\t\t\ti = firstToken.attrs.length;\r\n\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\tattr = firstToken.attrs[i];\r\n\r\n\t\t\t\t\tthis.attributes[i] = {\r\n\t\t\t\t\t\tname: attr.name,\r\n\t\t\t\t\t\tvalue: attr.value ? getFragmentStubFromTokens( attr.value ) : null\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\telse {\r\n\t\t\t// enforce lower case tag names by default. HTML doesn't care. SVG does, so if we see an SVG tag\r\n\t\t\t// that should be camelcased, camelcase it\r\n\t\t\tthis.tag = ( svgCamelCaseElementsMap[ this.lcTag ] ? svgCamelCaseElementsMap[ this.lcTag ] : this.lcTag );\r\n\r\n\t\t\t// if this is a <pre> element, preserve whitespace within\r\n\t\t\tpreserveWhitespace = ( preserveWhitespace || this.lcTag === 'pre' );\r\n\r\n\t\t\tif ( firstToken.attrs ) {\r\n\t\t\t\tfiltered = filterAttrs( firstToken.attrs );\r\n\t\t\t\t\r\n\t\t\t\tattrs = filtered.attrs;\r\n\t\t\t\tproxies = filtered.proxies;\r\n\r\n\t\t\t\t// remove event attributes (e.g. onclick='doSomething()') if we're sanitizing\r\n\t\t\t\tif ( parser.options.sanitize && parser.options.sanitize.eventAttributes ) {\r\n\t\t\t\t\tattrs = attrs.filter( sanitize );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( attrs.length ) {\r\n\t\t\t\t\tthis.attributes = attrs.map( getFrag );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( proxies.length ) {\r\n\t\t\t\t\tthis.proxies = proxies.map( processProxy );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// TODO rename this helper function\r\n\t\t\t\tif ( filtered.intro ) {\r\n\t\t\t\t\tthis.intro = processProxy( filtered.intro );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( filtered.outro ) {\r\n\t\t\t\t\tthis.outro = processProxy( filtered.outro );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\r\n\t\tif ( firstToken.selfClosing ) {\r\n\t\t\tthis.selfClosing = true;\r\n\t\t}\r\n\r\n\t\tif ( voidElementNames.indexOf( this.lcTag ) !== -1 ) {\r\n\t\t\tthis.isVoid = true;\r\n\t\t}\r\n\r\n\t\t// if self-closing or a void element, close\r\n\t\tif ( this.selfClosing || this.isVoid ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.siblings = siblingsByTagName[ this.lcTag ];\r\n\r\n\t\tthis.items = [];\r\n\r\n\t\tnext = parser.next();\r\n\t\twhile ( next ) {\r\n\r\n\t\t\t// section closing mustache should also close this element, e.g.\r\n\t\t\t// <ul>{{#items}}<li>{{content}}{{/items}}</ul>\r\n\t\t\tif ( next.mustacheType === CLOSING ) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif ( next.type === TAG ) {\r\n\r\n\t\t\t\t// closing tag\r\n\t\t\t\tif ( next.closing ) {\r\n\t\t\t\t\t// it's a closing tag, which means this element is closed...\r\n\t\t\t\t\tif ( next.name.toLowerCase() === this.lcTag ) {\r\n\t\t\t\t\t\tparser.pos += 1;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// sibling element, which closes this element implicitly\r\n\t\t\t\telse if ( this.siblings && ( this.siblings.indexOf( next.name.toLowerCase() ) !== -1 ) ) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t\tthis.items[ this.items.length ] = getItem( parser );\r\n\r\n\t\t\tnext = parser.next();\r\n\t\t}\r\n\r\n\r\n\t\t// if we're not preserving whitespace, we can eliminate inner leading and trailing whitespace\r\n\t\tif ( !preserveWhitespace ) {\r\n\t\t\titem = this.items[0];\r\n\t\t\tif ( item && item.type === TEXT ) {\r\n\t\t\t\titem.text = item.text.replace( leadingWhitespace, '' );\r\n\t\t\t\tif ( !item.text ) {\r\n\t\t\t\t\tthis.items.shift();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\titem = this.items[ this.items.length - 1 ];\r\n\t\t\tif ( item && item.type === TEXT ) {\r\n\t\t\t\titem.text = item.text.replace( trailingWhitespace, '' );\r\n\t\t\t\tif ( !item.text ) {\r\n\t\t\t\t\tthis.items.pop();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tElementStub.prototype = {\r\n\t\ttoJSON: function ( noStringify ) {\r\n\t\t\tvar json, name, value, proxy, i, len;\r\n\r\n\t\t\tif ( this[ 'json_' + noStringify ] ) {\r\n\t\t\t\treturn this[ 'json_' + noStringify ];\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.component ) {\r\n\t\t\t\tjson = {\r\n\t\t\t\t\tt: COMPONENT,\r\n\t\t\t\t\te: this.component\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\tjson = {\r\n\t\t\t\t\tt: ELEMENT,\r\n\t\t\t\t\te: this.tag\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.attributes && this.attributes.length ) {\r\n\t\t\t\tjson.a = {};\r\n\r\n\t\t\t\tlen = this.attributes.length;\r\n\t\t\t\tfor ( i=0; i<len; i+=1 ) {\r\n\t\t\t\t\tname = this.attributes[i].name;\r\n\r\n\t\t\t\t\tif ( json.a[ name ] ) {\r\n\t\t\t\t\t\tthrow new Error( 'You cannot have multiple attributes with the same name' );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// empty attributes (e.g. autoplay, checked)\r\n\t\t\t\t\tif( this.attributes[i].value === null ) {\r\n\t\t\t\t\t\tvalue = null;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvalue = jsonifyStubs( this.attributes[i].value.items, noStringify );\t\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tjson.a[ name ] = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.items && this.items.length ) {\r\n\t\t\t\tjson.f = jsonifyStubs( this.items, noStringify );\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.proxies && this.proxies.length ) {\r\n\t\t\t\tjson.v = {};\r\n\r\n\t\t\t\tlen = this.proxies.length;\r\n\t\t\t\tfor ( i=0; i<len; i+=1 ) {\r\n\t\t\t\t\tproxy = this.proxies[i];\r\n\r\n\t\t\t\t\tjson.v[ proxy.domEventName ] = jsonifyProxy( proxy );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.intro ) {\r\n\t\t\t\tif ( this.intro.args ) {\r\n\t\t\t\t\tjson.t1 = {\r\n\t\t\t\t\t\tn: this.intro.name,\r\n\t\t\t\t\t\ta: this.intro.args\r\n\t\t\t\t\t};\r\n\t\t\t\t} else if ( this.intro.dynamicArgs ) {\r\n\t\t\t\t\tjson.t1 = {\r\n\t\t\t\t\t\tn: this.intro.name,\r\n\t\t\t\t\t\td: jsonifyStubs( this.intro.dynamicArgs.items, noStringify )\r\n\t\t\t\t\t};\r\n\t\t\t\t} else {\r\n\t\t\t\t\tjson.t1 = this.intro.name;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.outro ) {\r\n\t\t\t\tif ( this.outro.args ) {\r\n\t\t\t\t\tjson.t2 = {\r\n\t\t\t\t\t\tn: this.outro.name,\r\n\t\t\t\t\t\ta: this.outro.args\r\n\t\t\t\t\t};\r\n\t\t\t\t} else if ( this.outro.dynamicArgs ) {\r\n\t\t\t\t\tjson.t2 = {\r\n\t\t\t\t\t\tn: this.outro.name,\r\n\t\t\t\t\t\td: jsonifyStubs( this.outro.dynamicArgs.items, noStringify )\r\n\t\t\t\t\t};\r\n\t\t\t\t} else {\r\n\t\t\t\t\tjson.t2 = this.outro.name;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis[ 'json_' + noStringify ] = json;\r\n\t\t\treturn json;\r\n\t\t},\r\n\r\n\t\ttoString: function () {\r\n\t\t\tvar str, i, len, attrStr, name, attrValueStr, fragStr, isVoid;\r\n\r\n\t\t\tif ( this.str !== undefined ) {\r\n\t\t\t\treturn this.str;\r\n\t\t\t}\r\n\r\n\t\t\t// components can't be stringified\r\n\t\t\tif ( this.component ) {\r\n\t\t\t\treturn ( this.str = false );\r\n\t\t\t}\r\n\r\n\t\t\t// if this isn't an HTML element, it can't be stringified (since the only reason to stringify an\r\n\t\t\t// element is to use with innerHTML, and SVG doesn't support that method.\r\n\t\t\t// Note: table elements and select children are excluded from this, because IE (of course)\r\n\t\t\t// fucks up when you use innerHTML with them\r\n\t\t\tif ( allElementNames.indexOf( this.tag.toLowerCase() ) === -1 ) {\r\n\t\t\t\treturn ( this.str = false );\r\n\t\t\t}\r\n\r\n\t\t\t// do we have proxies or transitions? if so we can't use innerHTML\r\n\t\t\tif ( this.proxies || this.intro || this.outro ) {\r\n\t\t\t\treturn ( this.str = false );\r\n\t\t\t}\r\n\r\n\t\t\t// see if children can be stringified (i.e. don't contain mustaches)\r\n\t\t\tfragStr = stringifyStubs( this.items );\r\n\t\t\tif ( fragStr === false ) {\r\n\t\t\t\treturn ( this.str = false );\r\n\t\t\t}\r\n\r\n\t\t\t// is this a void element?\r\n\t\t\tisVoid = ( voidElementNames.indexOf( this.tag.toLowerCase() ) !== -1 );\r\n\r\n\t\t\tstr = '<' + this.tag;\r\n\t\t\t\r\n\t\t\tif ( this.attributes ) {\r\n\t\t\t\tfor ( i=0, len=this.attributes.length; i<len; i+=1 ) {\r\n\r\n\t\t\t\t\tname = this.attributes[i].name;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// does this look like a namespaced attribute? if so we can't stringify it\r\n\t\t\t\t\tif ( name.indexOf( ':' ) !== -1 ) {\r\n\t\t\t\t\t\treturn ( this.str = false );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// if this element has an id attribute, it can't be stringified (since references are stored\r\n\t\t\t\t\t// in ractive.nodes). Similarly, intro and outro transitions\r\n\t\t\t\t\tif ( name === 'id' || name === 'intro' || name === 'outro' ) {\r\n\t\t\t\t\t\treturn ( this.str = false );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tattrStr = ' ' + name;\r\n\r\n\t\t\t\t\t// empty attributes\r\n\t\t\t\t\tif ( this.attributes[i].value !== null ) {\r\n\t\t\t\t\t\tattrValueStr = this.attributes[i].value.toString();\r\n\r\n\t\t\t\t\t\tif ( attrValueStr === false ) {\r\n\t\t\t\t\t\t\treturn ( this.str = false );\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( attrValueStr !== '' ) {\r\n\t\t\t\t\t\t\tattrStr += '=';\r\n\r\n\t\t\t\t\t\t\t// does it need to be quoted?\r\n\t\t\t\t\t\t\tif ( /[\\s\"'=<>`]/.test( attrValueStr ) ) {\r\n\t\t\t\t\t\t\t\tattrStr += '\"' + attrValueStr.replace( /\"/g, '&quot;' ) + '\"';\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tattrStr += attrValueStr;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tstr += attrStr;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// if this isn't a void tag, but is self-closing, add a solidus. Aaaaand, we're done\r\n\t\t\tif ( this.selfClosing && !isVoid ) {\r\n\t\t\t\tstr += '/>';\r\n\t\t\t\treturn ( this.str = str );\r\n\t\t\t}\r\n\r\n\t\t\tstr += '>';\r\n\r\n\t\t\t// void element? we're done\r\n\t\t\tif ( isVoid ) {\r\n\t\t\t\treturn ( this.str = str );\r\n\t\t\t}\r\n\r\n\t\t\t// if this has children, add them\r\n\t\t\tstr += fragStr;\r\n\r\n\t\t\tstr += '</' + this.tag + '>';\r\n\t\t\treturn ( this.str = str );\r\n\t\t}\r\n\t};\r\n\r\n\r\n\tvoidElementNames = 'area base br col command embed hr img input keygen link meta param source track wbr'.split( ' ' );\r\n\tallElementNames = 'a abbr acronym address applet area b base basefont bdo big blockquote body br button caption center cite code col colgroup dd del dfn dir div dl dt em fieldset font form frame frameset h1 h2 h3 h4 h5 h6 head hr html i iframe img input ins isindex kbd label legend li link map menu meta noframes noscript object ol p param pre q s samp script select small span strike strong style sub sup textarea title tt u ul var article aside audio bdi canvas command data datagrid datalist details embed eventsource figcaption figure footer header hgroup keygen mark meter nav output progress ruby rp rt section source summary time track video wbr'.split( ' ' );\r\n\tclosedByParentClose = 'li dd rt rp optgroup option tbody tfoot tr td th'.split( ' ' );\r\n\r\n\tsvgCamelCaseElements = 'altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern'.split( ' ' );\r\n\tsvgCamelCaseAttributes = 'attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef glyphRef gradientTransform gradientTransform gradientUnits gradientUnits kernelMatrix kernelUnitLength kernelUnitLength kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent specularExponent spreadMethod spreadMethod startOffset stdDeviation stitchTiles surfaceScale surfaceScale systemLanguage tableValues targetX targetY textLength textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan'.split( ' ' );\r\n\t\r\n\tmapToLowerCase = function ( items ) {\r\n\t\tvar map = {}, i = items.length;\r\n\t\twhile ( i-- ) {\r\n\t\t\tmap[ items[i].toLowerCase() ] = items[i];\r\n\t\t}\r\n\t\treturn map;\r\n\t};\r\n\r\n\tsvgCamelCaseElementsMap = mapToLowerCase( svgCamelCaseElements );\r\n\tsvgCamelCaseAttributesMap = mapToLowerCase( svgCamelCaseAttributes );\r\n\r\n\tsiblingsByTagName = {\r\n\t\tli: [ 'li' ],\r\n\t\tdt: [ 'dt', 'dd' ],\r\n\t\tdd: [ 'dt', 'dd' ],\r\n\t\tp: 'address article aside blockquote dir div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr menu nav ol p pre section table ul'.split( ' ' ),\r\n\t\trt: [ 'rt', 'rp' ],\r\n\t\trp: [ 'rp', 'rt' ],\r\n\t\toptgroup: [ 'optgroup' ],\r\n\t\toption: [ 'option', 'optgroup' ],\r\n\t\tthead: [ 'tbody', 'tfoot' ],\r\n\t\ttbody: [ 'tbody', 'tfoot' ],\r\n\t\ttr: [ 'tr' ],\r\n\t\ttd: [ 'td', 'th' ],\r\n\t\tth: [ 'td', 'th' ]\r\n\t};\r\n\r\n\tonPattern = /^on[a-zA-Z]/;\r\n\r\n\tsanitize = function ( attr ) {\r\n\t\tvar valid = !onPattern.test( attr.name );\r\n\t\treturn valid;\r\n\t};\r\n\r\n\tfilterAttrs = function ( items ) {\r\n\t\tvar attrs, proxies, filtered, i, len, item;\r\n\r\n\t\tfiltered = {};\r\n\t\tattrs = [];\r\n\t\tproxies = [];\r\n\r\n\t\tlen = items.length;\r\n\t\tfor ( i=0; i<len; i+=1 ) {\r\n\t\t\titem = items[i];\r\n\r\n\t\t\t// Transition?\r\n\t\t\tif ( item.name === 'intro' ) {\r\n\t\t\t\tif ( filtered.intro ) {\r\n\t\t\t\t\tthrow new Error( 'An element can only have one intro transition' );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfiltered.intro = item;\r\n\t\t\t} else if ( item.name === 'outro' ) {\r\n\t\t\t\tif ( filtered.outro ) {\r\n\t\t\t\t\tthrow new Error( 'An element can only have one outro transition' );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfiltered.outro = item;\r\n\t\t\t}\r\n\r\n\t\t\t// Proxy?\r\n\t\t\telse if ( item.name.substr( 0, 6 ) === 'proxy-' ) {\r\n\t\t\t\titem.name = item.name.substring( 6 );\r\n\t\t\t\tproxies[ proxies.length ] = item;\r\n\t\t\t}\r\n\r\n\t\t\telse if ( item.name.substr( 0, 3 ) === 'on-' ) {\r\n\t\t\t\titem.name = item.name.substring( 3 );\r\n\t\t\t\tproxies[ proxies.length ] = item;\r\n\t\t\t}\r\n\r\n\t\t\t// Attribute?\r\n\t\t\telse {\r\n\t\t\t\tattrs[ attrs.length ] = item;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfiltered.attrs = attrs;\r\n\t\tfiltered.proxies = proxies;\r\n\r\n\t\treturn filtered;\r\n\t};\r\n\r\n\tgetFrag = function ( attr ) {\r\n\t\tvar lcName = attr.name.toLowerCase();\r\n\r\n\t\treturn {\r\n\t\t\tname: ( svgCamelCaseAttributesMap[ lcName ] ? svgCamelCaseAttributesMap[ lcName ] : lcName ),\r\n\t\t\tvalue: attr.value ? getFragmentStubFromTokens( attr.value ) : null\r\n\t\t};\r\n\t};\r\n\r\n\tprocessProxy = function ( proxy ) {\r\n\t\tvar processed, tokens, token, colonIndex, throwError, proxyName, proxyArgs;\r\n\r\n\t\tthrowError = function () {\r\n\t\t\tthrow new Error( 'Illegal proxy event' );\r\n\t\t};\r\n\r\n\t\tif ( !proxy.name || !proxy.value ) {\r\n\t\t\tthrowError();\r\n\t\t}\r\n\r\n\t\tprocessed = { domEventName: proxy.name };\r\n\r\n\t\ttokens = proxy.value;\r\n\r\n\t\tproxyName = [];\r\n\t\tproxyArgs = [];\r\n\r\n\t\twhile ( tokens.length ) {\r\n\t\t\ttoken = tokens.shift();\r\n\r\n\t\t\tif ( token.type === TEXT ) {\r\n\t\t\t\tcolonIndex = token.value.indexOf( ':' );\r\n\t\t\t\t\r\n\t\t\t\tif ( colonIndex === -1 ) {\r\n\t\t\t\t\tproxyName[ proxyName.length ] = token;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// is the colon the first character?\r\n\t\t\t\t\tif ( colonIndex ) {\r\n\t\t\t\t\t\t// no\r\n\t\t\t\t\t\tproxyName[ proxyName.length ] = {\r\n\t\t\t\t\t\t\ttype: TEXT,\r\n\t\t\t\t\t\t\tvalue: token.value.substr( 0, colonIndex )\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// if there is anything after the colon in this token, treat\r\n\t\t\t\t\t// it as the first token of the proxyArgs fragment\r\n\t\t\t\t\tif ( token.value.length > colonIndex + 1 ) {\r\n\t\t\t\t\t\tproxyArgs[0] = {\r\n\t\t\t\t\t\t\ttype: TEXT,\r\n\t\t\t\t\t\t\tvalue: token.value.substring( colonIndex + 1 )\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\telse {\r\n\t\t\t\tproxyName[ proxyName.length ] = token;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tproxyArgs = proxyArgs.concat( tokens );\r\n\r\n\t\tif ( proxyName.length === 1 && proxyName[0].type === TEXT ) {\r\n\t\t\tprocessed.name = proxyName[0].value;\r\n\t\t} else {\r\n\t\t\tprocessed.name = proxyName;\r\n\t\t}\r\n\r\n\t\tif ( proxyArgs.length ) {\r\n\t\t\tif ( proxyArgs.length === 1 && proxyArgs[0].type === TEXT ) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tprocessed.args = JSON.parse( proxyArgs[0].value );\r\n\t\t\t\t} catch ( err ) {\r\n\t\t\t\t\tprocessed.args = proxyArgs[0].value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\telse {\r\n\t\t\t\tprocessed.dynamicArgs = proxyArgs;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn processed;\r\n\t};\r\n\r\n\tjsonifyProxy = function ( proxy ) {\r\n\t\tvar result, name;\r\n\r\n\t\tif ( typeof proxy.name === 'string' ) {\r\n\t\t\tif ( !proxy.args && !proxy.dynamicArgs ) {\r\n\t\t\t\treturn proxy.name;\r\n\t\t\t}\r\n\r\n\t\t\tname = proxy.name;\r\n\t\t} else {\r\n\t\t\tname = getFragmentStubFromTokens( proxy.name ).toJSON();\r\n\t\t}\r\n\r\n\t\tresult = { n: name };\r\n\r\n\t\tif ( proxy.args ) {\r\n\t\t\tresult.a = proxy.args;\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t\tif ( proxy.dynamicArgs ) {\r\n\t\t\tresult.d = getFragmentStubFromTokens( proxy.dynamicArgs ).toJSON();\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t};\r\n\r\n\tcamelCase = function ( hyphenatedStr ) {\r\n\t\treturn hyphenatedStr.replace( /-([a-zA-Z])/g, function ( match, $1 ) {\r\n\t\t\treturn $1.toUpperCase();\r\n\t\t});\r\n\t};\r\n\r\n\r\n}());\r\nvar ExpressionStub;\r\n\r\n(function () {\r\n\r\n\tvar getRefs, stringify, stringifyKey, identifier;\r\n\r\n\tExpressionStub = function ( token ) {\r\n\t\tthis.refs = [];\r\n\r\n\t\tgetRefs( token, this.refs );\r\n\t\tthis.str = stringify( token, this.refs );\r\n\t};\r\n\r\n\tExpressionStub.prototype = {\r\n\t\ttoJSON: function () {\r\n\t\t\tif ( this.json ) {\r\n\t\t\t\treturn this.json;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.json = {\r\n\t\t\t\tr: this.refs,\r\n\t\t\t\ts: this.str\r\n\t\t\t};\r\n\r\n\t\t\treturn this.json;\r\n\t\t}\r\n\t};\r\n\r\n\r\n\t// TODO maybe refactor this?\r\n\tgetRefs = function ( token, refs ) {\r\n\t\tvar i, list;\r\n\r\n\t\tif ( token.t === REFERENCE ) {\r\n\t\t\tif ( refs.indexOf( token.n ) === -1 ) {\r\n\t\t\t\trefs.unshift( token.n );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlist = token.o || token.m;\r\n\t\tif ( list ) {\r\n\t\t\tif ( isObject( list ) ) {\r\n\t\t\t\tgetRefs( list, refs );\r\n\t\t\t} else {\r\n\t\t\t\ti = list.length;\r\n\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\tgetRefs( list[i], refs );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( token.x ) {\r\n\t\t\tgetRefs( token.x, refs );\r\n\t\t}\r\n\r\n\t\tif ( token.r ) {\r\n\t\t\tgetRefs( token.r, refs );\r\n\t\t}\r\n\r\n\t\tif ( token.v ) {\r\n\t\t\tgetRefs( token.v, refs );\r\n\t\t}\r\n\t};\r\n\r\n\r\n\tstringify = function ( token, refs ) {\r\n\t\tvar map = function ( item ) {\r\n\t\t\treturn stringify( item, refs );\r\n\t\t};\r\n\r\n\t\tswitch ( token.t ) {\r\n\t\t\tcase BOOLEAN_LITERAL:\r\n\t\t\tcase GLOBAL:\r\n\t\t\tcase NUMBER_LITERAL:\r\n\t\t\treturn token.v;\r\n\r\n\t\t\tcase STRING_LITERAL:\r\n\t\t\treturn \"'\" + token.v.replace( /'/g, \"\\\\'\" ) + \"'\";\r\n\r\n\t\t\tcase ARRAY_LITERAL:\r\n\t\t\treturn '[' + ( token.m ? token.m.map( map ).join( ',' ) : '' ) + ']';\r\n\r\n\t\t\tcase OBJECT_LITERAL:\r\n\t\t\treturn '{' + ( token.m ? token.m.map( map ).join( ',' ) : '' ) + '}';\r\n\r\n\t\t\tcase KEY_VALUE_PAIR:\r\n\t\t\treturn stringifyKey( token.k ) + ':' + stringify( token.v, refs );\r\n\r\n\t\t\tcase PREFIX_OPERATOR:\r\n\t\t\treturn ( token.s === 'typeof' ? 'typeof ' : token.s ) + stringify( token.o, refs );\r\n\r\n\t\t\tcase INFIX_OPERATOR:\r\n\t\t\treturn stringify( token.o[0], refs ) + ( token.s.substr( 0, 2 ) === 'in' ? ' ' + token.s + ' ' : token.s ) + stringify( token.o[1], refs );\r\n\r\n\t\t\tcase INVOCATION:\r\n\t\t\treturn stringify( token.x, refs ) + '(' + ( token.o ? token.o.map( map ).join( ',' ) : '' ) + ')';\r\n\r\n\t\t\tcase BRACKETED:\r\n\t\t\treturn '(' + stringify( token.x, refs ) + ')';\r\n\r\n\t\t\tcase MEMBER:\r\n\t\t\treturn stringify( token.x, refs ) + stringify( token.r, refs );\r\n\r\n\t\t\tcase REFINEMENT:\r\n\t\t\treturn ( token.n ? '.' + token.n : '[' + stringify( token.x, refs ) + ']' );\r\n\r\n\t\t\tcase CONDITIONAL:\r\n\t\t\treturn stringify( token.o[0], refs ) + '?' + stringify( token.o[1], refs ) + ':' + stringify( token.o[2], refs );\r\n\r\n\t\t\tcase REFERENCE:\r\n\t\t\treturn '${' + refs.indexOf( token.n ) + '}';\r\n\r\n\t\t\tdefault:\r\n\t\t\tconsole.log( token );\r\n\t\t\tthrow new Error( 'Could not stringify expression token. This error is unexpected' );\r\n\t\t}\r\n\t};\r\n\r\n\tstringifyKey = function ( key ) {\r\n\t\tif ( key.t === STRING_LITERAL ) {\r\n\t\t\treturn identifier.test( key.v ) ? key.v : '\"' + key.v.replace( /\"/g, '\\\\\"' ) + '\"';\r\n\t\t}\r\n\r\n\t\tif ( key.t === NUMBER_LITERAL ) {\r\n\t\t\treturn key.v;\r\n\t\t}\r\n\r\n\t\treturn key;\r\n\t};\r\n\r\n\tidentifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\r\n\r\n}());\r\nvar FragmentStub = function ( parser, preserveWhitespace ) {\r\n\tvar items, item;\r\n\r\n\titems = this.items = [];\r\n\r\n\titem = getItem( parser, preserveWhitespace );\r\n\twhile ( item !== null ) {\r\n\t\titems[ items.length ] = item;\r\n\t\titem = getItem( parser, preserveWhitespace );\r\n\t}\r\n};\r\n\r\nFragmentStub.prototype = {\r\n\ttoJSON: function ( noStringify ) {\r\n\t\tvar json;\r\n\r\n\t\tif ( this[ 'json_' + noStringify ] ) {\r\n\t\t\treturn this[ 'json_' + noStringify ];\r\n\t\t}\r\n\r\n\t\tjson = this[ 'json_' + noStringify ] = jsonifyStubs( this.items, noStringify );\r\n\t\treturn json;\r\n\t},\r\n\r\n\ttoString: function () {\r\n\t\tif ( this.str !== undefined ) {\r\n\t\t\treturn this.str;\r\n\t\t}\r\n\r\n\t\tthis.str = stringifyStubs( this.items );\r\n\t\treturn this.str;\r\n\t}\r\n};\r\nvar MustacheStub = function ( token, parser ) {\r\n\tthis.type = ( token.type === TRIPLE ? TRIPLE : token.mustacheType );\r\n\r\n\tif ( token.ref ) {\r\n\t\tthis.ref = token.ref;\r\n\t}\r\n\t\r\n\tif ( token.expression ) {\r\n\t\tthis.expr = new ExpressionStub( token.expression );\r\n\t}\r\n\r\n\tparser.pos += 1;\r\n};\r\n\r\nMustacheStub.prototype = {\r\n\ttoJSON: function () {\r\n\t\tvar json;\r\n\r\n\t\tif ( this.json ) {\r\n\t\t\treturn this.json;\r\n\t\t}\r\n\r\n\t\tjson = {\r\n\t\t\tt: this.type\r\n\t\t};\r\n\r\n\t\tif ( this.ref ) {\r\n\t\t\tjson.r = this.ref;\r\n\t\t}\r\n\r\n\t\tif ( this.expr ) {\r\n\t\t\tjson.x = this.expr.toJSON();\r\n\t\t}\r\n\r\n\t\tthis.json = json;\r\n\t\treturn json;\r\n\t},\r\n\r\n\ttoString: function () {\r\n\t\t// mustaches cannot be stringified\r\n\t\treturn false;\r\n\t}\r\n};\r\nvar SectionStub = function ( firstToken, parser, preserveWhitespace ) {\r\n\tvar next;\r\n\r\n\tthis.ref = firstToken.ref;\r\n\tthis.indexRef = firstToken.indexRef;\r\n\r\n\tthis.inverted = ( firstToken.mustacheType === INVERTED );\r\n\r\n\tif ( firstToken.expression ) {\r\n\t\tthis.expr = new ExpressionStub( firstToken.expression );\r\n\t}\r\n\r\n\tparser.pos += 1;\r\n\r\n\tthis.items = [];\r\n\tnext = parser.next();\r\n\r\n\twhile ( next ) {\r\n\t\tif ( next.mustacheType === CLOSING ) {\r\n\t\t\tif ( ( next.ref.trim() === this.ref ) || this.expr ) {\r\n\t\t\t\tparser.pos += 1;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\telse {\r\n\t\t\t\tthrow new Error( 'Could not parse template: Illegal closing section' );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.items[ this.items.length ] = getItem( parser, preserveWhitespace );\r\n\t\tnext = parser.next();\r\n\t}\r\n};\r\n\r\nSectionStub.prototype = {\r\n\ttoJSON: function ( noStringify ) {\r\n\t\tvar json;\r\n\r\n\t\tif ( this.json ) {\r\n\t\t\treturn this.json;\r\n\t\t}\r\n\r\n\t\tjson = { t: SECTION };\r\n\r\n\t\tif ( this.ref ) {\r\n\t\t\tjson.r = this.ref;\r\n\t\t}\r\n\r\n\t\tif ( this.indexRef ) {\r\n\t\t\tjson.i = this.indexRef;\r\n\t\t}\r\n\r\n\t\tif ( this.inverted ) {\r\n\t\t\tjson.n = true;\r\n\t\t}\r\n\r\n\t\tif ( this.expr ) {\r\n\t\t\tjson.x = this.expr.toJSON();\r\n\t\t}\r\n\r\n\t\tif ( this.items.length ) {\r\n\t\t\tjson.f = jsonifyStubs( this.items, noStringify );\r\n\t\t}\r\n\r\n\t\tthis.json = json;\r\n\t\treturn json;\r\n\t},\r\n\r\n\ttoString: function () {\r\n\t\t// sections cannot be stringified\r\n\t\treturn false;\r\n\t}\r\n};\r\nvar TextStub;\r\n\r\n(function () {\r\n\t\r\n\tvar htmlEntities, controlCharacters, namedEntityPattern, hexEntityPattern, decimalEntityPattern, validateCode, decodeCharacterReferences, whitespace;\r\n\r\n\tTextStub = function ( token, preserveWhitespace ) {\r\n\t\tthis.type = TEXT;\r\n\t\tthis.text = ( preserveWhitespace ? token.value : token.value.replace( whitespace, ' ' ) );\r\n\t};\r\n\r\n\tTextStub.prototype = {\r\n\t\ttoJSON: function () {\r\n\t\t\t// this will be used within HTML, so we need to decode things like &amp;\r\n\t\t\treturn this.decoded || ( this.decoded = decodeCharacterReferences( this.text) );\r\n\t\t},\r\n\r\n\t\ttoString: function () {\r\n\t\t\t// this will be used as straight text\r\n\t\t\treturn this.text;\r\n\t\t}\r\n\t};\r\n\r\n\thtmlEntities = { quot: 34, amp: 38, apos: 39, lt: 60, gt: 62, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, 'int': 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830\t};\r\n\tcontrolCharacters = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376];\r\n\r\n\tnamedEntityPattern = new RegExp( '&(' + Object.keys( htmlEntities ).join( '|' ) + ');?', 'g' );\r\n\thexEntityPattern     = /&#x([0-9]+);?/g;\r\n\tdecimalEntityPattern = /&#([0-9]+);?/g;\r\n\r\n\t// some code points are verboten. If we were inserting HTML, the browser would replace the illegal\r\n\t// code points with alternatives in some cases - since we're bypassing that mechanism, we need\r\n\t// to replace them ourselves\r\n\t//\r\n\t// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters\r\n\tvalidateCode = function ( code ) {\r\n\t\tif ( !code ) {\r\n\t\t\treturn 65533;\r\n\t\t}\r\n\r\n\t\t// line feed becomes generic whitespace\r\n\t\tif ( code === 10 ) {\r\n\t\t\treturn 32;\r\n\t\t}\r\n\r\n\t\t// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)\r\n\t\tif ( code < 128 ) {\r\n\t\t\treturn code;\r\n\t\t}\r\n\r\n\t\t// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need\r\n\t\t// to correct the mistake or we'll end up with missing  signs and so on\r\n\t\tif ( code <= 159 ) {\r\n\t\t\treturn controlCharacters[ code - 128 ];\r\n\t\t}\r\n\r\n\t\t// basic multilingual plane\r\n\t\tif ( code < 55296 ) {\r\n\t\t\treturn code;\r\n\t\t}\r\n\r\n\t\t// UTF-16 surrogate halves\r\n\t\tif ( code <= 57343 ) {\r\n\t\t\treturn 65533;\r\n\t\t}\r\n\r\n\t\t// rest of the basic multilingual plane\r\n\t\tif ( code <= 65535 ) {\r\n\t\t\treturn code;\r\n\t\t}\r\n\r\n\t\t// TODO it's... not exactly clear what should happen with code points over this value. The\r\n\t\t// following seems to work. But I can't guarantee it works in China!\r\n\t\treturn 65533;\r\n\t};\r\n\r\n\tdecodeCharacterReferences = function ( html ) {\r\n\t\tvar result;\r\n\r\n\t\t// named entities\r\n\t\tresult = html.replace( namedEntityPattern, function ( match, name ) {\r\n\t\t\tif ( htmlEntities[ name ] ) {\r\n\t\t\t\treturn String.fromCharCode( htmlEntities[ name ] );\r\n\t\t\t}\r\n\r\n\t\t\treturn match;\r\n\t\t});\r\n\r\n\t\t// hex references\r\n\t\tresult = result.replace( hexEntityPattern, function ( match, hex ) {\r\n\t\t\treturn String.fromCharCode( validateCode( parseInt( hex, 16 ) ) );\r\n\t\t});\r\n\r\n\t\t// decimal references\r\n\t\tresult = result.replace( decimalEntityPattern, function ( match, charCode ) {\r\n\t\t\treturn String.fromCharCode( validateCode( charCode ) );\r\n\t\t});\r\n\r\n\t\treturn result;\r\n\t};\r\n\r\n\twhitespace = /\\s+/g;\r\n\r\n}());\r\ngetFragmentStubFromTokens = function ( tokens, options, preserveWhitespace ) {\r\n\tvar parser, stub;\r\n\r\n\tparser = {\r\n\t\tpos: 0,\r\n\t\ttokens: tokens || [],\r\n\t\tnext: function () {\r\n\t\t\treturn parser.tokens[ parser.pos ];\r\n\t\t},\r\n\t\toptions: options\r\n\t};\r\n\r\n\tstub = new FragmentStub( parser, preserveWhitespace );\r\n\r\n\treturn stub;\r\n};\r\nvar getExpression;\r\n\r\n// expression\r\n(function () {\r\n\tvar getExpressionList,\r\n\tmakePrefixSequenceMatcher,\r\n\tmakeInfixSequenceMatcher,\r\n\tgetBracketedExpression,\r\n\tgetPrimary,\r\n\tgetMemberOrInvocation,\r\n\tgetTypeOf,\r\n\tgetLogicalOr,\r\n\tgetConditional,\r\n\t\r\n\tgetDigits,\r\n\tgetExponent,\r\n\tgetFraction,\r\n\tgetInteger,\r\n\t\r\n\tgetReference,\r\n\tgetRefinement,\r\n\r\n\tgetLiteral,\r\n\tgetArrayLiteral,\r\n\tgetBooleanLiteral,\r\n\tgetNumberLiteral,\r\n\tgetStringLiteral,\r\n\tgetObjectLiteral,\r\n\r\n\tgetKeyValuePairs,\r\n\tgetKeyValuePair,\r\n\tgetKey,\r\n\r\n\tgetName,\r\n\r\n\tgetDotRefinement,\r\n\tgetArrayRefinement,\r\n\tgetArrayMember,\r\n\r\n\tglobals;\r\n\r\n\tgetExpression = function ( tokenizer ) {\r\n\t\t// The conditional operator is the lowest precedence operator (except yield,\r\n\t\t// assignment operators, and commas, none of which are supported), so we\r\n\t\t// start there. If it doesn't match, it 'falls through' to progressively\r\n\t\t// higher precedence operators, until it eventually matches (or fails to\r\n\t\t// match) a 'primary' - a literal or a reference. This way, the abstract syntax\r\n\t\t// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.\r\n\t\treturn getConditional( tokenizer );\r\n\t};\r\n\r\n\tgetExpressionList = function ( tokenizer ) {\r\n\t\tvar start, expressions, expr, next;\r\n\r\n\t\tstart = tokenizer.pos;\r\n\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\texpr = getExpression( tokenizer );\r\n\r\n\t\tif ( expr === null ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\texpressions = [ expr ];\r\n\r\n\t\t// allow whitespace between expression and ','\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\tif ( getStringMatch( tokenizer, ',' ) ) {\r\n\t\t\tnext = getExpressionList( tokenizer );\r\n\t\t\tif ( next === null ) {\r\n\t\t\t\ttokenizer.pos = start;\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\texpressions = expressions.concat( next );\r\n\t\t}\r\n\r\n\t\treturn expressions;\r\n\t};\r\n\r\n\tgetBracketedExpression = function ( tokenizer ) {\r\n\t\tvar start, expr;\r\n\r\n\t\tstart = tokenizer.pos;\r\n\r\n\t\tif ( !getStringMatch( tokenizer, '(' ) ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\texpr = getExpression( tokenizer );\r\n\t\tif ( !expr ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\tif ( !getStringMatch( tokenizer, ')' ) ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tt: BRACKETED,\r\n\t\t\tx: expr\r\n\t\t};\r\n\t};\r\n\r\n\tgetPrimary = function ( tokenizer ) {\r\n\t\treturn getLiteral( tokenizer )\r\n\t\t    || getReference( tokenizer )\r\n\t\t    || getBracketedExpression( tokenizer );\r\n\t};\r\n\r\n\tgetMemberOrInvocation = function ( tokenizer ) {\r\n\t\tvar current, expression, refinement, expressionList;\r\n\r\n\t\texpression = getPrimary( tokenizer );\r\n\r\n\t\tif ( !expression ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\twhile ( expression ) {\r\n\t\t\tcurrent = tokenizer.pos;\r\n\r\n\t\t\tif ( refinement = getRefinement( tokenizer ) ) {\r\n\t\t\t\texpression = {\r\n\t\t\t\t\tt: MEMBER,\r\n\t\t\t\t\tx: expression,\r\n\t\t\t\t\tr: refinement\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\telse if ( getStringMatch( tokenizer, '(' ) ) {\r\n\t\t\t\tallowWhitespace( tokenizer );\r\n\t\t\t\texpressionList = getExpressionList( tokenizer );\r\n\r\n\t\t\t\tallowWhitespace( tokenizer );\r\n\r\n\t\t\t\tif ( !getStringMatch( tokenizer, ')' ) ) {\r\n\t\t\t\t\ttokenizer.pos = current;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\texpression = {\r\n\t\t\t\t\tt: INVOCATION,\r\n\t\t\t\t\tx: expression\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif ( expressionList ) {\r\n\t\t\t\t\texpression.o = expressionList;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\telse {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn expression;\r\n\t};\r\n\r\n\t// right-to-left\r\n\tmakePrefixSequenceMatcher = function ( symbol, fallthrough ) {\r\n\t\treturn function ( tokenizer ) {\r\n\t\t\tvar start, expression;\r\n\r\n\t\t\tif ( !getStringMatch( tokenizer, symbol ) ) {\r\n\t\t\t\treturn fallthrough( tokenizer );\r\n\t\t\t}\r\n\r\n\t\t\tstart = tokenizer.pos;\r\n\r\n\t\t\tallowWhitespace( tokenizer );\r\n\r\n\t\t\texpression = getExpression( tokenizer );\r\n\t\t\tif ( !expression ) {\r\n\t\t\t\tfail( tokenizer, 'an expression' );\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\ts: symbol,\r\n\t\t\t\to: expression,\r\n\t\t\t\tt: PREFIX_OPERATOR\r\n\t\t\t};\r\n\t\t};\r\n\t};\r\n\r\n\t// create all prefix sequence matchers\r\n\t(function () {\r\n\t\tvar i, len, matcher, prefixOperators, fallthrough;\r\n\r\n\t\tprefixOperators = '! ~ + - typeof'.split( ' ' );\r\n\r\n\t\t// An invocation refinement is higher precedence than logical-not\r\n\t\t//fallthrough = getInvocationRefinement;\r\n\t\tfallthrough = getMemberOrInvocation;\r\n\t\tfor ( i=0, len=prefixOperators.length; i<len; i+=1 ) {\r\n\t\t\tmatcher = makePrefixSequenceMatcher( prefixOperators[i], fallthrough );\r\n\t\t\tfallthrough = matcher;\r\n\t\t}\r\n\r\n\t\t// typeof operator is higher precedence than multiplication, so provides the\r\n\t\t// fallthrough for the multiplication sequence matcher we're about to create\r\n\t\t// (we're skipping void and delete)\r\n\t\tgetTypeOf = fallthrough;\r\n\t}());\r\n\r\n\r\n\tmakeInfixSequenceMatcher = function ( symbol, fallthrough ) {\r\n\t\treturn function ( tokenizer ) {\r\n\t\t\tvar start, left, right;\r\n\r\n\t\t\tleft = fallthrough( tokenizer );\r\n\t\t\tif ( !left ) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tstart = tokenizer.pos;\r\n\r\n\t\t\tallowWhitespace( tokenizer );\r\n\r\n\t\t\tif ( !getStringMatch( tokenizer, symbol ) ) {\r\n\t\t\t\ttokenizer.pos = start;\r\n\t\t\t\treturn left;\r\n\t\t\t}\r\n\r\n\t\t\t// special case - in operator must not be followed by [a-zA-Z_$0-9]\r\n\t\t\tif ( symbol === 'in' && /[a-zA-Z_$0-9]/.test( tokenizer.remaining().charAt( 0 ) ) ) {\r\n\t\t\t\ttokenizer.pos = start;\r\n\t\t\t\treturn left;\r\n\t\t\t}\r\n\r\n\t\t\tallowWhitespace( tokenizer );\r\n\r\n\t\t\tright = getExpression( tokenizer );\r\n\t\t\tif ( !right ) {\r\n\t\t\t\ttokenizer.pos = start;\r\n\t\t\t\treturn left;\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\tt: INFIX_OPERATOR,\r\n\t\t\t\ts: symbol,\r\n\t\t\t\to: [ left, right ]\r\n\t\t\t};\r\n\t\t};\r\n\t};\r\n\r\n\t// create all infix sequence matchers\r\n\t(function () {\r\n\t\tvar i, len, matcher, infixOperators, fallthrough;\r\n\r\n\t\t// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)\r\n\t\t// Each sequence matcher will initially fall through to its higher precedence\r\n\t\t// neighbour, and only attempt to match if one of the higher precedence operators\r\n\t\t// (or, ultimately, a literal, reference, or bracketed expression) already matched\r\n\t\tinfixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split( ' ' );\r\n\r\n\t\t// A typeof operator is higher precedence than multiplication\r\n\t\tfallthrough = getTypeOf;\r\n\t\tfor ( i=0, len=infixOperators.length; i<len; i+=1 ) {\r\n\t\t\tmatcher = makeInfixSequenceMatcher( infixOperators[i], fallthrough );\r\n\t\t\tfallthrough = matcher;\r\n\t\t}\r\n\r\n\t\t// Logical OR is the fallthrough for the conditional matcher\r\n\t\tgetLogicalOr = fallthrough;\r\n\t}());\r\n\t\r\n\r\n\t// The conditional operator is the lowest precedence operator, so we start here\r\n\tgetConditional = function ( tokenizer ) {\r\n\t\tvar start, expression, ifTrue, ifFalse;\r\n\r\n\t\texpression = getLogicalOr( tokenizer );\r\n\t\tif ( !expression ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tstart = tokenizer.pos;\r\n\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\tif ( !getStringMatch( tokenizer, '?' ) ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn expression;\r\n\t\t}\r\n\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\tifTrue = getExpression( tokenizer );\r\n\t\tif ( !ifTrue ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn expression;\r\n\t\t}\r\n\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\tif ( !getStringMatch( tokenizer, ':' ) ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn expression;\r\n\t\t}\r\n\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\tifFalse = getExpression( tokenizer );\r\n\t\tif ( !ifFalse ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn expression;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tt: CONDITIONAL,\r\n\t\t\to: [ expression, ifTrue, ifFalse ]\r\n\t\t};\r\n\t};\r\n\t\r\n\r\n\r\n\tgetDigits = getRegexMatcher( /^[0-9]+/ );\r\n\tgetExponent = getRegexMatcher( /^[eE][\\-+]?[0-9]+/ );\r\n\tgetFraction = getRegexMatcher( /^\\.[0-9]+/ );\r\n\tgetInteger = getRegexMatcher( /^(0|[1-9][0-9]*)/ );\r\n\r\n\r\n\t// if a reference is a browser global, we don't deference it later, so it needs special treatment\r\n\tglobals = /^(?:Array|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)$/;\r\n\r\n\tgetReference = function ( tokenizer ) {\r\n\t\tvar startPos, ancestor, name, dot, combo, refinement, lastDotIndex;\r\n\r\n\t\tstartPos = tokenizer.pos;\r\n\r\n\t\t// we might have ancestor refs...\r\n\t\tancestor = '';\r\n\t\twhile ( getStringMatch( tokenizer, '../' ) ) {\r\n\t\t\tancestor += '../';\r\n\t\t}\r\n\r\n\t\tif ( !ancestor ) {\r\n\t\t\t// we might have an implicit iterator or a restricted reference\r\n\t\t\tdot = getStringMatch( tokenizer, '.' ) || '';\r\n\t\t}\r\n\r\n\t\tname = getName( tokenizer ) || '';\r\n\r\n\t\t// if this is a browser global, stop here\r\n\t\tif ( !ancestor && !dot && globals.test( name ) ) {\r\n\t\t\treturn {\r\n\t\t\t\tt: GLOBAL,\r\n\t\t\t\tv: name\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// allow the use of `this`\r\n\t\tif ( name === 'this' && !ancestor && !dot ) {\r\n\t\t\tname = '.';\r\n\t\t\tstartPos += 3; // horrible hack to allow method invocations with `this` by ensuring combo.length is right!\r\n\t\t}\r\n\r\n\t\tcombo = ( ancestor || dot ) + name;\r\n\r\n\t\tif ( !combo ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\twhile ( refinement = getDotRefinement( tokenizer ) || getArrayRefinement( tokenizer ) ) {\r\n\t\t\tcombo += refinement;\r\n\t\t}\r\n\r\n\t\tif ( getStringMatch( tokenizer, '(' ) ) {\r\n\t\t\t\r\n\t\t\t// if this is a method invocation (as opposed to a function) we need\r\n\t\t\t// to strip the method name from the reference combo, else the context\r\n\t\t\t// will be wrong\r\n\t\t\tlastDotIndex = combo.lastIndexOf( '.' );\r\n\t\t\tif ( lastDotIndex !== -1 ) {\r\n\t\t\t\tcombo = combo.substr( 0, lastDotIndex );\r\n\t\t\t\ttokenizer.pos = startPos + combo.length;\r\n\t\t\t} else {\r\n\t\t\t\ttokenizer.pos -= 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tt: REFERENCE,\r\n\t\t\tn: combo\r\n\t\t};\r\n\t};\r\n\r\n\tgetRefinement = function ( tokenizer ) {\r\n\t\tvar start, name, expr;\r\n\r\n\t\tstart = tokenizer.pos;\r\n\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\t// \".\" name\r\n\t\tif ( getStringMatch( tokenizer, '.' ) ) {\r\n\t\t\tallowWhitespace( tokenizer );\r\n\r\n\t\t\tif ( name = getName( tokenizer ) ) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tt: REFINEMENT,\r\n\t\t\t\t\tn: name\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tfail( tokenizer, 'a property name' );\r\n\t\t}\r\n\r\n\t\t// \"[\" expression \"]\"\r\n\t\tif ( getStringMatch( tokenizer, '[' ) ) {\r\n\t\t\tallowWhitespace( tokenizer );\r\n\r\n\t\t\texpr = getExpression( tokenizer );\r\n\t\t\tif ( !expr ) {\r\n\t\t\t\tfail( tokenizer, 'an expression' );\r\n\t\t\t}\r\n\r\n\t\t\tallowWhitespace( tokenizer );\r\n\r\n\t\t\tif ( !getStringMatch( tokenizer, ']' ) ) {\r\n\t\t\t\tfail( tokenizer, '\"]\"' );\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\tt: REFINEMENT,\r\n\t\t\t\tx: expr\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t};\r\n\r\n\t// Any literal except function and regexp literals, which aren't supported (yet?)\r\n\tgetLiteral = function ( tokenizer ) {\r\n\t\tvar literal = getNumberLiteral( tokenizer )   ||\r\n\t\t              getBooleanLiteral( tokenizer )  ||\r\n\t\t              getStringLiteral( tokenizer )   ||\r\n\t\t              getObjectLiteral( tokenizer )   ||\r\n\t\t              getArrayLiteral( tokenizer );\r\n\r\n\t\treturn literal;\r\n\t};\r\n\r\n\tgetArrayLiteral = function ( tokenizer ) {\r\n\t\tvar start, expressionList;\r\n\r\n\t\tstart = tokenizer.pos;\r\n\r\n\t\t// allow whitespace before '['\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\tif ( !getStringMatch( tokenizer, '[' ) ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\texpressionList = getExpressionList( tokenizer );\r\n\r\n\t\tif ( !getStringMatch( tokenizer, ']' ) ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tt: ARRAY_LITERAL,\r\n\t\t\tm: expressionList\r\n\t\t};\r\n\t};\r\n\r\n\tgetBooleanLiteral = function ( tokenizer ) {\r\n\t\tvar remaining = tokenizer.remaining();\r\n\r\n\t\tif ( remaining.substr( 0, 4 ) === 'true' ) {\r\n\t\t\ttokenizer.pos += 4;\r\n\t\t\treturn {\r\n\t\t\t\tt: BOOLEAN_LITERAL,\r\n\t\t\t\tv: 'true'\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tif ( remaining.substr( 0, 5 ) === 'false' ) {\r\n\t\t\ttokenizer.pos += 5;\r\n\t\t\treturn {\r\n\t\t\t\tt: BOOLEAN_LITERAL,\r\n\t\t\t\tv: 'false'\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t};\r\n\r\n\tgetNumberLiteral = function ( tokenizer ) {\r\n\t\tvar start, result;\r\n\r\n\t\tstart = tokenizer.pos;\r\n\r\n\t\t// special case - we may have a decimal without a literal zero (because\r\n\t\t// some programmers are plonkers)\r\n\t\tif ( result = getFraction( tokenizer ) ) {\r\n\t\t\treturn {\r\n\t\t\t\tt: NUMBER_LITERAL,\r\n\t\t\t\tv: result\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tresult = getInteger( tokenizer );\r\n\t\tif ( result === null ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tresult += getFraction( tokenizer ) || '';\r\n\t\tresult += getExponent( tokenizer ) || '';\r\n\r\n\t\treturn {\r\n\t\t\tt: NUMBER_LITERAL,\r\n\t\t\tv: result\r\n\t\t};\r\n\t};\r\n\r\n\tgetObjectLiteral = function ( tokenizer ) {\r\n\t\tvar start, keyValuePairs;\r\n\r\n\t\tstart = tokenizer.pos;\r\n\r\n\t\t// allow whitespace\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\tif ( !getStringMatch( tokenizer, '{' ) ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tkeyValuePairs = getKeyValuePairs( tokenizer );\r\n\r\n\t\t// allow whitespace between final value and '}'\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\tif ( !getStringMatch( tokenizer, '}' ) ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tt: OBJECT_LITERAL,\r\n\t\t\tm: keyValuePairs\r\n\t\t};\r\n\t};\r\n\r\n\tgetKeyValuePairs = function ( tokenizer ) {\r\n\t\tvar start, pairs, pair, keyValuePairs;\r\n\r\n\t\tstart = tokenizer.pos;\r\n\r\n\t\tpair = getKeyValuePair( tokenizer );\r\n\t\tif ( pair === null ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tpairs = [ pair ];\r\n\r\n\t\tif ( getStringMatch( tokenizer, ',' ) ) {\r\n\t\t\tkeyValuePairs = getKeyValuePairs( tokenizer );\r\n\r\n\t\t\tif ( !keyValuePairs ) {\r\n\t\t\t\ttokenizer.pos = start;\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\treturn pairs.concat( keyValuePairs );\r\n\t\t}\r\n\r\n\t\treturn pairs;\r\n\t};\r\n\r\n\tgetKeyValuePair = function ( tokenizer ) {\r\n\t\tvar start, key, value;\r\n\r\n\t\tstart = tokenizer.pos;\r\n\r\n\t\t// allow whitespace between '{' and key\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\tkey = getKey( tokenizer );\r\n\t\tif ( key === null ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// allow whitespace between key and ':'\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\t// next character must be ':'\r\n\t\tif ( !getStringMatch( tokenizer, ':' ) ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// allow whitespace between ':' and value\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\t// next expression must be a, well... expression\r\n\t\tvalue = getExpression( tokenizer );\r\n\t\tif ( value === null ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tt: KEY_VALUE_PAIR,\r\n\t\t\tk: key,\r\n\t\t\tv: value\r\n\t\t};\r\n\t};\r\n\r\n\t// http://mathiasbynens.be/notes/javascript-properties\r\n\t// can be any name, string literal, or number literal\r\n\tgetKey = function ( tokenizer ) {\r\n\t\treturn getName( tokenizer ) || getStringLiteral( tokenizer ) || getNumberLiteral( tokenizer );\r\n\t};\r\n\r\n\tgetStringLiteral = function ( tokenizer ) {\r\n\t\tvar start, string;\r\n\r\n\t\tstart = tokenizer.pos;\r\n\r\n\t\tif ( getStringMatch( tokenizer, '\"' ) ) {\r\n\t\t\tstring = getDoubleQuotedString( tokenizer );\r\n\t\t\r\n\t\t\tif ( !getStringMatch( tokenizer, '\"' ) ) {\r\n\t\t\t\ttokenizer.pos = start;\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\tt: STRING_LITERAL,\r\n\t\t\t\tv: string\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tif ( getStringMatch( tokenizer, \"'\" ) ) {\r\n\t\t\tstring = getSingleQuotedString( tokenizer );\r\n\r\n\t\t\tif ( !getStringMatch( tokenizer, \"'\" ) ) {\r\n\t\t\t\ttokenizer.pos = start;\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\tt: STRING_LITERAL,\r\n\t\t\t\tv: string\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t};\r\n\r\n\tgetName = getRegexMatcher( /^[a-zA-Z_$][a-zA-Z_$0-9]*/ );\r\n\r\n\tgetDotRefinement = getRegexMatcher( /^\\.[a-zA-Z_$0-9]+/ );\r\n\r\n\tgetArrayRefinement = function ( tokenizer ) {\r\n\t\tvar num = getArrayMember( tokenizer );\r\n\r\n\t\tif ( num ) {\r\n\t\t\treturn '.' + num;\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t};\r\n\r\n\tgetArrayMember = getRegexMatcher( /^\\[(0|[1-9][0-9]*)\\]/ );\r\n\t\r\n}());\r\nvar getMustacheOrTriple;\r\n\r\n// mustache / triple\r\n(function () {\r\n\tvar getMustache,\r\n\t\tgetTriple,\r\n\t\tgetMustacheContent,\r\n\t\tgetMustacheType,\r\n\t\tgetIndexRef,\r\n\t\tmustacheTypes,\r\n\t\tgetDelimiter,\r\n\t\tgetDelimiterChange;\r\n\r\n\tgetMustacheOrTriple = function ( tokenizer ) {\r\n\t\t// if the triple delimiter (e.g. '{{{') is longer than the regular mustache\r\n\t\t// delimiter (e.g. '{{') then we need to try and find a triple first. Otherwise\r\n\t\t// we will get a false positive if the mustache delimiter is a substring of the\r\n\t\t// triple delimiter, as in the default case\r\n\t\tif ( tokenizer.tripleDelimiters[0].length > tokenizer.delimiters[0].length ) {\r\n\t\t\treturn getTriple( tokenizer ) || getMustache( tokenizer );\r\n\t\t}\r\n\r\n\t\treturn getMustache( tokenizer ) || getTriple( tokenizer );\r\n\t};\r\n\r\n\tgetMustache = function ( tokenizer ) {\r\n\t\tvar start = tokenizer.pos, content;\r\n\r\n\t\tif ( !getStringMatch( tokenizer, tokenizer.delimiters[0] ) ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// delimiter change?\r\n\t\tcontent = getDelimiterChange( tokenizer );\r\n\t\tif ( content ) {\r\n\t\t\t// find closing delimiter or abort...\r\n\t\t\tif ( !getStringMatch( tokenizer, tokenizer.delimiters[1] ) ) {\r\n\t\t\t\ttokenizer.pos = start;\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\t// ...then make the switch\r\n\t\t\ttokenizer.delimiters = content;\r\n\t\t\treturn { type: MUSTACHE, mustacheType: DELIMCHANGE };\r\n\t\t}\r\n\r\n\t\tcontent = getMustacheContent( tokenizer );\r\n\r\n\t\tif ( content === null ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// allow whitespace before closing delimiter\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\tif ( !getStringMatch( tokenizer, tokenizer.delimiters[1] ) ) {\r\n\t\t\tfail( tokenizer, '\"' + tokenizer.delimiters[1] + '\"' );\r\n\t\t}\r\n\r\n\t\treturn content;\r\n\t};\r\n\r\n\tgetTriple = function ( tokenizer ) {\r\n\t\tvar start = tokenizer.pos, content;\r\n\r\n\t\tif ( !getStringMatch( tokenizer, tokenizer.tripleDelimiters[0] ) ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// delimiter change?\r\n\t\tcontent = getDelimiterChange( tokenizer );\r\n\t\tif ( content ) {\r\n\t\t\t// find closing delimiter or abort...\r\n\t\t\tif ( !getStringMatch( tokenizer, tokenizer.tripleDelimiters[1] ) ) {\r\n\t\t\t\ttokenizer.pos = start;\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\t// ...then make the switch\r\n\t\t\ttokenizer.tripleDelimiters = content;\r\n\t\t\treturn { type: MUSTACHE, mustacheType: DELIMCHANGE };\r\n\t\t}\r\n\r\n\t\t// allow whitespace between opening delimiter and reference\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\tcontent = getMustacheContent( tokenizer, true );\r\n\r\n\t\tif ( content === null ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// allow whitespace between reference and closing delimiter\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\tif ( !getStringMatch( tokenizer, tokenizer.tripleDelimiters[1] ) ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn content;\r\n\t};\r\n\r\n\tgetMustacheContent = function ( tokenizer, isTriple ) {\r\n\t\tvar start, mustache, type, expr, i, remaining, index;\r\n\r\n\t\tstart = tokenizer.pos;\r\n\r\n\t\tmustache = { type: isTriple ? TRIPLE : MUSTACHE };\r\n\r\n\t\t// mustache type\r\n\t\tif ( !isTriple ) {\r\n\t\t\ttype = getMustacheType( tokenizer );\r\n\t\t\tmustache.mustacheType = type || INTERPOLATOR; // default\r\n\r\n\t\t\t// if it's a comment or a section closer, allow any contents except '}}'\r\n\t\t\tif ( type === COMMENT || type === CLOSING ) {\r\n\t\t\t\tremaining = tokenizer.remaining();\r\n\t\t\t\tindex = remaining.indexOf( tokenizer.delimiters[1] );\r\n\r\n\t\t\t\tif ( index !== -1 ) {\r\n\t\t\t\t\tmustache.ref = remaining.substr( 0, index );\r\n\t\t\t\t\ttokenizer.pos += index;\r\n\t\t\t\t\treturn mustache;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// allow whitespace\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\t// get expression\r\n\t\texpr = getExpression( tokenizer );\r\n\r\n\t\twhile ( expr.t === BRACKETED && expr.x ) {\r\n\t\t\texpr = expr.x;\r\n\t\t}\r\n\r\n\t\tif ( expr.t === REFERENCE ) {\r\n\t\t\tmustache.ref = expr.n;\r\n\t\t} else {\r\n\t\t\tmustache.expression = expr;\r\n\t\t}\r\n\r\n\t\t// optional index reference\r\n\t\ti = getIndexRef( tokenizer );\r\n\t\tif ( i !== null ) {\r\n\t\t\tmustache.indexRef = i;\r\n\t\t}\r\n\r\n\t\treturn mustache;\r\n\t};\r\n\r\n\tmustacheTypes = {\r\n\t\t'#': SECTION,\r\n\t\t'^': INVERTED,\r\n\t\t'/': CLOSING,\r\n\t\t'>': PARTIAL,\r\n\t\t'!': COMMENT,\r\n\t\t'&': INTERPOLATOR\r\n\t};\r\n\r\n\tgetMustacheType = function ( tokenizer ) {\r\n\t\tvar type = mustacheTypes[ tokenizer.str.charAt( tokenizer.pos ) ];\r\n\r\n\t\tif ( !type ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\ttokenizer.pos += 1;\r\n\t\treturn type;\r\n\t};\r\n\r\n\tgetIndexRef = getRegexMatcher( /^\\s*:\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/ );\r\n\r\n\tgetDelimiter = getRegexMatcher( /^[^\\s=]+/ );\r\n\r\n\tgetDelimiterChange = function ( tokenizer ) {\r\n\t\tvar start, opening, closing;\r\n\r\n\t\tif ( !getStringMatch( tokenizer, '=' ) ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tstart = tokenizer.pos;\r\n\r\n\t\t// allow whitespace before new opening delimiter\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\topening = getDelimiter( tokenizer );\r\n\t\tif ( !opening ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// allow whitespace (in fact, it's necessary...)\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\tclosing = getDelimiter( tokenizer );\r\n\t\tif ( !closing ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// allow whitespace before closing '='\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\tif ( !getStringMatch( tokenizer, '=' ) ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn [ opening, closing ];\r\n\t};\r\n\r\n}());\r\nvar getTag;\r\n\r\n(function () {\r\n\tvar getOpeningTag,\r\n\tgetClosingTag,\r\n\tgetTagName,\r\n\tgetAttributes,\r\n\tgetAttribute,\r\n\tgetAttributeName,\r\n\tgetAttributeValue,\r\n\tgetUnquotedAttributeValue,\r\n\tgetUnquotedAttributeValueToken,\r\n\tgetUnquotedAttributeValueText,\r\n\tgetQuotedStringToken,\r\n\tgetQuotedAttributeValue;\r\n\r\n\tgetTag = function ( tokenizer ) {\r\n\t\treturn getOpeningTag( tokenizer ) || getClosingTag( tokenizer );\r\n\t};\r\n\r\n\tgetOpeningTag = function ( tokenizer ) {\r\n\t\tvar start, tag, attrs;\r\n\r\n\t\tstart = tokenizer.pos;\r\n\r\n\t\tif ( !getStringMatch( tokenizer, '<' ) ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\ttag = {\r\n\t\t\ttype: TAG\r\n\t\t};\r\n\r\n\t\t// tag name\r\n\t\ttag.name = getTagName( tokenizer );\r\n\t\tif ( !tag.name ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// attributes\r\n\t\tattrs = getAttributes( tokenizer );\r\n\t\tif ( attrs ) {\r\n\t\t\ttag.attrs = attrs;\r\n\t\t}\r\n\r\n\t\t// allow whitespace before closing solidus\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\t// self-closing solidus?\r\n\t\tif ( getStringMatch( tokenizer, '/' ) ) {\r\n\t\t\ttag.selfClosing = true;\r\n\t\t}\r\n\r\n\t\t// closing angle bracket\r\n\t\tif ( !getStringMatch( tokenizer, '>' ) ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn tag;\r\n\t};\r\n\r\n\tgetClosingTag = function ( tokenizer ) {\r\n\t\tvar start, tag;\r\n\r\n\t\tstart = tokenizer.pos;\r\n\r\n\t\tif ( !getStringMatch( tokenizer, '<' ) ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\ttag = { type: TAG, closing: true };\r\n\r\n\t\t// closing solidus\r\n\t\tif ( !getStringMatch( tokenizer, '/' ) ) {\r\n\t\t\tthrow new Error( 'Unexpected character ' + tokenizer.remaining().charAt( 0 ) + ' (expected \"/\")' );\r\n\t\t}\r\n\r\n\t\t// tag name\r\n\t\ttag.name = getTagName( tokenizer );\r\n\t\tif ( !tag.name ) {\r\n\t\t\tthrow new Error( 'Unexpected character ' + tokenizer.remaining().charAt( 0 ) + ' (expected tag name)' );\r\n\t\t}\r\n\r\n\t\t// closing angle bracket\r\n\t\tif ( !getStringMatch( tokenizer, '>' ) ) {\r\n\t\t\tthrow new Error( 'Unexpected character ' + tokenizer.remaining().charAt( 0 ) + ' (expected \">\")' );\r\n\t\t}\r\n\r\n\t\treturn tag;\r\n\t};\r\n\r\n\tgetTagName = getRegexMatcher( /^[a-zA-Z][a-zA-Z0-9\\-]*/ );\r\n\r\n\tgetAttributes = function ( tokenizer ) {\r\n\t\tvar start, attrs, attr;\r\n\r\n\t\tstart = tokenizer.pos;\r\n\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\tattr = getAttribute( tokenizer );\r\n\r\n\t\tif ( !attr ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tattrs = [];\r\n\r\n\t\twhile ( attr !== null ) {\r\n\t\t\tattrs[ attrs.length ] = attr;\r\n\r\n\t\t\tallowWhitespace( tokenizer );\r\n\t\t\tattr = getAttribute( tokenizer );\r\n\t\t}\r\n\r\n\t\treturn attrs;\r\n\t};\r\n\r\n\tgetAttribute = function ( tokenizer ) {\r\n\t\tvar attr, name, value;\r\n\r\n\t\tname = getAttributeName( tokenizer );\r\n\t\tif ( !name ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tattr = {\r\n\t\t\tname: name\r\n\t\t};\r\n\r\n\t\tvalue = getAttributeValue( tokenizer );\r\n\t\tif ( value ) {\r\n\t\t\tattr.value = value;\r\n\t\t}\r\n\r\n\t\treturn attr;\r\n\t};\r\n\r\n\tgetAttributeName = getRegexMatcher( /^[^\\s\"'>\\/=]+/ );\r\n\r\n\t\r\n\r\n\tgetAttributeValue = function ( tokenizer ) {\r\n\t\tvar start, value;\r\n\r\n\t\tstart = tokenizer.pos;\r\n\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\tif ( !getStringMatch( tokenizer, '=' ) ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tallowWhitespace( tokenizer );\r\n\r\n\t\tvalue = getQuotedAttributeValue( tokenizer, \"'\" ) ||\r\n\t\t        getQuotedAttributeValue( tokenizer, '\"' ) ||\r\n\t\t        getUnquotedAttributeValue( tokenizer );\r\n\t\t\r\n\t\tif ( value === null ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn value;\r\n\t};\r\n\r\n\tgetUnquotedAttributeValueText = getRegexMatcher( /^[^\\s\"'=<>`]+/ );\r\n\r\n\tgetUnquotedAttributeValueToken = function ( tokenizer ) {\r\n\t\tvar start, text, index;\r\n\r\n\t\tstart = tokenizer.pos;\r\n\r\n\t\ttext = getUnquotedAttributeValueText( tokenizer );\r\n\r\n\t\tif ( !text ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tif ( ( index = text.indexOf( tokenizer.delimiters[0] ) ) !== -1 ) {\r\n\t\t\ttext = text.substr( 0, index );\r\n\t\t\ttokenizer.pos = start + text.length;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttype: TEXT,\r\n\t\t\tvalue: text\r\n\t\t};\r\n\t};\r\n\r\n\tgetUnquotedAttributeValue = function ( tokenizer ) {\r\n\t\tvar tokens, token;\r\n\r\n\t\ttokens = [];\r\n\r\n\t\ttoken = getMustacheOrTriple( tokenizer ) || getUnquotedAttributeValueToken( tokenizer );\r\n\t\twhile ( token !== null ) {\r\n\t\t\ttokens[ tokens.length ] = token;\r\n\t\t\ttoken = getMustacheOrTriple( tokenizer ) || getUnquotedAttributeValueToken( tokenizer );\r\n\t\t}\r\n\r\n\t\tif ( !tokens.length ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn tokens;\r\n\t};\r\n\r\n\tgetQuotedAttributeValue = function ( tokenizer, quoteMark ) {\r\n\t\tvar start, tokens, token;\r\n\r\n\t\tstart = tokenizer.pos;\r\n\r\n\t\tif ( !getStringMatch( tokenizer, quoteMark ) ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\ttokens = [];\r\n\r\n\t\ttoken = getMustacheOrTriple( tokenizer ) || getQuotedStringToken( tokenizer, quoteMark );\r\n\t\twhile ( token !== null ) {\r\n\t\t\ttokens[ tokens.length ] = token;\r\n\t\t\ttoken = getMustacheOrTriple( tokenizer ) || getQuotedStringToken( tokenizer, quoteMark );\r\n\t\t}\r\n\r\n\t\tif ( !getStringMatch( tokenizer, quoteMark ) ) {\r\n\t\t\ttokenizer.pos = start;\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn tokens;\r\n\t};\r\n\r\n\tgetQuotedStringToken = function ( tokenizer, quoteMark ) {\r\n\t\tvar start, index, remaining;\r\n\r\n\t\tstart = tokenizer.pos;\r\n\t\tremaining = tokenizer.remaining();\r\n\r\n\t\tindex = getLowestIndex( remaining, [ quoteMark, tokenizer.delimiters[0], tokenizer.delimiters[1] ] );\r\n\r\n\t\tif ( index === -1 ) {\r\n\t\t\tthrow new Error( 'Quoted attribute value must have a closing quote' );\r\n\t\t}\r\n\r\n\t\tif ( !index ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\ttokenizer.pos += index;\r\n\r\n\t\treturn {\r\n\t\t\ttype: TEXT,\r\n\t\t\tvalue: remaining.substr( 0, index )\r\n\t\t};\r\n\t};\r\n\r\n}());\r\nvar getText = function ( tokenizer ) {\r\n\tvar index, remaining;\r\n\r\n\tremaining = tokenizer.remaining();\r\n\r\n\tindex = getLowestIndex( remaining, [ '<', tokenizer.delimiters[0], tokenizer.tripleDelimiters[0] ] );\r\n\r\n\tif ( !index ) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tif ( index === -1 ) {\r\n\t\tindex = remaining.length;\r\n\t}\r\n\r\n\ttokenizer.pos += index;\r\n\treturn {\r\n\t\ttype: TEXT,\r\n\t\tvalue: remaining.substr( 0, index )\r\n\t};\r\n};\r\ngetToken = function ( tokenizer ) {\r\n\tvar token = getMustacheOrTriple( tokenizer ) ||\r\n\t        getTag( tokenizer ) ||\r\n\t        getText( tokenizer );\r\n\r\n\treturn token;\r\n};\r\n// TODO establish whether we actually need this (and siblings)\r\nvar getDoubleQuotedString = function ( tokenizer ) {\r\n\tvar start, string, escaped, unescaped, next;\r\n\r\n\tstart = tokenizer.pos;\r\n\r\n\tstring = '';\r\n\r\n\tescaped = getEscapedChars( tokenizer );\r\n\tif ( escaped ) {\r\n\t\tstring += escaped;\r\n\t}\r\n\r\n\tunescaped = getUnescapedDoubleQuotedChars( tokenizer );\r\n\tif ( unescaped ) {\r\n\t\tstring += unescaped;\r\n\t}\r\n\r\n\tif ( !string ) {\r\n\t\treturn '';\r\n\t}\r\n\r\n\tnext = getDoubleQuotedString( tokenizer );\r\n\twhile ( next !== '' ) {\r\n\t\tstring += next;\r\n\t}\r\n\r\n\treturn string;\r\n};\r\n\r\nvar getUnescapedDoubleQuotedChars = getRegexMatcher( /^[^\\\\\"]+/ );\r\nvar getEscapedChar = function ( tokenizer ) {\r\n\tvar character;\r\n\r\n\tif ( !getStringMatch( tokenizer, '\\\\' ) ) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tcharacter = tokenizer.str.charAt( tokenizer.pos );\r\n\ttokenizer.pos += 1;\r\n\r\n\treturn character;\r\n};\r\nvar getEscapedChars = function ( tokenizer ) {\r\n\tvar chars = '', character;\r\n\r\n\tcharacter = getEscapedChar( tokenizer );\r\n\twhile ( character ) {\r\n\t\tchars += character;\r\n\t\tcharacter = getEscapedChar( tokenizer );\r\n\t}\r\n\r\n\treturn chars || null;\r\n};\r\nvar getLowestIndex = function ( haystack, needles ) {\r\n\tvar i, index, lowest;\r\n\r\n\ti = needles.length;\r\n\twhile ( i-- ) {\r\n\t\tindex = haystack.indexOf( needles[i] );\r\n\t\t\r\n\t\t// short circuit\r\n\t\tif ( !index ) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tif ( index === -1 ) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\t\r\n\t\tif ( !lowest || ( index < lowest ) ) {\r\n\t\t\tlowest = index;\r\n\t\t}\r\n\t}\r\n\r\n\treturn lowest || -1;\r\n};\r\nvar getSingleQuotedString = function ( tokenizer ) {\r\n\tvar start, string, escaped, unescaped, next;\r\n\r\n\tstart = tokenizer.pos;\r\n\r\n\tstring = '';\r\n\r\n\tescaped = getEscapedChars( tokenizer );\r\n\tif ( escaped ) {\r\n\t\tstring += escaped;\r\n\t}\r\n\r\n\tunescaped = getUnescapedSingleQuotedChars( tokenizer );\r\n\tif ( unescaped ) {\r\n\t\tstring += unescaped;\r\n\t}\r\n\tif ( string ) {\r\n\t\tnext = getSingleQuotedString( tokenizer );\r\n\t\twhile ( next ) {\r\n\t\t\tstring += next;\r\n\t\t\tnext = getSingleQuotedString( tokenizer );\r\n\t\t}\r\n\t}\r\n\r\n\treturn string;\r\n};\r\n\r\nvar getUnescapedSingleQuotedChars = getRegexMatcher( /^[^\\\\']+/ );\r\n// Ractive.parse\r\n// ===============\r\n//\r\n// Takes in a string, and returns an object representing the parsed template.\r\n// A parsed template is an array of 1 or more 'descriptors', which in some\r\n// cases have children.\r\n//\r\n// The format is optimised for size, not readability, however for reference the\r\n// keys for each descriptor are as follows:\r\n//\r\n// * r - Reference, e.g. 'mustache' in {{mustache}}\r\n// * t - Type code (e.g. 1 is text, 2 is interpolator...)\r\n// * f - Fragment. Contains a descriptor's children\r\n// * e - Element name\r\n// * a - map of element Attributes, or proxy event/transition Arguments\r\n// * d - Dynamic proxy event/transition arguments\r\n// * n - indicates an iNverted section\r\n// * i - Index reference, e.g. 'num' in {{#section:num}}content{{/section}}\r\n// * v - eVent proxies (i.e. when user e.g. clicks on a node, fire proxy event)\r\n// * c - Conditionals (e.g. ['yes', 'no'] in {{condition ? yes : no}})\r\n// * x - eXpressions\r\n// * t1 - intro Transition\r\n// * t2 - outro Transition\r\n\r\n(function () {\r\n\r\n\tvar onlyWhitespace, inlinePartialStart, inlinePartialEnd, parseCompoundTemplate;\r\n\r\n\tonlyWhitespace = /^\\s*$/;\r\n\r\n\tinlinePartialStart = /<!--\\s*\\{\\{\\s*>\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*}\\}\\s*-->/;\r\n\tinlinePartialEnd = /<!--\\s*\\{\\{\\s*\\/\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*}\\}\\s*-->/;\r\n\r\n\tparse = function ( template, options ) {\r\n\t\tvar tokens, fragmentStub, json, token;\r\n\r\n\t\toptions = options || {};\r\n\r\n\t\t// does this template include inline partials?\r\n\t\tif ( inlinePartialStart.test( template ) ) {\r\n\t\t\treturn parseCompoundTemplate( template, options );\r\n\t\t}\r\n\r\n\r\n\t\tif ( options.sanitize === true ) {\r\n\t\t\toptions.sanitize = {\r\n\t\t\t\t// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json\r\n\t\t\t\telements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),\r\n\t\t\t\teventAttributes: true\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\ttokens = tokenize( template, options );\r\n\r\n\t\tif ( !options.preserveWhitespace ) {\r\n\t\t\t// remove first token if it only contains whitespace\r\n\t\t\ttoken = tokens[0];\r\n\t\t\tif ( token && ( token.type === TEXT ) && onlyWhitespace.test( token.value ) ) {\r\n\t\t\t\ttokens.shift();\r\n\t\t\t}\r\n\r\n\t\t\t// ditto last token\r\n\t\t\ttoken = tokens[ tokens.length - 1 ];\r\n\t\t\tif ( token && ( token.type === TEXT ) && onlyWhitespace.test( token.value ) ) {\r\n\t\t\t\ttokens.pop();\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tfragmentStub = getFragmentStubFromTokens( tokens, options, options.preserveWhitespace );\r\n\t\t\r\n\t\tjson = fragmentStub.toJSON();\r\n\r\n\t\tif ( typeof json === 'string' ) {\r\n\t\t\t// If we return it as a string, Ractive will attempt to reparse it!\r\n\t\t\t// Instead we wrap it in an array. Ractive knows what to do then\r\n\t\t\treturn [ json ];\r\n\t\t}\r\n\r\n\t\treturn json;\r\n\t};\r\n\r\n\t\r\n\tparseCompoundTemplate = function ( template, options ) {\r\n\t\tvar mainTemplate, remaining, partials, name, startMatch, endMatch;\r\n\r\n\t\tpartials = {};\r\n\r\n\t\tmainTemplate = '';\r\n\t\tremaining = template;\r\n\r\n\t\twhile ( startMatch = inlinePartialStart.exec( remaining ) ) {\r\n\t\t\tname = startMatch[1];\r\n\r\n\t\t\tmainTemplate += remaining.substr( 0, startMatch.index );\r\n\t\t\tremaining = remaining.substring( startMatch.index + startMatch[0].length );\r\n\r\n\t\t\tendMatch = inlinePartialEnd.exec( remaining );\r\n\r\n\t\t\tif ( !endMatch || endMatch[1] !== name ) {\r\n\t\t\t\tthrow new Error( 'Inline partials must have a closing delimiter, and cannot be nested' );\r\n\t\t\t}\r\n\r\n\t\t\tpartials[ name ] = parse( remaining.substr( 0, endMatch.index ), options );\r\n\r\n\t\t\tremaining = remaining.substring( endMatch.index + endMatch[0].length );\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tmain: parse( mainTemplate, options ),\r\n\t\t\tpartials: partials\r\n\t\t};\r\n\t};\r\n\r\n}());\r\ntokenize = function ( template, options ) {\r\n\tvar tokenizer, tokens, token, last20, next20;\r\n\r\n\toptions = options || {};\r\n\r\n\ttokenizer = {\r\n\t\tstr: stripHtmlComments( template ),\r\n\t\tpos: 0,\r\n\t\tdelimiters: options.delimiters || Ractive.delimiters,\r\n\t\ttripleDelimiters: options.tripleDelimiters || Ractive.tripleDelimiters,\r\n\t\tremaining: function () {\r\n\t\t\treturn tokenizer.str.substring( tokenizer.pos );\r\n\t\t}\r\n\t};\r\n\r\n\ttokens = [];\r\n\r\n\twhile ( tokenizer.pos < tokenizer.str.length ) {\r\n\t\ttoken = getToken( tokenizer );\r\n\r\n\t\tif ( token === null && tokenizer.remaining() ) {\r\n\t\t\tlast20 = tokenizer.str.substr( 0, tokenizer.pos ).substr( -20 );\r\n\t\t\tif ( last20.length === 20 ) {\r\n\t\t\t\tlast20 = '...' + last20;\r\n\t\t\t}\r\n\r\n\t\t\tnext20 = tokenizer.remaining().substr( 0, 20 );\r\n\t\t\tif ( next20.length === 20 ) {\r\n\t\t\t\tnext20 = next20 + '...';\r\n\t\t\t}\r\n\r\n\t\t\tthrow new Error( 'Could not parse template: ' + ( last20 ? last20 + '<- ' : '' ) + 'failed at character ' + tokenizer.pos + ' ->' + next20 );\r\n\t\t}\r\n\r\n\t\ttokens[ tokens.length ] = token;\r\n\t}\r\n\r\n\tstripStandalones( tokens );\r\n\tstripCommentTokens( tokens );\r\n\r\n\treturn tokens;\r\n};\r\nRactive.prototype = proto;\r\n\r\n// Shared properties\r\nRactive.partials = {};\r\nRactive.delimiters = [ '{{', '}}' ];\r\nRactive.tripleDelimiters = [ '{{{', '}}}' ];\r\n\r\n// Plugins\r\nRactive.adaptors = adaptors;\r\nRactive.eventDefinitions = eventDefinitions;\r\nRactive.easing = easing;\r\nRactive.transitions = transitions;\r\n\r\n// Static methods\r\nRactive.extend = extend;\r\nRactive.interpolate = interpolate;\r\nRactive.interpolators = interpolators;\r\nRactive.parse = parse;\r\n\r\nRactive.VERSION = VERSION;\r\n\r\n\r\n// export as Common JS module...\r\nif ( typeof module !== \"undefined\" && module.exports ) {\r\n\tmodule.exports = Ractive;\r\n}\r\n\r\n// ... or as AMD module\r\nelse if ( typeof define === \"function\" && define.amd ) {\r\n\tdefine( 'Ractive',[],function () {\r\n\t\treturn Ractive;\r\n\t});\r\n}\r\n\r\n// ... or as browser global\r\nelse {\r\n\tglobal.Ractive = Ractive;\r\n}\r\n\r\n}( typeof window !== 'undefined' ? window : this ));",
    "\n//     Underscore.js 1.5.2\r\n//     http://underscorejs.org\r\n//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\r\n//     Underscore may be freely distributed under the MIT license.\r\n\r\n(function() {\r\n\r\n  // Baseline setup\r\n  // --------------\r\n\r\n  // Establish the root object, `window` in the browser, or `exports` on the server.\r\n  var root = this;\r\n\r\n  // Save the previous value of the `_` variable.\r\n  var previousUnderscore = root._;\r\n\r\n  // Establish the object that gets returned to break out of a loop iteration.\r\n  var breaker = {};\r\n\r\n  // Save bytes in the minified (but not gzipped) version:\r\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\r\n\r\n  // Create quick reference variables for speed access to core prototypes.\r\n  var\r\n    push             = ArrayProto.push,\r\n    slice            = ArrayProto.slice,\r\n    concat           = ArrayProto.concat,\r\n    toString         = ObjProto.toString,\r\n    hasOwnProperty   = ObjProto.hasOwnProperty;\r\n\r\n  // All **ECMAScript 5** native function implementations that we hope to use\r\n  // are declared here.\r\n  var\r\n    nativeForEach      = ArrayProto.forEach,\r\n    nativeMap          = ArrayProto.map,\r\n    nativeReduce       = ArrayProto.reduce,\r\n    nativeReduceRight  = ArrayProto.reduceRight,\r\n    nativeFilter       = ArrayProto.filter,\r\n    nativeEvery        = ArrayProto.every,\r\n    nativeSome         = ArrayProto.some,\r\n    nativeIndexOf      = ArrayProto.indexOf,\r\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\r\n    nativeIsArray      = Array.isArray,\r\n    nativeKeys         = Object.keys,\r\n    nativeBind         = FuncProto.bind;\r\n\r\n  // Create a safe reference to the Underscore object for use below.\r\n  var _ = function(obj) {\r\n    if (obj instanceof _) return obj;\r\n    if (!(this instanceof _)) return new _(obj);\r\n    this._wrapped = obj;\r\n  };\r\n\r\n  // Export the Underscore object for **Node.js**, with\r\n  // backwards-compatibility for the old `require()` API. If we're in\r\n  // the browser, add `_` as a global object via a string identifier,\r\n  // for Closure Compiler \"advanced\" mode.\r\n  if (typeof exports !== 'undefined') {\r\n    if (typeof module !== 'undefined' && module.exports) {\r\n      exports = module.exports = _;\r\n    }\r\n    exports._ = _;\r\n  } else {\r\n    root._ = _;\r\n  }\r\n\r\n  // Current version.\r\n  _.VERSION = '1.5.2';\r\n\r\n  // Collection Functions\r\n  // --------------------\r\n\r\n  // The cornerstone, an `each` implementation, aka `forEach`.\r\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\r\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\r\n  var each = _.each = _.forEach = function(obj, iterator, context) {\r\n    if (obj == null) return;\r\n    if (nativeForEach && obj.forEach === nativeForEach) {\r\n      obj.forEach(iterator, context);\r\n    } else if (obj.length === +obj.length) {\r\n      for (var i = 0, length = obj.length; i < length; i++) {\r\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\r\n      }\r\n    } else {\r\n      var keys = _.keys(obj);\r\n      for (var i = 0, length = keys.length; i < length; i++) {\r\n        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;\r\n      }\r\n    }\r\n  };\r\n\r\n  // Return the results of applying the iterator to each element.\r\n  // Delegates to **ECMAScript 5**'s native `map` if available.\r\n  _.map = _.collect = function(obj, iterator, context) {\r\n    var results = [];\r\n    if (obj == null) return results;\r\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\r\n    each(obj, function(value, index, list) {\r\n      results.push(iterator.call(context, value, index, list));\r\n    });\r\n    return results;\r\n  };\r\n\r\n  var reduceError = 'Reduce of empty array with no initial value';\r\n\r\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\r\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\r\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\r\n    var initial = arguments.length > 2;\r\n    if (obj == null) obj = [];\r\n    if (nativeReduce && obj.reduce === nativeReduce) {\r\n      if (context) iterator = _.bind(iterator, context);\r\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\r\n    }\r\n    each(obj, function(value, index, list) {\r\n      if (!initial) {\r\n        memo = value;\r\n        initial = true;\r\n      } else {\r\n        memo = iterator.call(context, memo, value, index, list);\r\n      }\r\n    });\r\n    if (!initial) throw new TypeError(reduceError);\r\n    return memo;\r\n  };\r\n\r\n  // The right-associative version of reduce, also known as `foldr`.\r\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\r\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\r\n    var initial = arguments.length > 2;\r\n    if (obj == null) obj = [];\r\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\r\n      if (context) iterator = _.bind(iterator, context);\r\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\r\n    }\r\n    var length = obj.length;\r\n    if (length !== +length) {\r\n      var keys = _.keys(obj);\r\n      length = keys.length;\r\n    }\r\n    each(obj, function(value, index, list) {\r\n      index = keys ? keys[--length] : --length;\r\n      if (!initial) {\r\n        memo = obj[index];\r\n        initial = true;\r\n      } else {\r\n        memo = iterator.call(context, memo, obj[index], index, list);\r\n      }\r\n    });\r\n    if (!initial) throw new TypeError(reduceError);\r\n    return memo;\r\n  };\r\n\r\n  // Return the first value which passes a truth test. Aliased as `detect`.\r\n  _.find = _.detect = function(obj, iterator, context) {\r\n    var result;\r\n    any(obj, function(value, index, list) {\r\n      if (iterator.call(context, value, index, list)) {\r\n        result = value;\r\n        return true;\r\n      }\r\n    });\r\n    return result;\r\n  };\r\n\r\n  // Return all the elements that pass a truth test.\r\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\r\n  // Aliased as `select`.\r\n  _.filter = _.select = function(obj, iterator, context) {\r\n    var results = [];\r\n    if (obj == null) return results;\r\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\r\n    each(obj, function(value, index, list) {\r\n      if (iterator.call(context, value, index, list)) results.push(value);\r\n    });\r\n    return results;\r\n  };\r\n\r\n  // Return all the elements for which a truth test fails.\r\n  _.reject = function(obj, iterator, context) {\r\n    return _.filter(obj, function(value, index, list) {\r\n      return !iterator.call(context, value, index, list);\r\n    }, context);\r\n  };\r\n\r\n  // Determine whether all of the elements match a truth test.\r\n  // Delegates to **ECMAScript 5**'s native `every` if available.\r\n  // Aliased as `all`.\r\n  _.every = _.all = function(obj, iterator, context) {\r\n    iterator || (iterator = _.identity);\r\n    var result = true;\r\n    if (obj == null) return result;\r\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\r\n    each(obj, function(value, index, list) {\r\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\r\n    });\r\n    return !!result;\r\n  };\r\n\r\n  // Determine if at least one element in the object matches a truth test.\r\n  // Delegates to **ECMAScript 5**'s native `some` if available.\r\n  // Aliased as `any`.\r\n  var any = _.some = _.any = function(obj, iterator, context) {\r\n    iterator || (iterator = _.identity);\r\n    var result = false;\r\n    if (obj == null) return result;\r\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\r\n    each(obj, function(value, index, list) {\r\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\r\n    });\r\n    return !!result;\r\n  };\r\n\r\n  // Determine if the array or object contains a given value (using `===`).\r\n  // Aliased as `include`.\r\n  _.contains = _.include = function(obj, target) {\r\n    if (obj == null) return false;\r\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\r\n    return any(obj, function(value) {\r\n      return value === target;\r\n    });\r\n  };\r\n\r\n  // Invoke a method (with arguments) on every item in a collection.\r\n  _.invoke = function(obj, method) {\r\n    var args = slice.call(arguments, 2);\r\n    var isFunc = _.isFunction(method);\r\n    return _.map(obj, function(value) {\r\n      return (isFunc ? method : value[method]).apply(value, args);\r\n    });\r\n  };\r\n\r\n  // Convenience version of a common use case of `map`: fetching a property.\r\n  _.pluck = function(obj, key) {\r\n    return _.map(obj, function(value){ return value[key]; });\r\n  };\r\n\r\n  // Convenience version of a common use case of `filter`: selecting only objects\r\n  // containing specific `key:value` pairs.\r\n  _.where = function(obj, attrs, first) {\r\n    if (_.isEmpty(attrs)) return first ? void 0 : [];\r\n    return _[first ? 'find' : 'filter'](obj, function(value) {\r\n      for (var key in attrs) {\r\n        if (attrs[key] !== value[key]) return false;\r\n      }\r\n      return true;\r\n    });\r\n  };\r\n\r\n  // Convenience version of a common use case of `find`: getting the first object\r\n  // containing specific `key:value` pairs.\r\n  _.findWhere = function(obj, attrs) {\r\n    return _.where(obj, attrs, true);\r\n  };\r\n\r\n  // Return the maximum element or (element-based computation).\r\n  // Can't optimize arrays of integers longer than 65,535 elements.\r\n  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)\r\n  _.max = function(obj, iterator, context) {\r\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\r\n      return Math.max.apply(Math, obj);\r\n    }\r\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\r\n    var result = {computed : -Infinity, value: -Infinity};\r\n    each(obj, function(value, index, list) {\r\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\r\n      computed > result.computed && (result = {value : value, computed : computed});\r\n    });\r\n    return result.value;\r\n  };\r\n\r\n  // Return the minimum element (or element-based computation).\r\n  _.min = function(obj, iterator, context) {\r\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\r\n      return Math.min.apply(Math, obj);\r\n    }\r\n    if (!iterator && _.isEmpty(obj)) return Infinity;\r\n    var result = {computed : Infinity, value: Infinity};\r\n    each(obj, function(value, index, list) {\r\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\r\n      computed < result.computed && (result = {value : value, computed : computed});\r\n    });\r\n    return result.value;\r\n  };\r\n\r\n  // Shuffle an array, using the modern version of the \r\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).\r\n  _.shuffle = function(obj) {\r\n    var rand;\r\n    var index = 0;\r\n    var shuffled = [];\r\n    each(obj, function(value) {\r\n      rand = _.random(index++);\r\n      shuffled[index - 1] = shuffled[rand];\r\n      shuffled[rand] = value;\r\n    });\r\n    return shuffled;\r\n  };\r\n\r\n  // Sample **n** random values from an array.\r\n  // If **n** is not specified, returns a single random element from the array.\r\n  // The internal `guard` argument allows it to work with `map`.\r\n  _.sample = function(obj, n, guard) {\r\n    if (arguments.length < 2 || guard) {\r\n      return obj[_.random(obj.length - 1)];\r\n    }\r\n    return _.shuffle(obj).slice(0, Math.max(0, n));\r\n  };\r\n\r\n  // An internal function to generate lookup iterators.\r\n  var lookupIterator = function(value) {\r\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\r\n  };\r\n\r\n  // Sort the object's values by a criterion produced by an iterator.\r\n  _.sortBy = function(obj, value, context) {\r\n    var iterator = lookupIterator(value);\r\n    return _.pluck(_.map(obj, function(value, index, list) {\r\n      return {\r\n        value: value,\r\n        index: index,\r\n        criteria: iterator.call(context, value, index, list)\r\n      };\r\n    }).sort(function(left, right) {\r\n      var a = left.criteria;\r\n      var b = right.criteria;\r\n      if (a !== b) {\r\n        if (a > b || a === void 0) return 1;\r\n        if (a < b || b === void 0) return -1;\r\n      }\r\n      return left.index - right.index;\r\n    }), 'value');\r\n  };\r\n\r\n  // An internal function used for aggregate \"group by\" operations.\r\n  var group = function(behavior) {\r\n    return function(obj, value, context) {\r\n      var result = {};\r\n      var iterator = value == null ? _.identity : lookupIterator(value);\r\n      each(obj, function(value, index) {\r\n        var key = iterator.call(context, value, index, obj);\r\n        behavior(result, key, value);\r\n      });\r\n      return result;\r\n    };\r\n  };\r\n\r\n  // Groups the object's values by a criterion. Pass either a string attribute\r\n  // to group by, or a function that returns the criterion.\r\n  _.groupBy = group(function(result, key, value) {\r\n    (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\r\n  });\r\n\r\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\r\n  // when you know that your index values will be unique.\r\n  _.indexBy = group(function(result, key, value) {\r\n    result[key] = value;\r\n  });\r\n\r\n  // Counts instances of an object that group by a certain criterion. Pass\r\n  // either a string attribute to count by, or a function that returns the\r\n  // criterion.\r\n  _.countBy = group(function(result, key) {\r\n    _.has(result, key) ? result[key]++ : result[key] = 1;\r\n  });\r\n\r\n  // Use a comparator function to figure out the smallest index at which\r\n  // an object should be inserted so as to maintain order. Uses binary search.\r\n  _.sortedIndex = function(array, obj, iterator, context) {\r\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\r\n    var value = iterator.call(context, obj);\r\n    var low = 0, high = array.length;\r\n    while (low < high) {\r\n      var mid = (low + high) >>> 1;\r\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\r\n    }\r\n    return low;\r\n  };\r\n\r\n  // Safely create a real, live array from anything iterable.\r\n  _.toArray = function(obj) {\r\n    if (!obj) return [];\r\n    if (_.isArray(obj)) return slice.call(obj);\r\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\r\n    return _.values(obj);\r\n  };\r\n\r\n  // Return the number of elements in an object.\r\n  _.size = function(obj) {\r\n    if (obj == null) return 0;\r\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\r\n  };\r\n\r\n  // Array Functions\r\n  // ---------------\r\n\r\n  // Get the first element of an array. Passing **n** will return the first N\r\n  // values in the array. Aliased as `head` and `take`. The **guard** check\r\n  // allows it to work with `_.map`.\r\n  _.first = _.head = _.take = function(array, n, guard) {\r\n    if (array == null) return void 0;\r\n    return (n == null) || guard ? array[0] : slice.call(array, 0, n);\r\n  };\r\n\r\n  // Returns everything but the last entry of the array. Especially useful on\r\n  // the arguments object. Passing **n** will return all the values in\r\n  // the array, excluding the last N. The **guard** check allows it to work with\r\n  // `_.map`.\r\n  _.initial = function(array, n, guard) {\r\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\r\n  };\r\n\r\n  // Get the last element of an array. Passing **n** will return the last N\r\n  // values in the array. The **guard** check allows it to work with `_.map`.\r\n  _.last = function(array, n, guard) {\r\n    if (array == null) return void 0;\r\n    if ((n == null) || guard) {\r\n      return array[array.length - 1];\r\n    } else {\r\n      return slice.call(array, Math.max(array.length - n, 0));\r\n    }\r\n  };\r\n\r\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\r\n  // Especially useful on the arguments object. Passing an **n** will return\r\n  // the rest N values in the array. The **guard**\r\n  // check allows it to work with `_.map`.\r\n  _.rest = _.tail = _.drop = function(array, n, guard) {\r\n    return slice.call(array, (n == null) || guard ? 1 : n);\r\n  };\r\n\r\n  // Trim out all falsy values from an array.\r\n  _.compact = function(array) {\r\n    return _.filter(array, _.identity);\r\n  };\r\n\r\n  // Internal implementation of a recursive `flatten` function.\r\n  var flatten = function(input, shallow, output) {\r\n    if (shallow && _.every(input, _.isArray)) {\r\n      return concat.apply(output, input);\r\n    }\r\n    each(input, function(value) {\r\n      if (_.isArray(value) || _.isArguments(value)) {\r\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\r\n      } else {\r\n        output.push(value);\r\n      }\r\n    });\r\n    return output;\r\n  };\r\n\r\n  // Flatten out an array, either recursively (by default), or just one level.\r\n  _.flatten = function(array, shallow) {\r\n    return flatten(array, shallow, []);\r\n  };\r\n\r\n  // Return a version of the array that does not contain the specified value(s).\r\n  _.without = function(array) {\r\n    return _.difference(array, slice.call(arguments, 1));\r\n  };\r\n\r\n  // Produce a duplicate-free version of the array. If the array has already\r\n  // been sorted, you have the option of using a faster algorithm.\r\n  // Aliased as `unique`.\r\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\r\n    if (_.isFunction(isSorted)) {\r\n      context = iterator;\r\n      iterator = isSorted;\r\n      isSorted = false;\r\n    }\r\n    var initial = iterator ? _.map(array, iterator, context) : array;\r\n    var results = [];\r\n    var seen = [];\r\n    each(initial, function(value, index) {\r\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\r\n        seen.push(value);\r\n        results.push(array[index]);\r\n      }\r\n    });\r\n    return results;\r\n  };\r\n\r\n  // Produce an array that contains the union: each distinct element from all of\r\n  // the passed-in arrays.\r\n  _.union = function() {\r\n    return _.uniq(_.flatten(arguments, true));\r\n  };\r\n\r\n  // Produce an array that contains every item shared between all the\r\n  // passed-in arrays.\r\n  _.intersection = function(array) {\r\n    var rest = slice.call(arguments, 1);\r\n    return _.filter(_.uniq(array), function(item) {\r\n      return _.every(rest, function(other) {\r\n        return _.indexOf(other, item) >= 0;\r\n      });\r\n    });\r\n  };\r\n\r\n  // Take the difference between one array and a number of other arrays.\r\n  // Only the elements present in just the first array will remain.\r\n  _.difference = function(array) {\r\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\r\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\r\n  };\r\n\r\n  // Zip together multiple lists into a single array -- elements that share\r\n  // an index go together.\r\n  _.zip = function() {\r\n    var length = _.max(_.pluck(arguments, \"length\").concat(0));\r\n    var results = new Array(length);\r\n    for (var i = 0; i < length; i++) {\r\n      results[i] = _.pluck(arguments, '' + i);\r\n    }\r\n    return results;\r\n  };\r\n\r\n  // Converts lists into objects. Pass either a single array of `[key, value]`\r\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\r\n  // the corresponding values.\r\n  _.object = function(list, values) {\r\n    if (list == null) return {};\r\n    var result = {};\r\n    for (var i = 0, length = list.length; i < length; i++) {\r\n      if (values) {\r\n        result[list[i]] = values[i];\r\n      } else {\r\n        result[list[i][0]] = list[i][1];\r\n      }\r\n    }\r\n    return result;\r\n  };\r\n\r\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\r\n  // we need this function. Return the position of the first occurrence of an\r\n  // item in an array, or -1 if the item is not included in the array.\r\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\r\n  // If the array is large and already in sort order, pass `true`\r\n  // for **isSorted** to use binary search.\r\n  _.indexOf = function(array, item, isSorted) {\r\n    if (array == null) return -1;\r\n    var i = 0, length = array.length;\r\n    if (isSorted) {\r\n      if (typeof isSorted == 'number') {\r\n        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);\r\n      } else {\r\n        i = _.sortedIndex(array, item);\r\n        return array[i] === item ? i : -1;\r\n      }\r\n    }\r\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\r\n    for (; i < length; i++) if (array[i] === item) return i;\r\n    return -1;\r\n  };\r\n\r\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\r\n  _.lastIndexOf = function(array, item, from) {\r\n    if (array == null) return -1;\r\n    var hasIndex = from != null;\r\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\r\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\r\n    }\r\n    var i = (hasIndex ? from : array.length);\r\n    while (i--) if (array[i] === item) return i;\r\n    return -1;\r\n  };\r\n\r\n  // Generate an integer Array containing an arithmetic progression. A port of\r\n  // the native Python `range()` function. See\r\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\r\n  _.range = function(start, stop, step) {\r\n    if (arguments.length <= 1) {\r\n      stop = start || 0;\r\n      start = 0;\r\n    }\r\n    step = arguments[2] || 1;\r\n\r\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\r\n    var idx = 0;\r\n    var range = new Array(length);\r\n\r\n    while(idx < length) {\r\n      range[idx++] = start;\r\n      start += step;\r\n    }\r\n\r\n    return range;\r\n  };\r\n\r\n  // Function (ahem) Functions\r\n  // ------------------\r\n\r\n  // Reusable constructor function for prototype setting.\r\n  var ctor = function(){};\r\n\r\n  // Create a function bound to a given object (assigning `this`, and arguments,\r\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\r\n  // available.\r\n  _.bind = function(func, context) {\r\n    var args, bound;\r\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\r\n    if (!_.isFunction(func)) throw new TypeError;\r\n    args = slice.call(arguments, 2);\r\n    return bound = function() {\r\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\r\n      ctor.prototype = func.prototype;\r\n      var self = new ctor;\r\n      ctor.prototype = null;\r\n      var result = func.apply(self, args.concat(slice.call(arguments)));\r\n      if (Object(result) === result) return result;\r\n      return self;\r\n    };\r\n  };\r\n\r\n  // Partially apply a function by creating a version that has had some of its\r\n  // arguments pre-filled, without changing its dynamic `this` context.\r\n  _.partial = function(func) {\r\n    var args = slice.call(arguments, 1);\r\n    return function() {\r\n      return func.apply(this, args.concat(slice.call(arguments)));\r\n    };\r\n  };\r\n\r\n  // Bind all of an object's methods to that object. Useful for ensuring that\r\n  // all callbacks defined on an object belong to it.\r\n  _.bindAll = function(obj) {\r\n    var funcs = slice.call(arguments, 1);\r\n    if (funcs.length === 0) throw new Error(\"bindAll must be passed function names\");\r\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\r\n    return obj;\r\n  };\r\n\r\n  // Memoize an expensive function by storing its results.\r\n  _.memoize = function(func, hasher) {\r\n    var memo = {};\r\n    hasher || (hasher = _.identity);\r\n    return function() {\r\n      var key = hasher.apply(this, arguments);\r\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\r\n    };\r\n  };\r\n\r\n  // Delays a function for the given number of milliseconds, and then calls\r\n  // it with the arguments supplied.\r\n  _.delay = function(func, wait) {\r\n    var args = slice.call(arguments, 2);\r\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\r\n  };\r\n\r\n  // Defers a function, scheduling it to run after the current call stack has\r\n  // cleared.\r\n  _.defer = function(func) {\r\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\r\n  };\r\n\r\n  // Returns a function, that, when invoked, will only be triggered at most once\r\n  // during a given window of time. Normally, the throttled function will run\r\n  // as much as it can, without ever going more than once per `wait` duration;\r\n  // but if you'd like to disable the execution on the leading edge, pass\r\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\r\n  _.throttle = function(func, wait, options) {\r\n    var context, args, result;\r\n    var timeout = null;\r\n    var previous = 0;\r\n    options || (options = {});\r\n    var later = function() {\r\n      previous = options.leading === false ? 0 : new Date;\r\n      timeout = null;\r\n      result = func.apply(context, args);\r\n    };\r\n    return function() {\r\n      var now = new Date;\r\n      if (!previous && options.leading === false) previous = now;\r\n      var remaining = wait - (now - previous);\r\n      context = this;\r\n      args = arguments;\r\n      if (remaining <= 0) {\r\n        clearTimeout(timeout);\r\n        timeout = null;\r\n        previous = now;\r\n        result = func.apply(context, args);\r\n      } else if (!timeout && options.trailing !== false) {\r\n        timeout = setTimeout(later, remaining);\r\n      }\r\n      return result;\r\n    };\r\n  };\r\n\r\n  // Returns a function, that, as long as it continues to be invoked, will not\r\n  // be triggered. The function will be called after it stops being called for\r\n  // N milliseconds. If `immediate` is passed, trigger the function on the\r\n  // leading edge, instead of the trailing.\r\n  _.debounce = function(func, wait, immediate) {\r\n    var timeout, args, context, timestamp, result;\r\n    return function() {\r\n      context = this;\r\n      args = arguments;\r\n      timestamp = new Date();\r\n      var later = function() {\r\n        var last = (new Date()) - timestamp;\r\n        if (last < wait) {\r\n          timeout = setTimeout(later, wait - last);\r\n        } else {\r\n          timeout = null;\r\n          if (!immediate) result = func.apply(context, args);\r\n        }\r\n      };\r\n      var callNow = immediate && !timeout;\r\n      if (!timeout) {\r\n        timeout = setTimeout(later, wait);\r\n      }\r\n      if (callNow) result = func.apply(context, args);\r\n      return result;\r\n    };\r\n  };\r\n\r\n  // Returns a function that will be executed at most one time, no matter how\r\n  // often you call it. Useful for lazy initialization.\r\n  _.once = function(func) {\r\n    var ran = false, memo;\r\n    return function() {\r\n      if (ran) return memo;\r\n      ran = true;\r\n      memo = func.apply(this, arguments);\r\n      func = null;\r\n      return memo;\r\n    };\r\n  };\r\n\r\n  // Returns the first function passed as an argument to the second,\r\n  // allowing you to adjust arguments, run code before and after, and\r\n  // conditionally execute the original function.\r\n  _.wrap = function(func, wrapper) {\r\n    return function() {\r\n      var args = [func];\r\n      push.apply(args, arguments);\r\n      return wrapper.apply(this, args);\r\n    };\r\n  };\r\n\r\n  // Returns a function that is the composition of a list of functions, each\r\n  // consuming the return value of the function that follows.\r\n  _.compose = function() {\r\n    var funcs = arguments;\r\n    return function() {\r\n      var args = arguments;\r\n      for (var i = funcs.length - 1; i >= 0; i--) {\r\n        args = [funcs[i].apply(this, args)];\r\n      }\r\n      return args[0];\r\n    };\r\n  };\r\n\r\n  // Returns a function that will only be executed after being called N times.\r\n  _.after = function(times, func) {\r\n    return function() {\r\n      if (--times < 1) {\r\n        return func.apply(this, arguments);\r\n      }\r\n    };\r\n  };\r\n\r\n  // Object Functions\r\n  // ----------------\r\n\r\n  // Retrieve the names of an object's properties.\r\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\r\n  _.keys = nativeKeys || function(obj) {\r\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\r\n    var keys = [];\r\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\r\n    return keys;\r\n  };\r\n\r\n  // Retrieve the values of an object's properties.\r\n  _.values = function(obj) {\r\n    var keys = _.keys(obj);\r\n    var length = keys.length;\r\n    var values = new Array(length);\r\n    for (var i = 0; i < length; i++) {\r\n      values[i] = obj[keys[i]];\r\n    }\r\n    return values;\r\n  };\r\n\r\n  // Convert an object into a list of `[key, value]` pairs.\r\n  _.pairs = function(obj) {\r\n    var keys = _.keys(obj);\r\n    var length = keys.length;\r\n    var pairs = new Array(length);\r\n    for (var i = 0; i < length; i++) {\r\n      pairs[i] = [keys[i], obj[keys[i]]];\r\n    }\r\n    return pairs;\r\n  };\r\n\r\n  // Invert the keys and values of an object. The values must be serializable.\r\n  _.invert = function(obj) {\r\n    var result = {};\r\n    var keys = _.keys(obj);\r\n    for (var i = 0, length = keys.length; i < length; i++) {\r\n      result[obj[keys[i]]] = keys[i];\r\n    }\r\n    return result;\r\n  };\r\n\r\n  // Return a sorted list of the function names available on the object.\r\n  // Aliased as `methods`\r\n  _.functions = _.methods = function(obj) {\r\n    var names = [];\r\n    for (var key in obj) {\r\n      if (_.isFunction(obj[key])) names.push(key);\r\n    }\r\n    return names.sort();\r\n  };\r\n\r\n  // Extend a given object with all the properties in passed-in object(s).\r\n  _.extend = function(obj) {\r\n    each(slice.call(arguments, 1), function(source) {\r\n      if (source) {\r\n        for (var prop in source) {\r\n          obj[prop] = source[prop];\r\n        }\r\n      }\r\n    });\r\n    return obj;\r\n  };\r\n\r\n  // Return a copy of the object only containing the whitelisted properties.\r\n  _.pick = function(obj) {\r\n    var copy = {};\r\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\r\n    each(keys, function(key) {\r\n      if (key in obj) copy[key] = obj[key];\r\n    });\r\n    return copy;\r\n  };\r\n\r\n   // Return a copy of the object without the blacklisted properties.\r\n  _.omit = function(obj) {\r\n    var copy = {};\r\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\r\n    for (var key in obj) {\r\n      if (!_.contains(keys, key)) copy[key] = obj[key];\r\n    }\r\n    return copy;\r\n  };\r\n\r\n  // Fill in a given object with default properties.\r\n  _.defaults = function(obj) {\r\n    each(slice.call(arguments, 1), function(source) {\r\n      if (source) {\r\n        for (var prop in source) {\r\n          if (obj[prop] === void 0) obj[prop] = source[prop];\r\n        }\r\n      }\r\n    });\r\n    return obj;\r\n  };\r\n\r\n  // Create a (shallow-cloned) duplicate of an object.\r\n  _.clone = function(obj) {\r\n    if (!_.isObject(obj)) return obj;\r\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\r\n  };\r\n\r\n  // Invokes interceptor with the obj, and then returns obj.\r\n  // The primary purpose of this method is to \"tap into\" a method chain, in\r\n  // order to perform operations on intermediate results within the chain.\r\n  _.tap = function(obj, interceptor) {\r\n    interceptor(obj);\r\n    return obj;\r\n  };\r\n\r\n  // Internal recursive comparison function for `isEqual`.\r\n  var eq = function(a, b, aStack, bStack) {\r\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\r\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\r\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\r\n    // A strict comparison is necessary because `null == undefined`.\r\n    if (a == null || b == null) return a === b;\r\n    // Unwrap any wrapped objects.\r\n    if (a instanceof _) a = a._wrapped;\r\n    if (b instanceof _) b = b._wrapped;\r\n    // Compare `[[Class]]` names.\r\n    var className = toString.call(a);\r\n    if (className != toString.call(b)) return false;\r\n    switch (className) {\r\n      // Strings, numbers, dates, and booleans are compared by value.\r\n      case '[object String]':\r\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\r\n        // equivalent to `new String(\"5\")`.\r\n        return a == String(b);\r\n      case '[object Number]':\r\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\r\n        // other numeric values.\r\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\r\n      case '[object Date]':\r\n      case '[object Boolean]':\r\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\r\n        // millisecond representations. Note that invalid dates with millisecond representations\r\n        // of `NaN` are not equivalent.\r\n        return +a == +b;\r\n      // RegExps are compared by their source patterns and flags.\r\n      case '[object RegExp]':\r\n        return a.source == b.source &&\r\n               a.global == b.global &&\r\n               a.multiline == b.multiline &&\r\n               a.ignoreCase == b.ignoreCase;\r\n    }\r\n    if (typeof a != 'object' || typeof b != 'object') return false;\r\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\r\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\r\n    var length = aStack.length;\r\n    while (length--) {\r\n      // Linear search. Performance is inversely proportional to the number of\r\n      // unique nested structures.\r\n      if (aStack[length] == a) return bStack[length] == b;\r\n    }\r\n    // Objects with different constructors are not equivalent, but `Object`s\r\n    // from different frames are.\r\n    var aCtor = a.constructor, bCtor = b.constructor;\r\n    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\r\n                             _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\r\n      return false;\r\n    }\r\n    // Add the first object to the stack of traversed objects.\r\n    aStack.push(a);\r\n    bStack.push(b);\r\n    var size = 0, result = true;\r\n    // Recursively compare objects and arrays.\r\n    if (className == '[object Array]') {\r\n      // Compare array lengths to determine if a deep comparison is necessary.\r\n      size = a.length;\r\n      result = size == b.length;\r\n      if (result) {\r\n        // Deep compare the contents, ignoring non-numeric properties.\r\n        while (size--) {\r\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\r\n        }\r\n      }\r\n    } else {\r\n      // Deep compare objects.\r\n      for (var key in a) {\r\n        if (_.has(a, key)) {\r\n          // Count the expected number of properties.\r\n          size++;\r\n          // Deep compare each member.\r\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\r\n        }\r\n      }\r\n      // Ensure that both objects contain the same number of properties.\r\n      if (result) {\r\n        for (key in b) {\r\n          if (_.has(b, key) && !(size--)) break;\r\n        }\r\n        result = !size;\r\n      }\r\n    }\r\n    // Remove the first object from the stack of traversed objects.\r\n    aStack.pop();\r\n    bStack.pop();\r\n    return result;\r\n  };\r\n\r\n  // Perform a deep comparison to check if two objects are equal.\r\n  _.isEqual = function(a, b) {\r\n    return eq(a, b, [], []);\r\n  };\r\n\r\n  // Is a given array, string, or object empty?\r\n  // An \"empty\" object has no enumerable own-properties.\r\n  _.isEmpty = function(obj) {\r\n    if (obj == null) return true;\r\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\r\n    for (var key in obj) if (_.has(obj, key)) return false;\r\n    return true;\r\n  };\r\n\r\n  // Is a given value a DOM element?\r\n  _.isElement = function(obj) {\r\n    return !!(obj && obj.nodeType === 1);\r\n  };\r\n\r\n  // Is a given value an array?\r\n  // Delegates to ECMA5's native Array.isArray\r\n  _.isArray = nativeIsArray || function(obj) {\r\n    return toString.call(obj) == '[object Array]';\r\n  };\r\n\r\n  // Is a given variable an object?\r\n  _.isObject = function(obj) {\r\n    return obj === Object(obj);\r\n  };\r\n\r\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\r\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\r\n    _['is' + name] = function(obj) {\r\n      return toString.call(obj) == '[object ' + name + ']';\r\n    };\r\n  });\r\n\r\n  // Define a fallback version of the method in browsers (ahem, IE), where\r\n  // there isn't any inspectable \"Arguments\" type.\r\n  if (!_.isArguments(arguments)) {\r\n    _.isArguments = function(obj) {\r\n      return !!(obj && _.has(obj, 'callee'));\r\n    };\r\n  }\r\n\r\n  // Optimize `isFunction` if appropriate.\r\n  if (typeof (/./) !== 'function') {\r\n    _.isFunction = function(obj) {\r\n      return typeof obj === 'function';\r\n    };\r\n  }\r\n\r\n  // Is a given object a finite number?\r\n  _.isFinite = function(obj) {\r\n    return isFinite(obj) && !isNaN(parseFloat(obj));\r\n  };\r\n\r\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\r\n  _.isNaN = function(obj) {\r\n    return _.isNumber(obj) && obj != +obj;\r\n  };\r\n\r\n  // Is a given value a boolean?\r\n  _.isBoolean = function(obj) {\r\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\r\n  };\r\n\r\n  // Is a given value equal to null?\r\n  _.isNull = function(obj) {\r\n    return obj === null;\r\n  };\r\n\r\n  // Is a given variable undefined?\r\n  _.isUndefined = function(obj) {\r\n    return obj === void 0;\r\n  };\r\n\r\n  // Shortcut function for checking if an object has a given property directly\r\n  // on itself (in other words, not on a prototype).\r\n  _.has = function(obj, key) {\r\n    return hasOwnProperty.call(obj, key);\r\n  };\r\n\r\n  // Utility Functions\r\n  // -----------------\r\n\r\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\r\n  // previous owner. Returns a reference to the Underscore object.\r\n  _.noConflict = function() {\r\n    root._ = previousUnderscore;\r\n    return this;\r\n  };\r\n\r\n  // Keep the identity function around for default iterators.\r\n  _.identity = function(value) {\r\n    return value;\r\n  };\r\n\r\n  // Run a function **n** times.\r\n  _.times = function(n, iterator, context) {\r\n    var accum = Array(Math.max(0, n));\r\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\r\n    return accum;\r\n  };\r\n\r\n  // Return a random integer between min and max (inclusive).\r\n  _.random = function(min, max) {\r\n    if (max == null) {\r\n      max = min;\r\n      min = 0;\r\n    }\r\n    return min + Math.floor(Math.random() * (max - min + 1));\r\n  };\r\n\r\n  // List of HTML entities for escaping.\r\n  var entityMap = {\r\n    escape: {\r\n      '&': '&amp;',\r\n      '<': '&lt;',\r\n      '>': '&gt;',\r\n      '\"': '&quot;',\r\n      \"'\": '&#x27;'\r\n    }\r\n  };\r\n  entityMap.unescape = _.invert(entityMap.escape);\r\n\r\n  // Regexes containing the keys and values listed immediately above.\r\n  var entityRegexes = {\r\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\r\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\r\n  };\r\n\r\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\r\n  _.each(['escape', 'unescape'], function(method) {\r\n    _[method] = function(string) {\r\n      if (string == null) return '';\r\n      return ('' + string).replace(entityRegexes[method], function(match) {\r\n        return entityMap[method][match];\r\n      });\r\n    };\r\n  });\r\n\r\n  // If the value of the named `property` is a function then invoke it with the\r\n  // `object` as context; otherwise, return it.\r\n  _.result = function(object, property) {\r\n    if (object == null) return void 0;\r\n    var value = object[property];\r\n    return _.isFunction(value) ? value.call(object) : value;\r\n  };\r\n\r\n  // Add your own custom functions to the Underscore object.\r\n  _.mixin = function(obj) {\r\n    each(_.functions(obj), function(name) {\r\n      var func = _[name] = obj[name];\r\n      _.prototype[name] = function() {\r\n        var args = [this._wrapped];\r\n        push.apply(args, arguments);\r\n        return result.call(this, func.apply(_, args));\r\n      };\r\n    });\r\n  };\r\n\r\n  // Generate a unique integer id (unique within the entire client session).\r\n  // Useful for temporary DOM ids.\r\n  var idCounter = 0;\r\n  _.uniqueId = function(prefix) {\r\n    var id = ++idCounter + '';\r\n    return prefix ? prefix + id : id;\r\n  };\r\n\r\n  // By default, Underscore uses ERB-style template delimiters, change the\r\n  // following template settings to use alternative delimiters.\r\n  _.templateSettings = {\r\n    evaluate    : /<%([\\s\\S]+?)%>/g,\r\n    interpolate : /<%=([\\s\\S]+?)%>/g,\r\n    escape      : /<%-([\\s\\S]+?)%>/g\r\n  };\r\n\r\n  // When customizing `templateSettings`, if you don't want to define an\r\n  // interpolation, evaluation or escaping regex, we need one that is\r\n  // guaranteed not to match.\r\n  var noMatch = /(.)^/;\r\n\r\n  // Certain characters need to be escaped so that they can be put into a\r\n  // string literal.\r\n  var escapes = {\r\n    \"'\":      \"'\",\r\n    '\\\\':     '\\\\',\r\n    '\\r':     'r',\r\n    '\\n':     'n',\r\n    '\\t':     't',\r\n    '\\u2028': 'u2028',\r\n    '\\u2029': 'u2029'\r\n  };\r\n\r\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\r\n\r\n  // JavaScript micro-templating, similar to John Resig's implementation.\r\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\r\n  // and correctly escapes quotes within interpolated code.\r\n  _.template = function(text, data, settings) {\r\n    var render;\r\n    settings = _.defaults({}, settings, _.templateSettings);\r\n\r\n    // Combine delimiters into one regular expression via alternation.\r\n    var matcher = new RegExp([\r\n      (settings.escape || noMatch).source,\r\n      (settings.interpolate || noMatch).source,\r\n      (settings.evaluate || noMatch).source\r\n    ].join('|') + '|$', 'g');\r\n\r\n    // Compile the template source, escaping string literals appropriately.\r\n    var index = 0;\r\n    var source = \"__p+='\";\r\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\r\n      source += text.slice(index, offset)\r\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\r\n\r\n      if (escape) {\r\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\r\n      }\r\n      if (interpolate) {\r\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\r\n      }\r\n      if (evaluate) {\r\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\r\n      }\r\n      index = offset + match.length;\r\n      return match;\r\n    });\r\n    source += \"';\\n\";\r\n\r\n    // If a variable is not specified, place data values in local scope.\r\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\r\n\r\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\r\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\r\n      source + \"return __p;\\n\";\r\n\r\n    try {\r\n      render = new Function(settings.variable || 'obj', '_', source);\r\n    } catch (e) {\r\n      e.source = source;\r\n      throw e;\r\n    }\r\n\r\n    if (data) return render(data, _);\r\n    var template = function(data) {\r\n      return render.call(this, data, _);\r\n    };\r\n\r\n    // Provide the compiled function source as a convenience for precompilation.\r\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\r\n\r\n    return template;\r\n  };\r\n\r\n  // Add a \"chain\" function, which will delegate to the wrapper.\r\n  _.chain = function(obj) {\r\n    return _(obj).chain();\r\n  };\r\n\r\n  // OOP\r\n  // ---------------\r\n  // If Underscore is called as a function, it returns a wrapped object that\r\n  // can be used OO-style. This wrapper holds altered versions of all the\r\n  // underscore functions. Wrapped objects may be chained.\r\n\r\n  // Helper function to continue chaining intermediate results.\r\n  var result = function(obj) {\r\n    return this._chain ? _(obj).chain() : obj;\r\n  };\r\n\r\n  // Add all of the Underscore functions to the wrapper object.\r\n  _.mixin(_);\r\n\r\n  // Add all mutator Array functions to the wrapper.\r\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\r\n    var method = ArrayProto[name];\r\n    _.prototype[name] = function() {\r\n      var obj = this._wrapped;\r\n      method.apply(obj, arguments);\r\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\r\n      return result.call(this, obj);\r\n    };\r\n  });\r\n\r\n  // Add all accessor Array functions to the wrapper.\r\n  each(['concat', 'join', 'slice'], function(name) {\r\n    var method = ArrayProto[name];\r\n    _.prototype[name] = function() {\r\n      return result.call(this, method.apply(this._wrapped, arguments));\r\n    };\r\n  });\r\n\r\n  _.extend(_.prototype, {\r\n\r\n    // Start chaining a wrapped Underscore object.\r\n    chain: function() {\r\n      this._chain = true;\r\n      return this;\r\n    },\r\n\r\n    // Extracts the result from a wrapped and chained object.\r\n    value: function() {\r\n      return this._wrapped;\r\n    }\r\n\r\n  });\r\n\r\n}).call(this);\ndefine(\"underscore\", (function (global) {\n    return function () {\n        var ret, fn;\n        return ret || global._;\n    };\n}(this)));\n",
    "\n//     Backbone.js 1.0.0\r\n\r\n//     (c) 2010-2013 Jeremy Ashkenas, DocumentCloud Inc.\r\n//     Backbone may be freely distributed under the MIT license.\r\n//     For all details and documentation:\r\n//     http://backbonejs.org\r\n\r\n(function(){\r\n\r\n  // Initial Setup\r\n  // -------------\r\n\r\n  // Save a reference to the global object (`window` in the browser, `exports`\r\n  // on the server).\r\n  var root = this;\r\n\r\n  // Save the previous value of the `Backbone` variable, so that it can be\r\n  // restored later on, if `noConflict` is used.\r\n  var previousBackbone = root.Backbone;\r\n\r\n  // Create local references to array methods we'll want to use later.\r\n  var array = [];\r\n  var push = array.push;\r\n  var slice = array.slice;\r\n  var splice = array.splice;\r\n\r\n  // The top-level namespace. All public Backbone classes and modules will\r\n  // be attached to this. Exported for both the browser and the server.\r\n  var Backbone;\r\n  if (typeof exports !== 'undefined') {\r\n    Backbone = exports;\r\n  } else {\r\n    Backbone = root.Backbone = {};\r\n  }\r\n\r\n  // Current version of the library. Keep in sync with `package.json`.\r\n  Backbone.VERSION = '1.0.0';\r\n\r\n  // Require Underscore, if we're on the server, and it's not already present.\r\n  var _ = root._;\r\n  if (!_ && (typeof require !== 'undefined')) _ = require('underscore');\r\n\r\n  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns\r\n  // the `$` variable.\r\n  Backbone.$ = root.jQuery || root.Zepto || root.ender || root.$;\r\n\r\n  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable\r\n  // to its previous owner. Returns a reference to this Backbone object.\r\n  Backbone.noConflict = function() {\r\n    root.Backbone = previousBackbone;\r\n    return this;\r\n  };\r\n\r\n  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option\r\n  // will fake `\"PUT\"` and `\"DELETE\"` requests via the `_method` parameter and\r\n  // set a `X-Http-Method-Override` header.\r\n  Backbone.emulateHTTP = false;\r\n\r\n  // Turn on `emulateJSON` to support legacy servers that can't deal with direct\r\n  // `application/json` requests ... will encode the body as\r\n  // `application/x-www-form-urlencoded` instead and will send the model in a\r\n  // form param named `model`.\r\n  Backbone.emulateJSON = false;\r\n\r\n  // Backbone.Events\r\n  // ---------------\r\n\r\n  // A module that can be mixed in to *any object* in order to provide it with\r\n  // custom events. You may bind with `on` or remove with `off` callback\r\n  // functions to an event; `trigger`-ing an event fires all callbacks in\r\n  // succession.\r\n  //\r\n  //     var object = {};\r\n  //     _.extend(object, Backbone.Events);\r\n  //     object.on('expand', function(){ alert('expanded'); });\r\n  //     object.trigger('expand');\r\n  //\r\n  var Events = Backbone.Events = {\r\n\r\n    // Bind an event to a `callback` function. Passing `\"all\"` will bind\r\n    // the callback to all events fired.\r\n    on: function(name, callback, context) {\r\n      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;\r\n      this._events || (this._events = {});\r\n      var events = this._events[name] || (this._events[name] = []);\r\n      events.push({callback: callback, context: context, ctx: context || this});\r\n      return this;\r\n    },\r\n\r\n    // Bind an event to only be triggered a single time. After the first time\r\n    // the callback is invoked, it will be removed.\r\n    once: function(name, callback, context) {\r\n      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;\r\n      var self = this;\r\n      var once = _.once(function() {\r\n        self.off(name, once);\r\n        callback.apply(this, arguments);\r\n      });\r\n      once._callback = callback;\r\n      return this.on(name, once, context);\r\n    },\r\n\r\n    // Remove one or many callbacks. If `context` is null, removes all\r\n    // callbacks with that function. If `callback` is null, removes all\r\n    // callbacks for the event. If `name` is null, removes all bound\r\n    // callbacks for all events.\r\n    off: function(name, callback, context) {\r\n      var retain, ev, events, names, i, l, j, k;\r\n      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;\r\n      if (!name && !callback && !context) {\r\n        this._events = {};\r\n        return this;\r\n      }\r\n\r\n      names = name ? [name] : _.keys(this._events);\r\n      for (i = 0, l = names.length; i < l; i++) {\r\n        name = names[i];\r\n        if (events = this._events[name]) {\r\n          this._events[name] = retain = [];\r\n          if (callback || context) {\r\n            for (j = 0, k = events.length; j < k; j++) {\r\n              ev = events[j];\r\n              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||\r\n                  (context && context !== ev.context)) {\r\n                retain.push(ev);\r\n              }\r\n            }\r\n          }\r\n          if (!retain.length) delete this._events[name];\r\n        }\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    // Trigger one or many events, firing all bound callbacks. Callbacks are\r\n    // passed the same arguments as `trigger` is, apart from the event name\r\n    // (unless you're listening on `\"all\"`, which will cause your callback to\r\n    // receive the true name of the event as the first argument).\r\n    trigger: function(name) {\r\n      if (!this._events) return this;\r\n      var args = slice.call(arguments, 1);\r\n      if (!eventsApi(this, 'trigger', name, args)) return this;\r\n      var events = this._events[name];\r\n      var allEvents = this._events.all;\r\n      if (events) triggerEvents(events, args);\r\n      if (allEvents) triggerEvents(allEvents, arguments);\r\n      return this;\r\n    },\r\n\r\n    // Tell this object to stop listening to either specific events ... or\r\n    // to every object it's currently listening to.\r\n    stopListening: function(obj, name, callback) {\r\n      var listeners = this._listeners;\r\n      if (!listeners) return this;\r\n      var deleteListener = !name && !callback;\r\n      if (typeof name === 'object') callback = this;\r\n      if (obj) (listeners = {})[obj._listenerId] = obj;\r\n      for (var id in listeners) {\r\n        listeners[id].off(name, callback, this);\r\n        if (deleteListener) delete this._listeners[id];\r\n      }\r\n      return this;\r\n    }\r\n\r\n  };\r\n\r\n  // Regular expression used to split event strings.\r\n  var eventSplitter = /\\s+/;\r\n\r\n  // Implement fancy features of the Events API such as multiple event\r\n  // names `\"change blur\"` and jQuery-style event maps `{change: action}`\r\n  // in terms of the existing API.\r\n  var eventsApi = function(obj, action, name, rest) {\r\n    if (!name) return true;\r\n\r\n    // Handle event maps.\r\n    if (typeof name === 'object') {\r\n      for (var key in name) {\r\n        obj[action].apply(obj, [key, name[key]].concat(rest));\r\n      }\r\n      return false;\r\n    }\r\n\r\n    // Handle space separated event names.\r\n    if (eventSplitter.test(name)) {\r\n      var names = name.split(eventSplitter);\r\n      for (var i = 0, l = names.length; i < l; i++) {\r\n        obj[action].apply(obj, [names[i]].concat(rest));\r\n      }\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  // A difficult-to-believe, but optimized internal dispatch function for\r\n  // triggering events. Tries to keep the usual cases speedy (most internal\r\n  // Backbone events have 3 arguments).\r\n  var triggerEvents = function(events, args) {\r\n    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\r\n    switch (args.length) {\r\n      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;\r\n      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;\r\n      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;\r\n      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;\r\n      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);\r\n    }\r\n  };\r\n\r\n  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};\r\n\r\n  // Inversion-of-control versions of `on` and `once`. Tell *this* object to\r\n  // listen to an event in another object ... keeping track of what it's\r\n  // listening to.\r\n  _.each(listenMethods, function(implementation, method) {\r\n    Events[method] = function(obj, name, callback) {\r\n      var listeners = this._listeners || (this._listeners = {});\r\n      var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));\r\n      listeners[id] = obj;\r\n      if (typeof name === 'object') callback = this;\r\n      obj[implementation](name, callback, this);\r\n      return this;\r\n    };\r\n  });\r\n\r\n  // Aliases for backwards compatibility.\r\n  Events.bind   = Events.on;\r\n  Events.unbind = Events.off;\r\n\r\n  // Allow the `Backbone` object to serve as a global event bus, for folks who\r\n  // want global \"pubsub\" in a convenient place.\r\n  _.extend(Backbone, Events);\r\n\r\n  // Backbone.Model\r\n  // --------------\r\n\r\n  // Backbone **Models** are the basic data object in the framework --\r\n  // frequently representing a row in a table in a database on your server.\r\n  // A discrete chunk of data and a bunch of useful, related methods for\r\n  // performing computations and transformations on that data.\r\n\r\n  // Create a new model with the specified attributes. A client id (`cid`)\r\n  // is automatically generated and assigned for you.\r\n  var Model = Backbone.Model = function(attributes, options) {\r\n    var defaults;\r\n    var attrs = attributes || {};\r\n    options || (options = {});\r\n    this.cid = _.uniqueId('c');\r\n    this.attributes = {};\r\n    _.extend(this, _.pick(options, modelOptions));\r\n    if (options.parse) attrs = this.parse(attrs, options) || {};\r\n    if (defaults = _.result(this, 'defaults')) {\r\n      attrs = _.defaults({}, attrs, defaults);\r\n    }\r\n    this.set(attrs, options);\r\n    this.changed = {};\r\n    this.initialize.apply(this, arguments);\r\n  };\r\n\r\n  // A list of options to be attached directly to the model, if provided.\r\n  var modelOptions = ['url', 'urlRoot', 'collection'];\r\n\r\n  // Attach all inheritable methods to the Model prototype.\r\n  _.extend(Model.prototype, Events, {\r\n\r\n    // A hash of attributes whose current and previous value differ.\r\n    changed: null,\r\n\r\n    // The value returned during the last failed validation.\r\n    validationError: null,\r\n\r\n    // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\r\n    // CouchDB users may want to set this to `\"_id\"`.\r\n    idAttribute: 'id',\r\n\r\n    // Initialize is an empty function by default. Override it with your own\r\n    // initialization logic.\r\n    initialize: function(){},\r\n\r\n    // Return a copy of the model's `attributes` object.\r\n    toJSON: function(options) {\r\n      return _.clone(this.attributes);\r\n    },\r\n\r\n    // Proxy `Backbone.sync` by default -- but override this if you need\r\n    // custom syncing semantics for *this* particular model.\r\n    sync: function() {\r\n      return Backbone.sync.apply(this, arguments);\r\n    },\r\n\r\n    // Get the value of an attribute.\r\n    get: function(attr) {\r\n      return this.attributes[attr];\r\n    },\r\n\r\n    // Get the HTML-escaped value of an attribute.\r\n    escape: function(attr) {\r\n      return _.escape(this.get(attr));\r\n    },\r\n\r\n    // Returns `true` if the attribute contains a value that is not null\r\n    // or undefined.\r\n    has: function(attr) {\r\n      return this.get(attr) != null;\r\n    },\r\n\r\n    // Set a hash of model attributes on the object, firing `\"change\"`. This is\r\n    // the core primitive operation of a model, updating the data and notifying\r\n    // anyone who needs to know about the change in state. The heart of the beast.\r\n    set: function(key, val, options) {\r\n      var attr, attrs, unset, changes, silent, changing, prev, current;\r\n      if (key == null) return this;\r\n\r\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\r\n      if (typeof key === 'object') {\r\n        attrs = key;\r\n        options = val;\r\n      } else {\r\n        (attrs = {})[key] = val;\r\n      }\r\n\r\n      options || (options = {});\r\n\r\n      // Run validation.\r\n      if (!this._validate(attrs, options)) return false;\r\n\r\n      // Extract attributes and options.\r\n      unset           = options.unset;\r\n      silent          = options.silent;\r\n      changes         = [];\r\n      changing        = this._changing;\r\n      this._changing  = true;\r\n\r\n      if (!changing) {\r\n        this._previousAttributes = _.clone(this.attributes);\r\n        this.changed = {};\r\n      }\r\n      current = this.attributes, prev = this._previousAttributes;\r\n\r\n      // Check for changes of `id`.\r\n      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];\r\n\r\n      // For each `set` attribute, update or delete the current value.\r\n      for (attr in attrs) {\r\n        val = attrs[attr];\r\n        if (!_.isEqual(current[attr], val)) changes.push(attr);\r\n        if (!_.isEqual(prev[attr], val)) {\r\n          this.changed[attr] = val;\r\n        } else {\r\n          delete this.changed[attr];\r\n        }\r\n        unset ? delete current[attr] : current[attr] = val;\r\n      }\r\n\r\n      // Trigger all relevant attribute changes.\r\n      if (!silent) {\r\n        if (changes.length) this._pending = true;\r\n        for (var i = 0, l = changes.length; i < l; i++) {\r\n          this.trigger('change:' + changes[i], this, current[changes[i]], options);\r\n        }\r\n      }\r\n\r\n      // You might be wondering why there's a `while` loop here. Changes can\r\n      // be recursively nested within `\"change\"` events.\r\n      if (changing) return this;\r\n      if (!silent) {\r\n        while (this._pending) {\r\n          this._pending = false;\r\n          this.trigger('change', this, options);\r\n        }\r\n      }\r\n      this._pending = false;\r\n      this._changing = false;\r\n      return this;\r\n    },\r\n\r\n    // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\r\n    // if the attribute doesn't exist.\r\n    unset: function(attr, options) {\r\n      return this.set(attr, void 0, _.extend({}, options, {unset: true}));\r\n    },\r\n\r\n    // Clear all attributes on the model, firing `\"change\"`.\r\n    clear: function(options) {\r\n      var attrs = {};\r\n      for (var key in this.attributes) attrs[key] = void 0;\r\n      return this.set(attrs, _.extend({}, options, {unset: true}));\r\n    },\r\n\r\n    // Determine if the model has changed since the last `\"change\"` event.\r\n    // If you specify an attribute name, determine if that attribute has changed.\r\n    hasChanged: function(attr) {\r\n      if (attr == null) return !_.isEmpty(this.changed);\r\n      return _.has(this.changed, attr);\r\n    },\r\n\r\n    // Return an object containing all the attributes that have changed, or\r\n    // false if there are no changed attributes. Useful for determining what\r\n    // parts of a view need to be updated and/or what attributes need to be\r\n    // persisted to the server. Unset attributes will be set to undefined.\r\n    // You can also pass an attributes object to diff against the model,\r\n    // determining if there *would be* a change.\r\n    changedAttributes: function(diff) {\r\n      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;\r\n      var val, changed = false;\r\n      var old = this._changing ? this._previousAttributes : this.attributes;\r\n      for (var attr in diff) {\r\n        if (_.isEqual(old[attr], (val = diff[attr]))) continue;\r\n        (changed || (changed = {}))[attr] = val;\r\n      }\r\n      return changed;\r\n    },\r\n\r\n    // Get the previous value of an attribute, recorded at the time the last\r\n    // `\"change\"` event was fired.\r\n    previous: function(attr) {\r\n      if (attr == null || !this._previousAttributes) return null;\r\n      return this._previousAttributes[attr];\r\n    },\r\n\r\n    // Get all of the attributes of the model at the time of the previous\r\n    // `\"change\"` event.\r\n    previousAttributes: function() {\r\n      return _.clone(this._previousAttributes);\r\n    },\r\n\r\n    // Fetch the model from the server. If the server's representation of the\r\n    // model differs from its current attributes, they will be overridden,\r\n    // triggering a `\"change\"` event.\r\n    fetch: function(options) {\r\n      options = options ? _.clone(options) : {};\r\n      if (options.parse === void 0) options.parse = true;\r\n      var model = this;\r\n      var success = options.success;\r\n      options.success = function(resp) {\r\n        if (!model.set(model.parse(resp, options), options)) return false;\r\n        if (success) success(model, resp, options);\r\n        model.trigger('sync', model, resp, options);\r\n      };\r\n      wrapError(this, options);\r\n      return this.sync('read', this, options);\r\n    },\r\n\r\n    // Set a hash of model attributes, and sync the model to the server.\r\n    // If the server returns an attributes hash that differs, the model's\r\n    // state will be `set` again.\r\n    save: function(key, val, options) {\r\n      var attrs, method, xhr, attributes = this.attributes;\r\n\r\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\r\n      if (key == null || typeof key === 'object') {\r\n        attrs = key;\r\n        options = val;\r\n      } else {\r\n        (attrs = {})[key] = val;\r\n      }\r\n\r\n      // If we're not waiting and attributes exist, save acts as `set(attr).save(null, opts)`.\r\n      if (attrs && (!options || !options.wait) && !this.set(attrs, options)) return false;\r\n\r\n      options = _.extend({validate: true}, options);\r\n\r\n      // Do not persist invalid models.\r\n      if (!this._validate(attrs, options)) return false;\r\n\r\n      // Set temporary attributes if `{wait: true}`.\r\n      if (attrs && options.wait) {\r\n        this.attributes = _.extend({}, attributes, attrs);\r\n      }\r\n\r\n      // After a successful server-side save, the client is (optionally)\r\n      // updated with the server-side state.\r\n      if (options.parse === void 0) options.parse = true;\r\n      var model = this;\r\n      var success = options.success;\r\n      options.success = function(resp) {\r\n        // Ensure attributes are restored during synchronous saves.\r\n        model.attributes = attributes;\r\n        var serverAttrs = model.parse(resp, options);\r\n        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);\r\n        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {\r\n          return false;\r\n        }\r\n        if (success) success(model, resp, options);\r\n        model.trigger('sync', model, resp, options);\r\n      };\r\n      wrapError(this, options);\r\n\r\n      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\r\n      if (method === 'patch') options.attrs = attrs;\r\n      xhr = this.sync(method, this, options);\r\n\r\n      // Restore attributes.\r\n      if (attrs && options.wait) this.attributes = attributes;\r\n\r\n      return xhr;\r\n    },\r\n\r\n    // Destroy this model on the server if it was already persisted.\r\n    // Optimistically removes the model from its collection, if it has one.\r\n    // If `wait: true` is passed, waits for the server to respond before removal.\r\n    destroy: function(options) {\r\n      options = options ? _.clone(options) : {};\r\n      var model = this;\r\n      var success = options.success;\r\n\r\n      var destroy = function() {\r\n        model.trigger('destroy', model, model.collection, options);\r\n      };\r\n\r\n      options.success = function(resp) {\r\n        if (options.wait || model.isNew()) destroy();\r\n        if (success) success(model, resp, options);\r\n        if (!model.isNew()) model.trigger('sync', model, resp, options);\r\n      };\r\n\r\n      if (this.isNew()) {\r\n        options.success();\r\n        return false;\r\n      }\r\n      wrapError(this, options);\r\n\r\n      var xhr = this.sync('delete', this, options);\r\n      if (!options.wait) destroy();\r\n      return xhr;\r\n    },\r\n\r\n    // Default URL for the model's representation on the server -- if you're\r\n    // using Backbone's restful methods, override this to change the endpoint\r\n    // that will be called.\r\n    url: function() {\r\n      var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();\r\n      if (this.isNew()) return base;\r\n      return base + (base.charAt(base.length - 1) === '/' ? '' : '/') + encodeURIComponent(this.id);\r\n    },\r\n\r\n    // **parse** converts a response into the hash of attributes to be `set` on\r\n    // the model. The default implementation is just to pass the response along.\r\n    parse: function(resp, options) {\r\n      return resp;\r\n    },\r\n\r\n    // Create a new model with identical attributes to this one.\r\n    clone: function() {\r\n      return new this.constructor(this.attributes);\r\n    },\r\n\r\n    // A model is new if it has never been saved to the server, and lacks an id.\r\n    isNew: function() {\r\n      return this.id == null;\r\n    },\r\n\r\n    // Check if the model is currently in a valid state.\r\n    isValid: function(options) {\r\n      return this._validate({}, _.extend(options || {}, { validate: true }));\r\n    },\r\n\r\n    // Run validation against the next complete set of model attributes,\r\n    // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\r\n    _validate: function(attrs, options) {\r\n      if (!options.validate || !this.validate) return true;\r\n      attrs = _.extend({}, this.attributes, attrs);\r\n      var error = this.validationError = this.validate(attrs, options) || null;\r\n      if (!error) return true;\r\n      this.trigger('invalid', this, error, _.extend(options || {}, {validationError: error}));\r\n      return false;\r\n    }\r\n\r\n  });\r\n\r\n  // Underscore methods that we want to implement on the Model.\r\n  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];\r\n\r\n  // Mix in each Underscore method as a proxy to `Model#attributes`.\r\n  _.each(modelMethods, function(method) {\r\n    Model.prototype[method] = function() {\r\n      var args = slice.call(arguments);\r\n      args.unshift(this.attributes);\r\n      return _[method].apply(_, args);\r\n    };\r\n  });\r\n\r\n  // Backbone.Collection\r\n  // -------------------\r\n\r\n  // If models tend to represent a single row of data, a Backbone Collection is\r\n  // more analagous to a table full of data ... or a small slice or page of that\r\n  // table, or a collection of rows that belong together for a particular reason\r\n  // -- all of the messages in this particular folder, all of the documents\r\n  // belonging to this particular author, and so on. Collections maintain\r\n  // indexes of their models, both in order, and for lookup by `id`.\r\n\r\n  // Create a new **Collection**, perhaps to contain a specific type of `model`.\r\n  // If a `comparator` is specified, the Collection will maintain\r\n  // its models in sort order, as they're added and removed.\r\n  var Collection = Backbone.Collection = function(models, options) {\r\n    options || (options = {});\r\n    if (options.url) this.url = options.url;\r\n    if (options.model) this.model = options.model;\r\n    if (options.comparator !== void 0) this.comparator = options.comparator;\r\n    this._reset();\r\n    this.initialize.apply(this, arguments);\r\n    if (models) this.reset(models, _.extend({silent: true}, options));\r\n  };\r\n\r\n  // Default options for `Collection#set`.\r\n  var setOptions = {add: true, remove: true, merge: true};\r\n  var addOptions = {add: true, merge: false, remove: false};\r\n\r\n  // Define the Collection's inheritable methods.\r\n  _.extend(Collection.prototype, Events, {\r\n\r\n    // The default model for a collection is just a **Backbone.Model**.\r\n    // This should be overridden in most cases.\r\n    model: Model,\r\n\r\n    // Initialize is an empty function by default. Override it with your own\r\n    // initialization logic.\r\n    initialize: function(){},\r\n\r\n    // The JSON representation of a Collection is an array of the\r\n    // models' attributes.\r\n    toJSON: function(options) {\r\n      return this.map(function(model){ return model.toJSON(options); });\r\n    },\r\n\r\n    // Proxy `Backbone.sync` by default.\r\n    sync: function() {\r\n      return Backbone.sync.apply(this, arguments);\r\n    },\r\n\r\n    // Add a model, or list of models to the set.\r\n    add: function(models, options) {\r\n      return this.set(models, _.defaults(options || {}, addOptions));\r\n    },\r\n\r\n    // Remove a model, or a list of models from the set.\r\n    remove: function(models, options) {\r\n      models = _.isArray(models) ? models.slice() : [models];\r\n      options || (options = {});\r\n      var i, l, index, model;\r\n      for (i = 0, l = models.length; i < l; i++) {\r\n        model = this.get(models[i]);\r\n        if (!model) continue;\r\n        delete this._byId[model.id];\r\n        delete this._byId[model.cid];\r\n        index = this.indexOf(model);\r\n        this.models.splice(index, 1);\r\n        this.length--;\r\n        if (!options.silent) {\r\n          options.index = index;\r\n          model.trigger('remove', model, this, options);\r\n        }\r\n        this._removeReference(model);\r\n      }\r\n      return this;\r\n    },\r\n\r\n    // Update a collection by `set`-ing a new list of models, adding new ones,\r\n    // removing models that are no longer present, and merging models that\r\n    // already exist in the collection, as necessary. Similar to **Model#set**,\r\n    // the core operation for updating the data contained by the collection.\r\n    set: function(models, options) {\r\n      options = _.defaults(options || {}, setOptions);\r\n      if (options.parse) models = this.parse(models, options);\r\n      if (!_.isArray(models)) models = models ? [models] : [];\r\n      var i, l, model, attrs, existing, sort;\r\n      var at = options.at;\r\n      var sortable = this.comparator && (at == null) && options.sort !== false;\r\n      var sortAttr = _.isString(this.comparator) ? this.comparator : null;\r\n      var toAdd = [], toRemove = [], modelMap = {};\r\n\r\n      // Turn bare objects into model references, and prevent invalid models\r\n      // from being added.\r\n      for (i = 0, l = models.length; i < l; i++) {\r\n        if (!(model = this._prepareModel(models[i], options))) continue;\r\n\r\n        // If a duplicate is found, prevent it from being added and\r\n        // optionally merge it into the existing model.\r\n        if (existing = this.get(model)) {\r\n          if (options.remove) modelMap[existing.cid] = true;\r\n          if (options.merge) {\r\n            existing.set(model.attributes, options);\r\n            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;\r\n          }\r\n\r\n        // This is a new model, push it to the `toAdd` list.\r\n        } else if (options.add) {\r\n          toAdd.push(model);\r\n\r\n          // Listen to added models' events, and index models for lookup by\r\n          // `id` and by `cid`.\r\n          model.on('all', this._onModelEvent, this);\r\n          this._byId[model.cid] = model;\r\n          if (model.id != null) this._byId[model.id] = model;\r\n        }\r\n      }\r\n\r\n      // Remove nonexistent models if appropriate.\r\n      if (options.remove) {\r\n        for (i = 0, l = this.length; i < l; ++i) {\r\n          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);\r\n        }\r\n        if (toRemove.length) this.remove(toRemove, options);\r\n      }\r\n\r\n      // See if sorting is needed, update `length` and splice in new models.\r\n      if (toAdd.length) {\r\n        if (sortable) sort = true;\r\n        this.length += toAdd.length;\r\n        if (at != null) {\r\n          splice.apply(this.models, [at, 0].concat(toAdd));\r\n        } else {\r\n          push.apply(this.models, toAdd);\r\n        }\r\n      }\r\n\r\n      // Silently sort the collection if appropriate.\r\n      if (sort) this.sort({silent: true});\r\n\r\n      if (options.silent) return this;\r\n\r\n      // Trigger `add` events.\r\n      for (i = 0, l = toAdd.length; i < l; i++) {\r\n        (model = toAdd[i]).trigger('add', model, this, options);\r\n      }\r\n\r\n      // Trigger `sort` if the collection was sorted.\r\n      if (sort) this.trigger('sort', this, options);\r\n      return this;\r\n    },\r\n\r\n    // When you have more items than you want to add or remove individually,\r\n    // you can reset the entire set with a new list of models, without firing\r\n    // any granular `add` or `remove` events. Fires `reset` when finished.\r\n    // Useful for bulk operations and optimizations.\r\n    reset: function(models, options) {\r\n      options || (options = {});\r\n      for (var i = 0, l = this.models.length; i < l; i++) {\r\n        this._removeReference(this.models[i]);\r\n      }\r\n      options.previousModels = this.models;\r\n      this._reset();\r\n      this.add(models, _.extend({silent: true}, options));\r\n      if (!options.silent) this.trigger('reset', this, options);\r\n      return this;\r\n    },\r\n\r\n    // Add a model to the end of the collection.\r\n    push: function(model, options) {\r\n      model = this._prepareModel(model, options);\r\n      this.add(model, _.extend({at: this.length}, options));\r\n      return model;\r\n    },\r\n\r\n    // Remove a model from the end of the collection.\r\n    pop: function(options) {\r\n      var model = this.at(this.length - 1);\r\n      this.remove(model, options);\r\n      return model;\r\n    },\r\n\r\n    // Add a model to the beginning of the collection.\r\n    unshift: function(model, options) {\r\n      model = this._prepareModel(model, options);\r\n      this.add(model, _.extend({at: 0}, options));\r\n      return model;\r\n    },\r\n\r\n    // Remove a model from the beginning of the collection.\r\n    shift: function(options) {\r\n      var model = this.at(0);\r\n      this.remove(model, options);\r\n      return model;\r\n    },\r\n\r\n    // Slice out a sub-array of models from the collection.\r\n    slice: function(begin, end) {\r\n      return this.models.slice(begin, end);\r\n    },\r\n\r\n    // Get a model from the set by id.\r\n    get: function(obj) {\r\n      if (obj == null) return void 0;\r\n      return this._byId[obj.id != null ? obj.id : obj.cid || obj];\r\n    },\r\n\r\n    // Get the model at the given index.\r\n    at: function(index) {\r\n      return this.models[index];\r\n    },\r\n\r\n    // Return models with matching attributes. Useful for simple cases of\r\n    // `filter`.\r\n    where: function(attrs, first) {\r\n      if (_.isEmpty(attrs)) return first ? void 0 : [];\r\n      return this[first ? 'find' : 'filter'](function(model) {\r\n        for (var key in attrs) {\r\n          if (attrs[key] !== model.get(key)) return false;\r\n        }\r\n        return true;\r\n      });\r\n    },\r\n\r\n    // Return the first model with matching attributes. Useful for simple cases\r\n    // of `find`.\r\n    findWhere: function(attrs) {\r\n      return this.where(attrs, true);\r\n    },\r\n\r\n    // Force the collection to re-sort itself. You don't need to call this under\r\n    // normal circumstances, as the set will maintain sort order as each item\r\n    // is added.\r\n    sort: function(options) {\r\n      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');\r\n      options || (options = {});\r\n\r\n      // Run sort based on type of `comparator`.\r\n      if (_.isString(this.comparator) || this.comparator.length === 1) {\r\n        this.models = this.sortBy(this.comparator, this);\r\n      } else {\r\n        this.models.sort(_.bind(this.comparator, this));\r\n      }\r\n\r\n      if (!options.silent) this.trigger('sort', this, options);\r\n      return this;\r\n    },\r\n\r\n    // Figure out the smallest index at which a model should be inserted so as\r\n    // to maintain order.\r\n    sortedIndex: function(model, value, context) {\r\n      value || (value = this.comparator);\r\n      var iterator = _.isFunction(value) ? value : function(model) {\r\n        return model.get(value);\r\n      };\r\n      return _.sortedIndex(this.models, model, iterator, context);\r\n    },\r\n\r\n    // Pluck an attribute from each model in the collection.\r\n    pluck: function(attr) {\r\n      return _.invoke(this.models, 'get', attr);\r\n    },\r\n\r\n    // Fetch the default set of models for this collection, resetting the\r\n    // collection when they arrive. If `reset: true` is passed, the response\r\n    // data will be passed through the `reset` method instead of `set`.\r\n    fetch: function(options) {\r\n      options = options ? _.clone(options) : {};\r\n      if (options.parse === void 0) options.parse = true;\r\n      var success = options.success;\r\n      var collection = this;\r\n      options.success = function(resp) {\r\n        var method = options.reset ? 'reset' : 'set';\r\n        collection[method](resp, options);\r\n        if (success) success(collection, resp, options);\r\n        collection.trigger('sync', collection, resp, options);\r\n      };\r\n      wrapError(this, options);\r\n      return this.sync('read', this, options);\r\n    },\r\n\r\n    // Create a new instance of a model in this collection. Add the model to the\r\n    // collection immediately, unless `wait: true` is passed, in which case we\r\n    // wait for the server to agree.\r\n    create: function(model, options) {\r\n      options = options ? _.clone(options) : {};\r\n      if (!(model = this._prepareModel(model, options))) return false;\r\n      if (!options.wait) this.add(model, options);\r\n      var collection = this;\r\n      var success = options.success;\r\n      options.success = function(resp) {\r\n        if (options.wait) collection.add(model, options);\r\n        if (success) success(model, resp, options);\r\n      };\r\n      model.save(null, options);\r\n      return model;\r\n    },\r\n\r\n    // **parse** converts a response into a list of models to be added to the\r\n    // collection. The default implementation is just to pass it through.\r\n    parse: function(resp, options) {\r\n      return resp;\r\n    },\r\n\r\n    // Create a new collection with an identical list of models as this one.\r\n    clone: function() {\r\n      return new this.constructor(this.models);\r\n    },\r\n\r\n    // Private method to reset all internal state. Called when the collection\r\n    // is first initialized or reset.\r\n    _reset: function() {\r\n      this.length = 0;\r\n      this.models = [];\r\n      this._byId  = {};\r\n    },\r\n\r\n    // Prepare a hash of attributes (or other model) to be added to this\r\n    // collection.\r\n    _prepareModel: function(attrs, options) {\r\n      if (attrs instanceof Model) {\r\n        if (!attrs.collection) attrs.collection = this;\r\n        return attrs;\r\n      }\r\n      options || (options = {});\r\n      options.collection = this;\r\n      var model = new this.model(attrs, options);\r\n      if (!model._validate(attrs, options)) {\r\n        this.trigger('invalid', this, attrs, options);\r\n        return false;\r\n      }\r\n      return model;\r\n    },\r\n\r\n    // Internal method to sever a model's ties to a collection.\r\n    _removeReference: function(model) {\r\n      if (this === model.collection) delete model.collection;\r\n      model.off('all', this._onModelEvent, this);\r\n    },\r\n\r\n    // Internal method called every time a model in the set fires an event.\r\n    // Sets need to update their indexes when models change ids. All other\r\n    // events simply proxy through. \"add\" and \"remove\" events that originate\r\n    // in other collections are ignored.\r\n    _onModelEvent: function(event, model, collection, options) {\r\n      if ((event === 'add' || event === 'remove') && collection !== this) return;\r\n      if (event === 'destroy') this.remove(model, options);\r\n      if (model && event === 'change:' + model.idAttribute) {\r\n        delete this._byId[model.previous(model.idAttribute)];\r\n        if (model.id != null) this._byId[model.id] = model;\r\n      }\r\n      this.trigger.apply(this, arguments);\r\n    }\r\n\r\n  });\r\n\r\n  // Underscore methods that we want to implement on the Collection.\r\n  // 90% of the core usefulness of Backbone Collections is actually implemented\r\n  // right here:\r\n  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',\r\n    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',\r\n    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',\r\n    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',\r\n    'tail', 'drop', 'last', 'without', 'indexOf', 'shuffle', 'lastIndexOf',\r\n    'isEmpty', 'chain'];\r\n\r\n  // Mix in each Underscore method as a proxy to `Collection#models`.\r\n  _.each(methods, function(method) {\r\n    Collection.prototype[method] = function() {\r\n      var args = slice.call(arguments);\r\n      args.unshift(this.models);\r\n      return _[method].apply(_, args);\r\n    };\r\n  });\r\n\r\n  // Underscore methods that take a property name as an argument.\r\n  var attributeMethods = ['groupBy', 'countBy', 'sortBy'];\r\n\r\n  // Use attributes instead of properties.\r\n  _.each(attributeMethods, function(method) {\r\n    Collection.prototype[method] = function(value, context) {\r\n      var iterator = _.isFunction(value) ? value : function(model) {\r\n        return model.get(value);\r\n      };\r\n      return _[method](this.models, iterator, context);\r\n    };\r\n  });\r\n\r\n  // Backbone.View\r\n  // -------------\r\n\r\n  // Backbone Views are almost more convention than they are actual code. A View\r\n  // is simply a JavaScript object that represents a logical chunk of UI in the\r\n  // DOM. This might be a single item, an entire list, a sidebar or panel, or\r\n  // even the surrounding frame which wraps your whole app. Defining a chunk of\r\n  // UI as a **View** allows you to define your DOM events declaratively, without\r\n  // having to worry about render order ... and makes it easy for the view to\r\n  // react to specific changes in the state of your models.\r\n\r\n  // Creating a Backbone.View creates its initial element outside of the DOM,\r\n  // if an existing element is not provided...\r\n  var View = Backbone.View = function(options) {\r\n    this.cid = _.uniqueId('view');\r\n    this._configure(options || {});\r\n    this._ensureElement();\r\n    this.initialize.apply(this, arguments);\r\n    this.delegateEvents();\r\n  };\r\n\r\n  // Cached regex to split keys for `delegate`.\r\n  var delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\r\n\r\n  // List of view options to be merged as properties.\r\n  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];\r\n\r\n  // Set up all inheritable **Backbone.View** properties and methods.\r\n  _.extend(View.prototype, Events, {\r\n\r\n    // The default `tagName` of a View's element is `\"div\"`.\r\n    tagName: 'div',\r\n\r\n    // jQuery delegate for element lookup, scoped to DOM elements within the\r\n    // current view. This should be prefered to global lookups where possible.\r\n    $: function(selector) {\r\n      return this.$el.find(selector);\r\n    },\r\n\r\n    // Initialize is an empty function by default. Override it with your own\r\n    // initialization logic.\r\n    initialize: function(){},\r\n\r\n    // **render** is the core function that your view should override, in order\r\n    // to populate its element (`this.el`), with the appropriate HTML. The\r\n    // convention is for **render** to always return `this`.\r\n    render: function() {\r\n      return this;\r\n    },\r\n\r\n    // Remove this view by taking the element out of the DOM, and removing any\r\n    // applicable Backbone.Events listeners.\r\n    remove: function() {\r\n      this.$el.remove();\r\n      this.stopListening();\r\n      return this;\r\n    },\r\n\r\n    // Change the view's element (`this.el` property), including event\r\n    // re-delegation.\r\n    setElement: function(element, delegate) {\r\n      if (this.$el) this.undelegateEvents();\r\n      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);\r\n      this.el = this.$el[0];\r\n      if (delegate !== false) this.delegateEvents();\r\n      return this;\r\n    },\r\n\r\n    // Set callbacks, where `this.events` is a hash of\r\n    //\r\n    // *{\"event selector\": \"callback\"}*\r\n    //\r\n    //     {\r\n    //       'mousedown .title':  'edit',\r\n    //       'click .button':     'save'\r\n    //       'click .open':       function(e) { ... }\r\n    //     }\r\n    //\r\n    // pairs. Callbacks will be bound to the view, with `this` set properly.\r\n    // Uses event delegation for efficiency.\r\n    // Omitting the selector binds the event to `this.el`.\r\n    // This only works for delegate-able events: not `focus`, `blur`, and\r\n    // not `change`, `submit`, and `reset` in Internet Explorer.\r\n    delegateEvents: function(events) {\r\n      if (!(events || (events = _.result(this, 'events')))) return this;\r\n      this.undelegateEvents();\r\n      for (var key in events) {\r\n        var method = events[key];\r\n        if (!_.isFunction(method)) method = this[events[key]];\r\n        if (!method) continue;\r\n\r\n        var match = key.match(delegateEventSplitter);\r\n        var eventName = match[1], selector = match[2];\r\n        method = _.bind(method, this);\r\n        eventName += '.delegateEvents' + this.cid;\r\n        if (selector === '') {\r\n          this.$el.on(eventName, method);\r\n        } else {\r\n          this.$el.on(eventName, selector, method);\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    // Clears all callbacks previously bound to the view with `delegateEvents`.\r\n    // You usually don't need to use this, but may wish to if you have multiple\r\n    // Backbone views attached to the same DOM element.\r\n    undelegateEvents: function() {\r\n      this.$el.off('.delegateEvents' + this.cid);\r\n      return this;\r\n    },\r\n\r\n    // Performs the initial configuration of a View with a set of options.\r\n    // Keys with special meaning *(e.g. model, collection, id, className)* are\r\n    // attached directly to the view.  See `viewOptions` for an exhaustive\r\n    // list.\r\n    _configure: function(options) {\r\n      if (this.options) options = _.extend({}, _.result(this, 'options'), options);\r\n      _.extend(this, _.pick(options, viewOptions));\r\n      this.options = options;\r\n    },\r\n\r\n    // Ensure that the View has a DOM element to render into.\r\n    // If `this.el` is a string, pass it through `$()`, take the first\r\n    // matching element, and re-assign it to `el`. Otherwise, create\r\n    // an element from the `id`, `className` and `tagName` properties.\r\n    _ensureElement: function() {\r\n      if (!this.el) {\r\n        var attrs = _.extend({}, _.result(this, 'attributes'));\r\n        if (this.id) attrs.id = _.result(this, 'id');\r\n        if (this.className) attrs['class'] = _.result(this, 'className');\r\n        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);\r\n        this.setElement($el, false);\r\n      } else {\r\n        this.setElement(_.result(this, 'el'), false);\r\n      }\r\n    }\r\n\r\n  });\r\n\r\n  // Backbone.sync\r\n  // -------------\r\n\r\n  // Override this function to change the manner in which Backbone persists\r\n  // models to the server. You will be passed the type of request, and the\r\n  // model in question. By default, makes a RESTful Ajax request\r\n  // to the model's `url()`. Some possible customizations could be:\r\n  //\r\n  // * Use `setTimeout` to batch rapid-fire updates into a single request.\r\n  // * Send up the models as XML instead of JSON.\r\n  // * Persist models via WebSockets instead of Ajax.\r\n  //\r\n  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests\r\n  // as `POST`, with a `_method` parameter containing the true HTTP method,\r\n  // as well as all requests with the body as `application/x-www-form-urlencoded`\r\n  // instead of `application/json` with the model in a param named `model`.\r\n  // Useful when interfacing with server-side languages like **PHP** that make\r\n  // it difficult to read the body of `PUT` requests.\r\n  Backbone.sync = function(method, model, options) {\r\n    var type = methodMap[method];\r\n\r\n    // Default options, unless specified.\r\n    _.defaults(options || (options = {}), {\r\n      emulateHTTP: Backbone.emulateHTTP,\r\n      emulateJSON: Backbone.emulateJSON\r\n    });\r\n\r\n    // Default JSON-request options.\r\n    var params = {type: type, dataType: 'json'};\r\n\r\n    // Ensure that we have a URL.\r\n    if (!options.url) {\r\n      params.url = _.result(model, 'url') || urlError();\r\n    }\r\n\r\n    // Ensure that we have the appropriate request data.\r\n    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {\r\n      params.contentType = 'application/json';\r\n      params.data = JSON.stringify(options.attrs || model.toJSON(options));\r\n    }\r\n\r\n    // For older servers, emulate JSON by encoding the request into an HTML-form.\r\n    if (options.emulateJSON) {\r\n      params.contentType = 'application/x-www-form-urlencoded';\r\n      params.data = params.data ? {model: params.data} : {};\r\n    }\r\n\r\n    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`\r\n    // And an `X-HTTP-Method-Override` header.\r\n    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {\r\n      params.type = 'POST';\r\n      if (options.emulateJSON) params.data._method = type;\r\n      var beforeSend = options.beforeSend;\r\n      options.beforeSend = function(xhr) {\r\n        xhr.setRequestHeader('X-HTTP-Method-Override', type);\r\n        if (beforeSend) return beforeSend.apply(this, arguments);\r\n      };\r\n    }\r\n\r\n    // Don't process data on a non-GET request.\r\n    if (params.type !== 'GET' && !options.emulateJSON) {\r\n      params.processData = false;\r\n    }\r\n\r\n    // If we're sending a `PATCH` request, and we're in an old Internet Explorer\r\n    // that still has ActiveX enabled by default, override jQuery to use that\r\n    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.\r\n    if (params.type === 'PATCH' && window.ActiveXObject &&\r\n          !(window.external && window.external.msActiveXFilteringEnabled)) {\r\n      params.xhr = function() {\r\n        return new ActiveXObject(\"Microsoft.XMLHTTP\");\r\n      };\r\n    }\r\n\r\n    // Make the request, allowing the user to override any Ajax options.\r\n    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));\r\n    model.trigger('request', model, xhr, options);\r\n    return xhr;\r\n  };\r\n\r\n  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.\r\n  var methodMap = {\r\n    'create': 'POST',\r\n    'update': 'PUT',\r\n    'patch':  'PATCH',\r\n    'delete': 'DELETE',\r\n    'read':   'GET'\r\n  };\r\n\r\n  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.\r\n  // Override this if you'd like to use a different library.\r\n  Backbone.ajax = function() {\r\n    return Backbone.$.ajax.apply(Backbone.$, arguments);\r\n  };\r\n\r\n  // Backbone.Router\r\n  // ---------------\r\n\r\n  // Routers map faux-URLs to actions, and fire events when routes are\r\n  // matched. Creating a new one sets its `routes` hash, if not set statically.\r\n  var Router = Backbone.Router = function(options) {\r\n    options || (options = {});\r\n    if (options.routes) this.routes = options.routes;\r\n    this._bindRoutes();\r\n    this.initialize.apply(this, arguments);\r\n  };\r\n\r\n  // Cached regular expressions for matching named param parts and splatted\r\n  // parts of route strings.\r\n  var optionalParam = /\\((.*?)\\)/g;\r\n  var namedParam    = /(\\(\\?)?:\\w+/g;\r\n  var splatParam    = /\\*\\w+/g;\r\n  var escapeRegExp  = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\r\n\r\n  // Set up all inheritable **Backbone.Router** properties and methods.\r\n  _.extend(Router.prototype, Events, {\r\n\r\n    // Initialize is an empty function by default. Override it with your own\r\n    // initialization logic.\r\n    initialize: function(){},\r\n\r\n    // Manually bind a single named route to a callback. For example:\r\n    //\r\n    //     this.route('search/:query/p:num', 'search', function(query, num) {\r\n    //       ...\r\n    //     });\r\n    //\r\n    route: function(route, name, callback) {\r\n      if (!_.isRegExp(route)) route = this._routeToRegExp(route);\r\n      if (_.isFunction(name)) {\r\n        callback = name;\r\n        name = '';\r\n      }\r\n      if (!callback) callback = this[name];\r\n      var router = this;\r\n      Backbone.history.route(route, function(fragment) {\r\n        var args = router._extractParameters(route, fragment);\r\n        callback && callback.apply(router, args);\r\n        router.trigger.apply(router, ['route:' + name].concat(args));\r\n        router.trigger('route', name, args);\r\n        Backbone.history.trigger('route', router, name, args);\r\n      });\r\n      return this;\r\n    },\r\n\r\n    // Simple proxy to `Backbone.history` to save a fragment into the history.\r\n    navigate: function(fragment, options) {\r\n      Backbone.history.navigate(fragment, options);\r\n      return this;\r\n    },\r\n\r\n    // Bind all defined routes to `Backbone.history`. We have to reverse the\r\n    // order of the routes here to support behavior where the most general\r\n    // routes can be defined at the bottom of the route map.\r\n    _bindRoutes: function() {\r\n      if (!this.routes) return;\r\n      this.routes = _.result(this, 'routes');\r\n      var route, routes = _.keys(this.routes);\r\n      while ((route = routes.pop()) != null) {\r\n        this.route(route, this.routes[route]);\r\n      }\r\n    },\r\n\r\n    // Convert a route string into a regular expression, suitable for matching\r\n    // against the current location hash.\r\n    _routeToRegExp: function(route) {\r\n      route = route.replace(escapeRegExp, '\\\\$&')\r\n                   .replace(optionalParam, '(?:$1)?')\r\n                   .replace(namedParam, function(match, optional){\r\n                     return optional ? match : '([^\\/]+)';\r\n                   })\r\n                   .replace(splatParam, '(.*?)');\r\n      return new RegExp('^' + route + '$');\r\n    },\r\n\r\n    // Given a route, and a URL fragment that it matches, return the array of\r\n    // extracted decoded parameters. Empty or unmatched parameters will be\r\n    // treated as `null` to normalize cross-browser behavior.\r\n    _extractParameters: function(route, fragment) {\r\n      var params = route.exec(fragment).slice(1);\r\n      return _.map(params, function(param) {\r\n        return param ? decodeURIComponent(param) : null;\r\n      });\r\n    }\r\n\r\n  });\r\n\r\n  // Backbone.History\r\n  // ----------------\r\n\r\n  // Handles cross-browser history management, based on either\r\n  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or\r\n  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\r\n  // and URL fragments. If the browser supports neither (old IE, natch),\r\n  // falls back to polling.\r\n  var History = Backbone.History = function() {\r\n    this.handlers = [];\r\n    _.bindAll(this, 'checkUrl');\r\n\r\n    // Ensure that `History` can be used outside of the browser.\r\n    if (typeof window !== 'undefined') {\r\n      this.location = window.location;\r\n      this.history = window.history;\r\n    }\r\n  };\r\n\r\n  // Cached regex for stripping a leading hash/slash and trailing space.\r\n  var routeStripper = /^[#\\/]|\\s+$/g;\r\n\r\n  // Cached regex for stripping leading and trailing slashes.\r\n  var rootStripper = /^\\/+|\\/+$/g;\r\n\r\n  // Cached regex for detecting MSIE.\r\n  var isExplorer = /msie [\\w.]+/;\r\n\r\n  // Cached regex for removing a trailing slash.\r\n  var trailingSlash = /\\/$/;\r\n\r\n  // Has the history handling already been started?\r\n  History.started = false;\r\n\r\n  // Set up all inheritable **Backbone.History** properties and methods.\r\n  _.extend(History.prototype, Events, {\r\n\r\n    // The default interval to poll for hash changes, if necessary, is\r\n    // twenty times a second.\r\n    interval: 50,\r\n\r\n    // Gets the true hash value. Cannot use location.hash directly due to bug\r\n    // in Firefox where location.hash will always be decoded.\r\n    getHash: function(window) {\r\n      var match = (window || this).location.href.match(/#(.*)$/);\r\n      return match ? match[1] : '';\r\n    },\r\n\r\n    // Get the cross-browser normalized URL fragment, either from the URL,\r\n    // the hash, or the override.\r\n    getFragment: function(fragment, forcePushState) {\r\n      if (fragment == null) {\r\n        if (this._hasPushState || !this._wantsHashChange || forcePushState) {\r\n          fragment = this.location.pathname;\r\n          var root = this.root.replace(trailingSlash, '');\r\n          if (!fragment.indexOf(root)) fragment = fragment.substr(root.length);\r\n        } else {\r\n          fragment = this.getHash();\r\n        }\r\n      }\r\n      return fragment.replace(routeStripper, '');\r\n    },\r\n\r\n    // Start the hash change handling, returning `true` if the current URL matches\r\n    // an existing route, and `false` otherwise.\r\n    start: function(options) {\r\n      if (History.started) throw new Error(\"Backbone.history has already been started\");\r\n      History.started = true;\r\n\r\n      // Figure out the initial configuration. Do we need an iframe?\r\n      // Is pushState desired ... is it available?\r\n      this.options          = _.extend({}, {root: '/'}, this.options, options);\r\n      this.root             = this.options.root;\r\n      this._wantsHashChange = this.options.hashChange !== false;\r\n      this._wantsPushState  = !!this.options.pushState;\r\n      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);\r\n      var fragment          = this.getFragment();\r\n      var docMode           = document.documentMode;\r\n      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));\r\n\r\n      // Normalize root to always include a leading and trailing slash.\r\n      this.root = ('/' + this.root + '/').replace(rootStripper, '/');\r\n\r\n      if (oldIE && this._wantsHashChange) {\r\n        this.iframe = Backbone.$('<iframe src=\"javascript:0\" tabindex=\"-1\" />').hide().appendTo('body')[0].contentWindow;\r\n        this.navigate(fragment);\r\n      }\r\n\r\n      // Depending on whether we're using pushState or hashes, and whether\r\n      // 'onhashchange' is supported, determine how we check the URL state.\r\n      if (this._hasPushState) {\r\n        Backbone.$(window).on('popstate', this.checkUrl);\r\n      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {\r\n        Backbone.$(window).on('hashchange', this.checkUrl);\r\n      } else if (this._wantsHashChange) {\r\n        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\r\n      }\r\n\r\n      // Determine if we need to change the base url, for a pushState link\r\n      // opened by a non-pushState browser.\r\n      this.fragment = fragment;\r\n      var loc = this.location;\r\n      var atRoot = loc.pathname.replace(/[^\\/]$/, '$&/') === this.root;\r\n\r\n      // If we've started off with a route from a `pushState`-enabled browser,\r\n      // but we're currently in a browser that doesn't support it...\r\n      if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {\r\n        this.fragment = this.getFragment(null, true);\r\n        this.location.replace(this.root + this.location.search + '#' + this.fragment);\r\n        // Return immediately as browser will do redirect to new url\r\n        return true;\r\n\r\n      // Or if we've started out with a hash-based route, but we're currently\r\n      // in a browser where it could be `pushState`-based instead...\r\n      } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {\r\n        this.fragment = this.getHash().replace(routeStripper, '');\r\n        this.history.replaceState({}, document.title, this.root + this.fragment + loc.search);\r\n      }\r\n\r\n      if (!this.options.silent) return this.loadUrl();\r\n    },\r\n\r\n    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,\r\n    // but possibly useful for unit testing Routers.\r\n    stop: function() {\r\n      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);\r\n      clearInterval(this._checkUrlInterval);\r\n      History.started = false;\r\n    },\r\n\r\n    // Add a route to be tested when the fragment changes. Routes added later\r\n    // may override previous routes.\r\n    route: function(route, callback) {\r\n      this.handlers.unshift({route: route, callback: callback});\r\n    },\r\n\r\n    // Checks the current URL to see if it has changed, and if it has,\r\n    // calls `loadUrl`, normalizing across the hidden iframe.\r\n    checkUrl: function(e) {\r\n      var current = this.getFragment();\r\n      if (current === this.fragment && this.iframe) {\r\n        current = this.getFragment(this.getHash(this.iframe));\r\n      }\r\n      if (current === this.fragment) return false;\r\n      if (this.iframe) this.navigate(current);\r\n      this.loadUrl() || this.loadUrl(this.getHash());\r\n    },\r\n\r\n    // Attempt to load the current URL fragment. If a route succeeds with a\r\n    // match, returns `true`. If no defined routes matches the fragment,\r\n    // returns `false`.\r\n    loadUrl: function(fragmentOverride) {\r\n      var fragment = this.fragment = this.getFragment(fragmentOverride);\r\n      var matched = _.any(this.handlers, function(handler) {\r\n        if (handler.route.test(fragment)) {\r\n          handler.callback(fragment);\r\n          return true;\r\n        }\r\n      });\r\n      return matched;\r\n    },\r\n\r\n    // Save a fragment into the hash history, or replace the URL state if the\r\n    // 'replace' option is passed. You are responsible for properly URL-encoding\r\n    // the fragment in advance.\r\n    //\r\n    // The options object can contain `trigger: true` if you wish to have the\r\n    // route callback be fired (not usually desirable), or `replace: true`, if\r\n    // you wish to modify the current URL without adding an entry to the history.\r\n    navigate: function(fragment, options) {\r\n      if (!History.started) return false;\r\n      if (!options || options === true) options = {trigger: options};\r\n      fragment = this.getFragment(fragment || '');\r\n      if (this.fragment === fragment) return;\r\n      this.fragment = fragment;\r\n      var url = this.root + fragment;\r\n\r\n      // If pushState is available, we use it to set the fragment as a real URL.\r\n      if (this._hasPushState) {\r\n        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\r\n\r\n      // If hash changes haven't been explicitly disabled, update the hash\r\n      // fragment to store history.\r\n      } else if (this._wantsHashChange) {\r\n        this._updateHash(this.location, fragment, options.replace);\r\n        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {\r\n          // Opening and closing the iframe tricks IE7 and earlier to push a\r\n          // history entry on hash-tag change.  When replace is true, we don't\r\n          // want this.\r\n          if(!options.replace) this.iframe.document.open().close();\r\n          this._updateHash(this.iframe.location, fragment, options.replace);\r\n        }\r\n\r\n      // If you've told us that you explicitly don't want fallback hashchange-\r\n      // based history, then `navigate` becomes a page refresh.\r\n      } else {\r\n        return this.location.assign(url);\r\n      }\r\n      if (options.trigger) this.loadUrl(fragment);\r\n    },\r\n\r\n    // Update the hash location, either replacing the current entry, or adding\r\n    // a new one to the browser history.\r\n    _updateHash: function(location, fragment, replace) {\r\n      if (replace) {\r\n        var href = location.href.replace(/(javascript:|#).*$/, '');\r\n        location.replace(href + '#' + fragment);\r\n      } else {\r\n        // Some browsers require that `hash` contains a leading #.\r\n        location.hash = '#' + fragment;\r\n      }\r\n    }\r\n\r\n  });\r\n\r\n  // Create the default Backbone.history.\r\n  Backbone.history = new History;\r\n\r\n  // Helpers\r\n  // -------\r\n\r\n  // Helper function to correctly set up the prototype chain, for subclasses.\r\n  // Similar to `goog.inherits`, but uses a hash of prototype properties and\r\n  // class properties to be extended.\r\n  var extend = function(protoProps, staticProps) {\r\n    var parent = this;\r\n    var child;\r\n\r\n    // The constructor function for the new subclass is either defined by you\r\n    // (the \"constructor\" property in your `extend` definition), or defaulted\r\n    // by us to simply call the parent's constructor.\r\n    if (protoProps && _.has(protoProps, 'constructor')) {\r\n      child = protoProps.constructor;\r\n    } else {\r\n      child = function(){ return parent.apply(this, arguments); };\r\n    }\r\n\r\n    // Add static properties to the constructor function, if supplied.\r\n    _.extend(child, parent, staticProps);\r\n\r\n    // Set the prototype chain to inherit from `parent`, without calling\r\n    // `parent`'s constructor function.\r\n    var Surrogate = function(){ this.constructor = child; };\r\n    Surrogate.prototype = parent.prototype;\r\n    child.prototype = new Surrogate;\r\n\r\n    // Add prototype properties (instance properties) to the subclass,\r\n    // if supplied.\r\n    if (protoProps) _.extend(child.prototype, protoProps);\r\n\r\n    // Set a convenience property in case the parent's prototype is needed\r\n    // later.\r\n    child.__super__ = parent.prototype;\r\n\r\n    return child;\r\n  };\r\n\r\n  // Set up inheritance for the model, collection, router, view and history.\r\n  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;\r\n\r\n  // Throw an error when a URL is needed, and none is supplied.\r\n  var urlError = function() {\r\n    throw new Error('A \"url\" property or function must be specified');\r\n  };\r\n\r\n  // Wrap an optional error callback with a fallback error event.\r\n  var wrapError = function (model, options) {\r\n    var error = options.error;\r\n    options.error = function(resp) {\r\n      if (error) error(model, resp, options);\r\n      model.trigger('error', model, resp, options);\r\n    };\r\n  };\r\n\r\n}).call(this);\ndefine(\"backbone\", [\"underscore\",\"jquery\"], (function (global) {\n    return function () {\n        var ret, fn;\n        return ret || global.Backbone;\n    };\n}(this)));\n",
    "\n// Backbone adaptor plugin\r\n// =======================\r\n//\r\n// Usage: Include this file below Ractive.js on your page, then tell Ractive to\r\n// expect Backbone objects by adding an `adaptors` property:\r\n//\r\n//     var ractive = new Ractive({\r\n//       el: myContainer,\r\n//       template: myTemplate,\r\n//       data: { foo: myBackboneModel, bar: myBackboneCollection },\r\n//       adaptors: [ 'Backbone' ]\r\n//     });\r\n//\r\n// A gotcha: if you're using a module loader, the code below will\r\n// need to execute in a scope that includes Ractive and Backbone!\r\n\r\ndefine('backboneAdaptor',['backbone', 'Ractive'], function(Backbone, Ractive) {\r\n\tRactive.adaptors.Backbone = {\r\n\t\tfilter: function ( object ) {\r\n\t\t\treturn object instanceof Backbone.Model || object instanceof Backbone.Collection;\r\n\t\t},\r\n\t\twrap: function ( ractive, object, keypath, prefix ) {\r\n\t\t\tif ( object instanceof Backbone.Model ) {\r\n\t\t\t\treturn new BackboneModelWrapper( ractive, object, keypath, prefix );\r\n\t\t\t}\r\n\r\n\t\t\treturn new BackboneCollectionWrapper( ractive, object, keypath, prefix );\r\n\t\t}\r\n\t};\r\n\r\n\tBackboneModelWrapper = function ( ractive, model, keypath, prefix ) {\r\n\t\tvar wrapper = this;\r\n\r\n\t\tthis.value = model;\r\n\r\n\t\tmodel.on( 'change', this.modelChangeHandler = function () {\r\n\t\t\twrapper.setting = true;\r\n\t\t\tractive.set( prefix( model.changed ) );\r\n\t\t\twrapper.setting = false;\r\n\t\t});\r\n\t};\r\n\r\n\tBackboneModelWrapper.prototype = {\r\n\t\tteardown: function () {\r\n\t\t\tthis.value.off( 'change', this.changeHandler );\r\n\t\t},\r\n\t\tget: function () {\r\n\t\t\treturn this.value.attributes;\r\n\t\t},\r\n\t\tset: function ( keypath, value ) {\r\n\t\t\t// Only set if the model didn't originate the change itself, and\r\n\t\t\t// only if it's an immediate child property\r\n\t\t\tif ( !this.setting && keypath.indexOf( '.' ) === -1 ) {\r\n\t\t\t\tthis.value.set( keypath, value );\t\r\n\t\t\t}\r\n\t\t},\r\n\t\treset: function ( object ) {\r\n\t\t\t// If the new object is a Backbone model, assume this one is\r\n\t\t\t// being retired. Ditto if it's not a model at all\r\n\t\t\tif ( object instanceof Backbone.Model || typeof object !== 'object' ) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// Otherwise if this is a POJO, reset the model\r\n\t\t\tthis.value.reset( object );\r\n\t\t}\r\n\t};\r\n\r\n\tBackboneCollectionWrapper = function ( ractive, collection, keypath, prefix ) {\r\n\t\tvar wrapper = this;\r\n\r\n\t\tthis.value = collection;\r\n\r\n\t\tcollection.on( 'add remove reset sort', this.changeHandler = function () {\r\n\t\t\t// TODO smart merge. It should be possible, if awkward, to trigger smart\r\n\t\t\t// updates instead of a blunderbuss .set() approach\r\n\t\t\twrapper.setting = true;\r\n\t\t\tractive.set( keypath, collection.models );\r\n\t\t\twrapper.setting = false;\r\n\t\t});\r\n\t};\r\n\r\n\tBackboneCollectionWrapper.prototype = {\r\n\t\tteardown: function () {\r\n\t\t\tthis.value.off( 'add remove reset sort', this.changeHandler );\r\n\t\t},\r\n\t\tget: function () {\r\n\t\t\treturn this.value.models;\r\n\t\t},\r\n\t\treset: function ( models ) {\r\n\t\t\tif ( this.setting ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// If the new object is a Backbone collection, assume this one is\r\n\t\t\t// being retired. Ditto if it's not a collection at all\r\n\t\t\tif ( models instanceof Backbone.Collection || Object.prototype.toString.call( models ) !== '[object Array]' ) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// Otherwise if this is a plain array, reset the collection\r\n\t\t\tthis.value.reset( models );\r\n\t\t}\r\n\t};\r\n});",
    "\ndefine('models/movie',['backbone'], function(Backbone) {\r\n\treturn Backbone.Model.extend({\r\n\t\turl: '/movies',\r\n\t\tvisible: false\r\n\t});\r\n});",
    "\ndefine(\r\n\t'collections/movieCollection',['backbone', 'models/movie'], \r\n\tfunction(Backbone, MovieModel) {\r\n\t\treturn Backbone.Collection.extend({\r\n\t\t\tmodel: MovieModel\r\n\t\t});\r\n\t}\r\n);",
    "\ndefine('mock/movieData',[],function() {\r\n\treturn [\r\n\t\t{\r\n\t\t\tid: 1,\r\n\t\t\ttitle: 'Batman',\r\n\t\t\tdescription: 'Batmovie movie',\r\n\t\t\tfollowing: true,\r\n\t\t\tposter: '',\r\n\t\t\tbanner: ''\r\n\t\t},\r\n\t\t{\r\n\t\t\tid: 2,\r\n\t\t\ttitle: 'Batman 2',\r\n\t\t\tdescription: 'Batmovie movie',\r\n\t\t\tfollowing: false,\r\n\t\t\tposter: '',\r\n\t\t\tbanner: ''\r\n\t\t},\r\n\t\t{\r\n\t\t\tid: 3,\r\n\t\t\ttitle: 'Batman 3',\r\n\t\t\tdescription: 'Batmovie movie',\r\n\t\t\tfollowing: false,\r\n\t\t\tposter: '',\r\n\t\t\tbanner: ''\r\n\t\t},\r\n\t\t{\r\n\t\t\tid: 4,\r\n\t\t\ttitle: 'Batman 3',\r\n\t\t\tdescription: 'Batmovie movie',\r\n\t\t\tfollowing: false,\r\n\t\t\tposter: '',\r\n\t\t\tbanner: ''\r\n\t\t},\r\n\t\t{\r\n\t\t\tid: 5,\r\n\t\t\ttitle: 'Batman 3',\r\n\t\t\tdescription: 'Batmovie movie',\r\n\t\t\tfollowing: false,\r\n\t\t\tposter: '',\r\n\t\t\tbanner: ''\r\n\t\t}\r\n\t];\r\n});",
    "\n/**\r\n * @license RequireJS text 2.0.10 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.\r\n * Available via the MIT or new BSD license.\r\n * see: http://github.com/requirejs/text for details\r\n */\r\n/*jslint regexp: true */\r\n/*global require, XMLHttpRequest, ActiveXObject,\r\n  define, window, process, Packages,\r\n  java, location, Components, FileUtils */\r\n\r\ndefine('text',['module'], function (module) {\r\n    'use strict';\r\n\r\n    var text, fs, Cc, Ci, xpcIsWindows,\r\n        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],\r\n        xmlRegExp = /^\\s*<\\?xml(\\s)+version=[\\'\\\"](\\d)*.(\\d)*[\\'\\\"](\\s)*\\?>/im,\r\n        bodyRegExp = /<body[^>]*>\\s*([\\s\\S]+)\\s*<\\/body>/im,\r\n        hasLocation = typeof location !== 'undefined' && location.href,\r\n        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\\:/, ''),\r\n        defaultHostName = hasLocation && location.hostname,\r\n        defaultPort = hasLocation && (location.port || undefined),\r\n        buildMap = {},\r\n        masterConfig = (module.config && module.config()) || {};\r\n\r\n    text = {\r\n        version: '2.0.10',\r\n\r\n        strip: function (content) {\r\n            //Strips <?xml ...?> declarations so that external SVG and XML\r\n            //documents can be added to a document without worry. Also, if the string\r\n            //is an HTML document, only the part inside the body tag is returned.\r\n            if (content) {\r\n                content = content.replace(xmlRegExp, \"\");\r\n                var matches = content.match(bodyRegExp);\r\n                if (matches) {\r\n                    content = matches[1];\r\n                }\r\n            } else {\r\n                content = \"\";\r\n            }\r\n            return content;\r\n        },\r\n\r\n        jsEscape: function (content) {\r\n            return content.replace(/(['\\\\])/g, '\\\\$1')\r\n                .replace(/[\\f]/g, \"\\\\f\")\r\n                .replace(/[\\b]/g, \"\\\\b\")\r\n                .replace(/[\\n]/g, \"\\\\n\")\r\n                .replace(/[\\t]/g, \"\\\\t\")\r\n                .replace(/[\\r]/g, \"\\\\r\")\r\n                .replace(/[\\u2028]/g, \"\\\\u2028\")\r\n                .replace(/[\\u2029]/g, \"\\\\u2029\");\r\n        },\r\n\r\n        createXhr: masterConfig.createXhr || function () {\r\n            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.\r\n            var xhr, i, progId;\r\n            if (typeof XMLHttpRequest !== \"undefined\") {\r\n                return new XMLHttpRequest();\r\n            } else if (typeof ActiveXObject !== \"undefined\") {\r\n                for (i = 0; i < 3; i += 1) {\r\n                    progId = progIds[i];\r\n                    try {\r\n                        xhr = new ActiveXObject(progId);\r\n                    } catch (e) {}\r\n\r\n                    if (xhr) {\r\n                        progIds = [progId];  // so faster next time\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return xhr;\r\n        },\r\n\r\n        /**\r\n         * Parses a resource name into its component parts. Resource names\r\n         * look like: module/name.ext!strip, where the !strip part is\r\n         * optional.\r\n         * @param {String} name the resource name\r\n         * @returns {Object} with properties \"moduleName\", \"ext\" and \"strip\"\r\n         * where strip is a boolean.\r\n         */\r\n        parseName: function (name) {\r\n            var modName, ext, temp,\r\n                strip = false,\r\n                index = name.indexOf(\".\"),\r\n                isRelative = name.indexOf('./') === 0 ||\r\n                             name.indexOf('../') === 0;\r\n\r\n            if (index !== -1 && (!isRelative || index > 1)) {\r\n                modName = name.substring(0, index);\r\n                ext = name.substring(index + 1, name.length);\r\n            } else {\r\n                modName = name;\r\n            }\r\n\r\n            temp = ext || modName;\r\n            index = temp.indexOf(\"!\");\r\n            if (index !== -1) {\r\n                //Pull off the strip arg.\r\n                strip = temp.substring(index + 1) === \"strip\";\r\n                temp = temp.substring(0, index);\r\n                if (ext) {\r\n                    ext = temp;\r\n                } else {\r\n                    modName = temp;\r\n                }\r\n            }\r\n\r\n            return {\r\n                moduleName: modName,\r\n                ext: ext,\r\n                strip: strip\r\n            };\r\n        },\r\n\r\n        xdRegExp: /^((\\w+)\\:)?\\/\\/([^\\/\\\\]+)/,\r\n\r\n        /**\r\n         * Is an URL on another domain. Only works for browser use, returns\r\n         * false in non-browser environments. Only used to know if an\r\n         * optimized .js version of a text resource should be loaded\r\n         * instead.\r\n         * @param {String} url\r\n         * @returns Boolean\r\n         */\r\n        useXhr: function (url, protocol, hostname, port) {\r\n            var uProtocol, uHostName, uPort,\r\n                match = text.xdRegExp.exec(url);\r\n            if (!match) {\r\n                return true;\r\n            }\r\n            uProtocol = match[2];\r\n            uHostName = match[3];\r\n\r\n            uHostName = uHostName.split(':');\r\n            uPort = uHostName[1];\r\n            uHostName = uHostName[0];\r\n\r\n            return (!uProtocol || uProtocol === protocol) &&\r\n                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&\r\n                   ((!uPort && !uHostName) || uPort === port);\r\n        },\r\n\r\n        finishLoad: function (name, strip, content, onLoad) {\r\n            content = strip ? text.strip(content) : content;\r\n            if (masterConfig.isBuild) {\r\n                buildMap[name] = content;\r\n            }\r\n            onLoad(content);\r\n        },\r\n\r\n        load: function (name, req, onLoad, config) {\r\n            //Name has format: some.module.filext!strip\r\n            //The strip part is optional.\r\n            //if strip is present, then that means only get the string contents\r\n            //inside a body tag in an HTML string. For XML/SVG content it means\r\n            //removing the <?xml ...?> declarations so the content can be inserted\r\n            //into the current doc without problems.\r\n\r\n            // Do not bother with the work if a build and text will\r\n            // not be inlined.\r\n            if (config.isBuild && !config.inlineText) {\r\n                onLoad();\r\n                return;\r\n            }\r\n\r\n            masterConfig.isBuild = config.isBuild;\r\n\r\n            var parsed = text.parseName(name),\r\n                nonStripName = parsed.moduleName +\r\n                    (parsed.ext ? '.' + parsed.ext : ''),\r\n                url = req.toUrl(nonStripName),\r\n                useXhr = (masterConfig.useXhr) ||\r\n                         text.useXhr;\r\n\r\n            // Do not load if it is an empty: url\r\n            if (url.indexOf('empty:') === 0) {\r\n                onLoad();\r\n                return;\r\n            }\r\n\r\n            //Load the text. Use XHR if possible and in a browser.\r\n            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {\r\n                text.get(url, function (content) {\r\n                    text.finishLoad(name, parsed.strip, content, onLoad);\r\n                }, function (err) {\r\n                    if (onLoad.error) {\r\n                        onLoad.error(err);\r\n                    }\r\n                });\r\n            } else {\r\n                //Need to fetch the resource across domains. Assume\r\n                //the resource has been optimized into a JS module. Fetch\r\n                //by the module name + extension, but do not include the\r\n                //!strip part to avoid file system issues.\r\n                req([nonStripName], function (content) {\r\n                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,\r\n                                    parsed.strip, content, onLoad);\r\n                });\r\n            }\r\n        },\r\n\r\n        write: function (pluginName, moduleName, write, config) {\r\n            if (buildMap.hasOwnProperty(moduleName)) {\r\n                var content = text.jsEscape(buildMap[moduleName]);\r\n                write.asModule(pluginName + \"!\" + moduleName,\r\n                               \"define(function () { return '\" +\r\n                                   content +\r\n                               \"';});\\n\");\r\n            }\r\n        },\r\n\r\n        writeFile: function (pluginName, moduleName, req, write, config) {\r\n            var parsed = text.parseName(moduleName),\r\n                extPart = parsed.ext ? '.' + parsed.ext : '',\r\n                nonStripName = parsed.moduleName + extPart,\r\n                //Use a '.js' file name so that it indicates it is a\r\n                //script that can be loaded across domains.\r\n                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';\r\n\r\n            //Leverage own load() method to load plugin value, but only\r\n            //write out values that do not have the strip argument,\r\n            //to avoid any potential issues with ! in file names.\r\n            text.load(nonStripName, req, function (value) {\r\n                //Use own write() method to construct full module value.\r\n                //But need to create shell that translates writeFile's\r\n                //write() to the right interface.\r\n                var textWrite = function (contents) {\r\n                    return write(fileName, contents);\r\n                };\r\n                textWrite.asModule = function (moduleName, contents) {\r\n                    return write.asModule(moduleName, fileName, contents);\r\n                };\r\n\r\n                text.write(pluginName, nonStripName, textWrite, config);\r\n            }, config);\r\n        }\r\n    };\r\n\r\n    if (masterConfig.env === 'node' || (!masterConfig.env &&\r\n            typeof process !== \"undefined\" &&\r\n            process.versions &&\r\n            !!process.versions.node &&\r\n            !process.versions['node-webkit'])) {\r\n        //Using special require.nodeRequire, something added by r.js.\r\n        fs = require.nodeRequire('fs');\r\n\r\n        text.get = function (url, callback, errback) {\r\n            try {\r\n                var file = fs.readFileSync(url, 'utf8');\r\n                //Remove BOM (Byte Mark Order) from utf8 files if it is there.\r\n                if (file.indexOf('\\uFEFF') === 0) {\r\n                    file = file.substring(1);\r\n                }\r\n                callback(file);\r\n            } catch (e) {\r\n                errback(e);\r\n            }\r\n        };\r\n    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&\r\n            text.createXhr())) {\r\n        text.get = function (url, callback, errback, headers) {\r\n            var xhr = text.createXhr(), header;\r\n            xhr.open('GET', url, true);\r\n\r\n            //Allow plugins direct access to xhr headers\r\n            if (headers) {\r\n                for (header in headers) {\r\n                    if (headers.hasOwnProperty(header)) {\r\n                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            //Allow overrides specified in config\r\n            if (masterConfig.onXhr) {\r\n                masterConfig.onXhr(xhr, url);\r\n            }\r\n\r\n            xhr.onreadystatechange = function (evt) {\r\n                var status, err;\r\n                //Do not explicitly handle errors, those should be\r\n                //visible via console output in the browser.\r\n                if (xhr.readyState === 4) {\r\n                    status = xhr.status;\r\n                    if (status > 399 && status < 600) {\r\n                        //An http 4xx or 5xx error. Signal an error.\r\n                        err = new Error(url + ' HTTP status: ' + status);\r\n                        err.xhr = xhr;\r\n                        errback(err);\r\n                    } else {\r\n                        callback(xhr.responseText);\r\n                    }\r\n\r\n                    if (masterConfig.onXhrComplete) {\r\n                        masterConfig.onXhrComplete(xhr, url);\r\n                    }\r\n                }\r\n            };\r\n            xhr.send(null);\r\n        };\r\n    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&\r\n            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {\r\n        //Why Java, why is this so awkward?\r\n        text.get = function (url, callback) {\r\n            var stringBuffer, line,\r\n                encoding = \"utf-8\",\r\n                file = new java.io.File(url),\r\n                lineSeparator = java.lang.System.getProperty(\"line.separator\"),\r\n                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),\r\n                content = '';\r\n            try {\r\n                stringBuffer = new java.lang.StringBuffer();\r\n                line = input.readLine();\r\n\r\n                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324\r\n                // http://www.unicode.org/faq/utf_bom.html\r\n\r\n                // Note that when we use utf-8, the BOM should appear as \"EF BB BF\", but it doesn't due to this bug in the JDK:\r\n                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058\r\n                if (line && line.length() && line.charAt(0) === 0xfeff) {\r\n                    // Eat the BOM, since we've already found the encoding on this file,\r\n                    // and we plan to concatenating this buffer with others; the BOM should\r\n                    // only appear at the top of a file.\r\n                    line = line.substring(1);\r\n                }\r\n\r\n                if (line !== null) {\r\n                    stringBuffer.append(line);\r\n                }\r\n\r\n                while ((line = input.readLine()) !== null) {\r\n                    stringBuffer.append(lineSeparator);\r\n                    stringBuffer.append(line);\r\n                }\r\n                //Make sure we return a JavaScript string and not a Java string.\r\n                content = String(stringBuffer.toString()); //String\r\n            } finally {\r\n                input.close();\r\n            }\r\n            callback(content);\r\n        };\r\n    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&\r\n            typeof Components !== 'undefined' && Components.classes &&\r\n            Components.interfaces)) {\r\n        //Avert your gaze!\r\n        Cc = Components.classes,\r\n        Ci = Components.interfaces;\r\n        Components.utils['import']('resource://gre/modules/FileUtils.jsm');\r\n        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);\r\n\r\n        text.get = function (url, callback) {\r\n            var inStream, convertStream, fileObj,\r\n                readData = {};\r\n\r\n            if (xpcIsWindows) {\r\n                url = url.replace(/\\//g, '\\\\');\r\n            }\r\n\r\n            fileObj = new FileUtils.File(url);\r\n\r\n            //XPCOM, you so crazy\r\n            try {\r\n                inStream = Cc['@mozilla.org/network/file-input-stream;1']\r\n                           .createInstance(Ci.nsIFileInputStream);\r\n                inStream.init(fileObj, 1, 0, false);\r\n\r\n                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']\r\n                                .createInstance(Ci.nsIConverterInputStream);\r\n                convertStream.init(inStream, \"utf-8\", inStream.available(),\r\n                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);\r\n\r\n                convertStream.readString(inStream.available(), readData);\r\n                convertStream.close();\r\n                inStream.close();\r\n                callback(readData.value);\r\n            } catch (e) {\r\n                throw new Error((fileObj && fileObj.path || '') + ': ' + e);\r\n            }\r\n        };\r\n    }\r\n    return text;\r\n});",
    "\n/*global define, XMLHttpRequest */\r\n\r\ndefine( 'rv',[ 'text', 'Ractive' ], function ( text, Ractive ) {\r\n\r\n\t'use strict';\r\n\r\n\tvar buildMap = {};\r\n\r\n\treturn {\r\n\t\tload: function ( name, req, onload, config ) {\r\n\t\t\tvar filename;\r\n\r\n\t\t\t// add .html extension\r\n\t\t\tfilename = name + ( ( name.substr( -5 ) !== '.html' ) ? '.html' : '' );\r\n\r\n\t\t\ttext.get( req.toUrl( filename ), function ( template ) {\r\n\t\t\t\tvar result = Ractive.parse( template );\r\n\r\n\t\t\t\tif ( config.isBuild ) {\r\n\t\t\t\t\tbuildMap[ name ] = result;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tonload( result );\r\n\t\t\t}, onload.error );\r\n\t\t},\r\n\r\n\t\twrite: function ( pluginName, name, write ) {\r\n\t\t\tif ( buildMap[ name ] === undefined ) {\r\n\t\t\t\tthrow 'Could not parse template ' + name;\r\n\t\t\t}\r\n\r\n\t\t\twrite( 'define(\"' + pluginName + '!' + name + '\",function(){return ' + JSON.stringify( buildMap[ name ] ) + ';})' );\r\n\t\t}\r\n\t};\r\n\r\n});",
    "\ndefine(\"rv!templates/movies\",function(){return [{\"t\":4,\"r\":\"visible\",\"f\":[\" \",{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"movies\"},\"f\":[{\"t\":7,\"e\":\"h2\",\"f\":\"Movies\"},\" \",{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"row\"},\"f\":[{\"t\":4,\"r\":\"movies\",\"f\":[\" \",{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"col-sm-6 col-md-3\"},\"f\":[{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"thumbnail\"},\"f\":[{\"t\":7,\"e\":\"img\",\"a\":{\"data-src\":\"holder.js/300x200/auto\",\"alt\":[{\"t\":2,\"r\":\"title\"}]}},\" \",{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"caption\"},\"f\":[{\"t\":7,\"e\":\"h3\",\"f\":[{\"t\":2,\"r\":\"title\"}]},\" \",{\"t\":7,\"e\":\"p\",\"f\":[{\"t\":2,\"r\":\"description\"}]},\" \",{\"t\":4,\"r\":\"following\",\"f\":[\" \",{\"t\":7,\"e\":\"button\",\"a\":{\"class\":\"btn btn-danger btn-block\"},\"f\":\"<i class=\\\"glyphicon glyphicon-ok\\\"></i> Fjern\",\"v\":{\"tap\":{\"n\":\"toggle\",\"d\":[{\"t\":2,\"r\":\"id\"}]}}},\" \"]},\" \",{\"t\":4,\"r\":\"following\",\"n\":true,\"f\":[\" \",{\"t\":7,\"e\":\"button\",\"a\":{\"class\":\"btn btn-success btn-block\"},\"f\":\"<i class=\\\"glyphicon glyphicon-plus\\\"></i> Legg til\",\"v\":{\"tap\":{\"n\":\"toggle\",\"d\":[{\"t\":2,\"r\":\"id\"}]}}},\" \"]}]}]}]},\" \"]}]}],\"t1\":\"fly\"},\" \"]}];});",
    "\ndefine(\r\n    'views/moviesView',['Ractive', 'rv!templates/movies'], \r\n    function(Ractive, movieTemplate) {\r\n        return Ractive.extend({\r\n            template: movieTemplate,\r\n\r\n            init: function(options) {\r\n                this.movies = options.movies;\r\n                this.set('movies', this.movies);\r\n                this.set('active', false);\r\n\r\n                this.on({\r\n                    toggle: function(event, id) {\r\n                        event.original.preventDefault();\r\n                        var movie = this.movies.get(id);\r\n\r\n                        var status = movie.get('following');\r\n                        movie.set('following', !status);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n);",
    "\ndefine(\"rv!templates/shows\",function(){return [{\"t\":4,\"r\":\"visible\",\"f\":[\" \",{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"shows\"},\"f\":[{\"t\":7,\"e\":\"h2\",\"f\":\"Tv shows\"},\" \",{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"row\"},\"f\":[{\"t\":4,\"r\":\"movies\",\"f\":[\" \",{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"col-sm-6 col-md-3\"},\"f\":[{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"thumbnail\"},\"f\":[{\"t\":7,\"e\":\"img\",\"a\":{\"data-src\":\"holder.js/300x200/auto\",\"alt\":[{\"t\":2,\"r\":\"title\"}]}},\" \",{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"caption\"},\"f\":[{\"t\":7,\"e\":\"h3\",\"f\":[{\"t\":2,\"r\":\"title\"}]},\" \",{\"t\":7,\"e\":\"p\",\"f\":[{\"t\":2,\"r\":\"description\"}]},\" \",{\"t\":4,\"r\":\"following\",\"f\":[\" \",{\"t\":7,\"e\":\"button\",\"a\":{\"class\":\"btn btn-danger btn-block\"},\"f\":\"<i class=\\\"glyphicon glyphicon-ok\\\"></i> Fjern\",\"v\":{\"tap\":{\"n\":\"toggle\",\"d\":[{\"t\":2,\"r\":\"id\"}]}}},\" \"]},\" \",{\"t\":4,\"r\":\"following\",\"n\":true,\"f\":[\" \",{\"t\":7,\"e\":\"button\",\"a\":{\"class\":\"btn btn-success btn-block\"},\"f\":\"<i class=\\\"glyphicon glyphicon-plus\\\"></i> Legg til\",\"v\":{\"tap\":{\"n\":\"toggle\",\"d\":[{\"t\":2,\"r\":\"id\"}]}}},\" \"]}]}]}]},\" \"]}]}],\"t1\":\"fly\"},\" \"]}];});",
    "\ndefine(\r\n    'views/showsView',['Ractive', 'rv!templates/shows'], \r\n    function(Ractive, showsTemplate) {\r\n        return Ractive.extend({\r\n\t\t\ttemplate: showsTemplate,\r\n\r\n\t\t\tinit: function(options) {\r\n\t\t\t\tthis.movies = options.movies;\r\n\t\t\t\tthis.set('movies', this.movies);\r\n\t\t\t\tthis.set('active', false);\r\n\r\n\t\t\t\tthis.on({\r\n\t\t\t\t\ttoggle: function(event, id) {\r\n\t\t\t\t\t\tevent.original.preventDefault();\r\n\t\t\t\t\t\tvar movie = this.movies.get(id);\r\n\r\n\t\t\t\t\t\tvar status = movie.get('following');\r\n\t\t\t\t\t\tmovie.set('following', !status);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n    }\r\n);",
    "\ndefine(\r\n    'router',['Ractive', 'rv!templates/shows'], \r\n    function(Ractive, showsTemplate) {\r\n        var Router = Backbone.Router.extend({\r\n\t\t\troutes: {\r\n\t\t\t\t'' : 'home',\r\n\t\t\t\t'shows' : 'shows'\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn new Router();\r\n    }\r\n);",
    "\ndefine(\r\n\t'app',[ 'jquery', 'Ractive', 'backbone', 'backboneAdaptor', 'models/movie', 'collections/movieCollection', \r\n\t'mock/movieData', 'views/moviesView', 'views/showsView', 'router' ], \r\n\tfunction ( $, Ractive, Backbone, Adaptor, MovieModel, Movies, mockMovies, MoviesView, ShowsView, router  ) {\r\n\t\tvar movieCollection = [];\r\n\t\tfor (var i = 0, len = 1000; i < len; i++) {\r\n\t\t\tmovieCollection.push(new MovieModel(\r\n\t\t\t\t{\r\n\t\t\t\t\tid: i,\r\n\t\t\t\t\ttitle: 'Film - ' + i,\r\n\t\t\t\t\tdescription: 'Most amazing movie ' + i,\r\n\t\t\t\t\tfollowing: true,\r\n\t\t\t\t\tposter: '',\r\n\t\t\t\t\tbanner: ''\r\n\t\t\t\t}\r\n\t\t\t));\r\n\t\t}\r\n\r\n\t\tvar movies = new Movies(movieCollection);\r\n\t\tvar movieList = new MoviesView({\r\n\t\t\tel: 'main',\r\n\t\t\tmovies: movies,\r\n\t\t\tadaptors: ['Backbone']\r\n\t\t});\r\n\r\n\t\tvar showList = new ShowsView({\r\n\t\t\tel: 'main',\r\n\t\t\tmovies: movies,\r\n\t\t\tadaptors: ['Backbone']\r\n\t\t});\r\n\r\n\t\trouter.on('route:home', function() {\r\n\t\t\tmovieList.set('visible', true);\r\n\t\t\tshowList.set('visible', false);\r\n\t\t});\r\n\t\trouter.on('route:shows', function() {\r\n\t\t\tmovieList.set('visible', false);\r\n\t\t\tshowList.set('visible', true);\r\n\t\t});\r\n\r\n\t\tBackbone.history.start();\r\n\t}\r\n\t);\r\n",
    "\n/*\r\n\r\nHolder - 2.2 - client side image placeholders\r\n(c) 2012-2013 Ivan Malopinsky / http://imsky.co\r\n\r\nProvided under the MIT License.\r\nCommercial use requires attribution.\r\n\r\n*/\r\n\r\nvar Holder = Holder || {};\r\n(function (app, win) {\r\n\r\nvar preempted = false,\r\nfallback = false,\r\ncanvas = document.createElement('canvas');\r\nvar dpr = 1, bsr = 1;\r\nvar resizable_images = [];\r\n\r\nif (!canvas.getContext) {\r\n\tfallback = true;\r\n} else {\r\n\tif (canvas.toDataURL(\"image/png\")\r\n\t\t.indexOf(\"data:image/png\") < 0) {\r\n\t\t//Android doesn't support data URI\r\n\t\tfallback = true;\r\n\t} else {\r\n\t\tvar ctx = canvas.getContext(\"2d\");\r\n\t}\r\n}\r\n\r\nif(!fallback){\r\n    dpr = window.devicePixelRatio || 1,\r\n    bsr = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;\r\n}\r\n\r\nvar ratio = dpr / bsr;\r\n\r\nvar settings = {\r\n\tdomain: \"holder.js\",\r\n\timages: \"img\",\r\n\tbgnodes: \".holderjs\",\r\n\tthemes: {\r\n\t\t\"gray\": {\r\n\t\t\tbackground: \"#eee\",\r\n\t\t\tforeground: \"#aaa\",\r\n\t\t\tsize: 12\r\n\t\t},\r\n\t\t\"social\": {\r\n\t\t\tbackground: \"#3a5a97\",\r\n\t\t\tforeground: \"#fff\",\r\n\t\t\tsize: 12\r\n\t\t},\r\n\t\t\"industrial\": {\r\n\t\t\tbackground: \"#434A52\",\r\n\t\t\tforeground: \"#C2F200\",\r\n\t\t\tsize: 12\r\n\t\t},\r\n\t\t\"sky\": {\r\n\t\t\tbackground: \"#0D8FDB\",\r\n\t\t\tforeground: \"#fff\",\r\n\t\t\tsize: 12\r\n\t\t},\r\n\t\t\"vine\": {\r\n\t\t\tbackground: \"#39DBAC\",\r\n\t\t\tforeground: \"#1E292C\",\r\n\t\t\tsize: 12\r\n\t\t},\r\n\t\t\"lava\": {\r\n\t\t\tbackground: \"#F8591A\",\r\n\t\t\tforeground: \"#1C2846\",\r\n\t\t\tsize: 12\r\n\t\t}\r\n\t},\r\n\tstylesheet: \"\"\r\n};\r\napp.flags = {\r\n\tdimensions: {\r\n\t\tregex: /^(\\d+)x(\\d+)$/,\r\n\t\toutput: function (val) {\r\n\t\t\tvar exec = this.regex.exec(val);\r\n\t\t\treturn {\r\n\t\t\t\twidth: +exec[1],\r\n\t\t\t\theight: +exec[2]\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tfluid: {\r\n\t\tregex: /^([0-9%]+)x([0-9%]+)$/,\r\n\t\toutput: function (val) {\r\n\t\t\tvar exec = this.regex.exec(val);\r\n\t\t\treturn {\r\n\t\t\t\twidth: exec[1],\r\n\t\t\t\theight: exec[2]\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tcolors: {\r\n\t\tregex: /#([0-9a-f]{3,})\\:#([0-9a-f]{3,})/i,\r\n\t\toutput: function (val) {\r\n\t\t\tvar exec = this.regex.exec(val);\r\n\t\t\treturn {\r\n\t\t\t\tsize: settings.themes.gray.size,\r\n\t\t\t\tforeground: \"#\" + exec[2],\r\n\t\t\t\tbackground: \"#\" + exec[1]\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\ttext: {\r\n\t\tregex: /text\\:(.*)/,\r\n\t\toutput: function (val) {\r\n\t\t\treturn this.regex.exec(val)[1];\r\n\t\t}\r\n\t},\r\n\tfont: {\r\n\t\tregex: /font\\:(.*)/,\r\n\t\toutput: function (val) {\r\n\t\t\treturn this.regex.exec(val)[1];\r\n\t\t}\r\n\t},\r\n\tauto: {\r\n\t\tregex: /^auto$/\r\n\t},\r\n\ttextmode: {\r\n\t\tregex: /textmode\\:(.*)/,\r\n\t\toutput: function(val){\r\n\t\t\treturn this.regex.exec(val)[1];\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//getElementsByClassName polyfill\r\ndocument.getElementsByClassName||(document.getElementsByClassName=function(e){var t=document,n,r,i,s=[];if(t.querySelectorAll)return t.querySelectorAll(\".\"+e);if(t.evaluate){r=\".//*[contains(concat(' ', @class, ' '), ' \"+e+\" ')]\",n=t.evaluate(r,t,null,0,null);while(i=n.iterateNext())s.push(i)}else{n=t.getElementsByTagName(\"*\"),r=new RegExp(\"(^|\\\\s)\"+e+\"(\\\\s|$)\");for(i=0;i<n.length;i++)r.test(n[i].className)&&s.push(n[i])}return s})\r\n\r\n//getComputedStyle polyfill\r\nwindow.getComputedStyle||(window.getComputedStyle=function(e){return this.el=e,this.getPropertyValue=function(t){var n=/(\\-([a-z]){1})/g;return t==\"float\"&&(t=\"styleFloat\"),n.test(t)&&(t=t.replace(n,function(){return arguments[2].toUpperCase()})),e.currentStyle[t]?e.currentStyle[t]:null},this})\r\n\r\n//http://javascript.nwbox.com/ContentLoaded by Diego Perini with modifications\r\nfunction contentLoaded(n,t){var l=\"complete\",s=\"readystatechange\",u=!1,h=u,c=!0,i=n.document,a=i.documentElement,e=i.addEventListener?\"addEventListener\":\"attachEvent\",v=i.addEventListener?\"removeEventListener\":\"detachEvent\",f=i.addEventListener?\"\":\"on\",r=function(e){(e.type!=s||i.readyState==l)&&((e.type==\"load\"?n:i)[v](f+e.type,r,u),!h&&(h=!0)&&t.call(n,null))},o=function(){try{a.doScroll(\"left\")}catch(n){setTimeout(o,50);return}r(\"poll\")};if(i.readyState==l)t.call(n,\"lazy\");else{if(i.createEventObject&&a.doScroll){try{c=!n.frameElement}catch(y){}c&&o()}i[e](f+\"DOMContentLoaded\",r,u),i[e](f+s,r,u),n[e](f+\"load\",r,u)}}\r\n\r\n//https://gist.github.com/991057 by Jed Schmidt with modifications\r\nfunction selector(a){\r\n\ta=a.match(/^(\\W)?(.*)/);var b=document[\"getElement\"+(a[1]?a[1]==\"#\"?\"ById\":\"sByClassName\":\"sByTagName\")](a[2]);\r\n\tvar ret=[];\tb!==null&&(b.length?ret=b:b.length===0?ret=b:ret=[b]);\treturn ret;\r\n}\r\n\r\n//shallow object property extend\r\nfunction extend(a,b){\r\n\tvar c={};\r\n\tfor(var i in a){\r\n\t\tif(a.hasOwnProperty(i)){\r\n\t\t\tc[i]=a[i];\r\n\t\t}\r\n\t}\r\n\tfor(var i in b){\r\n\t\tif(b.hasOwnProperty(i)){\r\n\t\t\tc[i]=b[i];\r\n\t\t}\r\n\t}\r\n\treturn c\r\n}\r\n\r\n//hasOwnProperty polyfill\r\nif (!Object.prototype.hasOwnProperty)\r\n    /*jshint -W001, -W103 */\r\n    Object.prototype.hasOwnProperty = function(prop) {\r\n\t\tvar proto = this.__proto__ || this.constructor.prototype;\r\n\t\treturn (prop in this) && (!(prop in proto) || proto[prop] !== this[prop]);\r\n\t}\r\n    /*jshint +W001, +W103 */\r\n\r\nfunction text_size(width, height, template) {\r\n\theight = parseInt(height, 10);\r\n\twidth = parseInt(width, 10);\r\n\tvar bigSide = Math.max(height, width)\r\n\tvar smallSide = Math.min(height, width)\r\n\tvar scale = 1 / 12;\r\n\tvar newHeight = Math.min(smallSide * 0.75, 0.75 * bigSide * scale);\r\n\treturn {\r\n\t\theight: Math.round(Math.max(template.size, newHeight))\r\n\t}\r\n}\r\n\r\nfunction draw(args) {\r\n\tvar ctx = args.ctx;\r\n\tvar dimensions = args.dimensions;\r\n\tvar template = args.template;\r\n\tvar ratio = args.ratio;\r\n\tvar holder = args.holder;\r\n\tvar literal = holder.textmode == \"literal\";\r\n\tvar exact = holder.textmode == \"exact\";\r\n\r\n\tvar ts = text_size(dimensions.width, dimensions.height, template);\r\n\tvar text_height = ts.height;\r\n\tvar width = dimensions.width * ratio,\r\n\t\theight = dimensions.height * ratio;\r\n\tvar font = template.font ? template.font : \"sans-serif\";\r\n\tcanvas.width = width;\r\n\tcanvas.height = height;\r\n\tctx.textAlign = \"center\";\r\n\tctx.textBaseline = \"middle\";\r\n\tctx.fillStyle = template.background;\r\n\tctx.fillRect(0, 0, width, height);\r\n\tctx.fillStyle = template.foreground;\r\n\tctx.font = \"bold \" + text_height + \"px \" + font;\r\n\tvar text = template.text ? template.text : (Math.floor(dimensions.width) + \"x\" + Math.floor(dimensions.height));\r\n\tif (literal) {\r\n\t\tvar dimensions = holder.dimensions;\r\n\t\ttext = dimensions.width + \"x\" + dimensions.height;\r\n\t}\r\n\telse if(exact && holder.exact_dimensions){\r\n\t\tvar dimensions = holder.exact_dimensions;\r\n\t\ttext = (Math.floor(dimensions.width) + \"x\" + Math.floor(dimensions.height));\r\n\t}\r\n\tvar text_width = ctx.measureText(text).width;\r\n\tif (text_width / width >= 0.75) {\r\n\t\ttext_height = Math.floor(text_height * 0.75 * (width / text_width));\r\n\t}\r\n\t//Resetting font size if necessary\r\n\tctx.font = \"bold \" + (text_height * ratio) + \"px \" + font;\r\n\tctx.fillText(text, (width / 2), (height / 2), width);\r\n\treturn canvas.toDataURL(\"image/png\");\r\n}\r\n\r\nfunction render(mode, el, holder, src) {\r\n\t\r\n\tvar dimensions = holder.dimensions,\r\n\t\ttheme = holder.theme,\r\n\t\ttext = holder.text ? decodeURIComponent(holder.text) : holder.text;\r\n\tvar dimensions_caption = dimensions.width + \"x\" + dimensions.height;\r\n\ttheme = (text ? extend(theme, {\r\n\t\ttext: text\r\n\t}) : theme);\r\n\ttheme = (holder.font ? extend(theme, {\r\n\t\tfont: holder.font\r\n\t}) : theme);\r\n\tel.setAttribute(\"data-src\", src);\r\n\tholder.theme = theme;\r\n\tel.holder_data = holder;\r\n\t\r\n\tif (mode == \"image\") {\r\n\t\tel.setAttribute(\"alt\", text ? text : theme.text ? theme.text + \" [\" + dimensions_caption + \"]\" : dimensions_caption);\r\n\t\tif (fallback || !holder.auto) {\r\n\t\t\tel.style.width = dimensions.width + \"px\";\r\n\t\t\tel.style.height = dimensions.height + \"px\";\r\n\t\t}\r\n\t\tif (fallback) {\r\n\t\t\tel.style.backgroundColor = theme.background;\r\n\t\t} else {\r\n\t\t\tel.setAttribute(\"src\", draw({ctx: ctx, dimensions: dimensions, template: theme, ratio:ratio, holder: holder}));\r\n\t\t\t\r\n\t\t\tif(holder.textmode && holder.textmode == \"exact\"){\r\n\t\t\t\tresizable_images.push(el);\r\n\t\t\t\tresizable_update(el);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t} else if (mode == \"background\") {\r\n\t\tif (!fallback) {\r\n\t\t\tel.style.backgroundImage = \"url(\" + draw({ctx:ctx, dimensions: dimensions, template: theme, ratio: ratio, holder: holder}) + \")\";\r\n\t\t\tel.style.backgroundSize = dimensions.width + \"px \" + dimensions.height + \"px\";\r\n\t\t}\r\n\t} else if (mode == \"fluid\") {\r\n\t\tel.setAttribute(\"alt\", text ? text : theme.text ? theme.text + \" [\" + dimensions_caption + \"]\" : dimensions_caption);\r\n\t\tif (dimensions.height.slice(-1) == \"%\") {\r\n\t\t\tel.style.height = dimensions.height\r\n\t\t} else {\r\n\t\t\tel.style.height = dimensions.height + \"px\"\r\n\t\t}\r\n\t\tif (dimensions.width.slice(-1) == \"%\") {\r\n\t\t\tel.style.width = dimensions.width\r\n\t\t} else {\r\n\t\t\tel.style.width = dimensions.width + \"px\"\r\n\t\t}\r\n\t\tif (el.style.display == \"inline\" || el.style.display === \"\" || el.style.display == \"none\") {\r\n\t\t\tel.style.display = \"block\";\r\n\t\t}\r\n\t\tif (fallback) {\r\n\t\t\tel.style.backgroundColor = theme.background;\r\n\t\t} else {\r\n\t\t\tresizable_images.push(el);\r\n\t\t\tresizable_update(el);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction dimension_check(el, callback) {\r\n\tvar dimensions = {\r\n\t\theight: el.clientHeight,\r\n\t\twidth: el.clientWidth\r\n\t};\r\n\tif (!dimensions.height && !dimensions.width) {\r\n\t\tif (el.hasAttribute(\"data-holder-invisible\")) {\r\n\t\t\tthrow new Error(\"Holder: placeholder is not visible\");\r\n\t\t} else {\r\n\t\t\tel.setAttribute(\"data-holder-invisible\", true)\r\n\t\t\tsetTimeout(function () {\r\n\t\t\t\tcallback.call(this, el)\r\n\t\t\t}, 1)\r\n\t\t\treturn null;\r\n\t\t}\r\n\t} else {\r\n\t\tel.removeAttribute(\"data-holder-invisible\")\r\n\t}\r\n\treturn dimensions;\r\n}\r\n\r\nfunction resizable_update(element) {\r\n\tvar images;\r\n\tif (element.nodeType == null) {\r\n\t\timages = resizable_images;\r\n\t} else {\r\n\t\timages = [element]\r\n\t}\r\n\tfor (var i in images) {\r\n\t\tif (!images.hasOwnProperty(i)) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tvar el = images[i]\r\n\t\tif (el.holder_data) {\r\n\t\t\tvar holder = el.holder_data;\r\n\t\t\tvar dimensions = dimension_check(el, resizable_update)\r\n\t\t\tif(dimensions){\r\n\t\t\t\tif(holder.fluid){\r\n\t\t\t\t\tel.setAttribute(\"src\", draw({\r\n\t\t\t\t\t\tctx: ctx,\r\n\t\t\t\t\t\tdimensions: dimensions,\r\n\t\t\t\t\t\ttemplate: holder.theme,\r\n\t\t\t\t\t\tratio: ratio,\r\n\t\t\t\t\t\tholder: holder\r\n\t\t\t\t\t}))\r\n\t\t\t\t}\r\n\t\t\t\tif(holder.textmode && holder.textmode == \"exact\"){\r\n\t\t\t\t\tholder.exact_dimensions = dimensions;\r\n\t\t\t\t\tel.setAttribute(\"src\", draw({\r\n\t\t\t\t\t\tctx: ctx,\r\n\t\t\t\t\t\tdimensions: holder.dimensions,\r\n\t\t\t\t\t\ttemplate: holder.theme,\r\n\t\t\t\t\t\tratio: ratio,\r\n\t\t\t\t\t\tholder: holder\r\n\t\t\t\t\t}))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction parse_flags(flags, options) {\r\n\tvar ret = {\r\n\t\ttheme: extend(settings.themes.gray, {})\r\n\t};\r\n\tvar render = false;\r\n\tfor (sl = flags.length, j = 0; j < sl; j++) {\r\n\t\tvar flag = flags[j];\r\n\t\tif (app.flags.dimensions.match(flag)) {\r\n\t\t\trender = true;\r\n\t\t\tret.dimensions = app.flags.dimensions.output(flag);\r\n\t\t} else if (app.flags.fluid.match(flag)) {\r\n\t\t\trender = true;\r\n\t\t\tret.dimensions = app.flags.fluid.output(flag);\r\n\t\t\tret.fluid = true;\r\n\t\t} else if (app.flags.textmode.match(flag)) {\r\n\t\t\tret.textmode = app.flags.textmode.output(flag)\r\n\t\t} else if (app.flags.colors.match(flag)) {\r\n\t\t\tret.theme = app.flags.colors.output(flag);\r\n\t\t} else if (options.themes[flag]) {\r\n\t\t\t//If a theme is specified, it will override custom colors\r\n\t\t\tif(options.themes.hasOwnProperty(flag)){\r\n\t\t\t\tret.theme = extend(options.themes[flag], {});\r\n\t\t\t}\r\n\t\t} else if (app.flags.font.match(flag)) {\r\n\t\t\tret.font = app.flags.font.output(flag);\r\n\t\t} else if (app.flags.auto.match(flag)) {\r\n\t\t\tret.auto = true;\r\n\t\t} else if (app.flags.text.match(flag)) {\r\n\t\t\tret.text = app.flags.text.output(flag);\r\n\t\t}\r\n\t}\r\n\treturn render ? ret : false;\r\n}\r\n\r\nfor (var flag in app.flags) {\r\n\tif (!app.flags.hasOwnProperty(flag)) continue;\r\n\tapp.flags[flag].match = function (val) {\r\n\t\treturn val.match(this.regex)\r\n\t}\r\n}\r\napp.add_theme = function (name, theme) {\r\n\tname != null && theme != null && (settings.themes[name] = theme);\r\n\treturn app;\r\n};\r\napp.add_image = function (src, el) {\r\n\tvar node = selector(el);\r\n\tif (node.length) {\r\n\t\tfor (var i = 0, l = node.length; i < l; i++) {\r\n\t\t\tvar img = document.createElement(\"img\")\r\n\t\t\timg.setAttribute(\"data-src\", src);\r\n\t\t\tnode[i].appendChild(img);\r\n\t\t}\r\n\t}\r\n\treturn app;\r\n};\r\napp.run = function (o) {\r\n\tpreempted = true;\r\n\t\r\n\tvar options = extend(settings, o),\r\n\t\timages = [],\r\n\t\timageNodes = [],\r\n\t\tbgnodes = [];\r\n\tif (typeof (options.images) == \"string\") {\r\n\t\timageNodes = selector(options.images);\r\n\t} else if (window.NodeList && options.images instanceof window.NodeList) {\r\n\t\timageNodes = options.images;\r\n\t} else if (window.Node && options.images instanceof window.Node) {\r\n\t\timageNodes = [options.images];\r\n\t}\r\n\t\r\n\tif (typeof (options.bgnodes) == \"string\") {\r\n\t\tbgnodes = selector(options.bgnodes);\r\n\t} else if (window.NodeList && options.elements instanceof window.NodeList) {\r\n\t\tbgnodes = options.bgnodes;\r\n\t} else if (window.Node && options.bgnodes instanceof window.Node) {\r\n\t\tbgnodes = [options.bgnodes];\r\n\t}\r\n\tfor (i = 0, l = imageNodes.length; i < l; i++) images.push(imageNodes[i]);\r\n\tvar holdercss = document.getElementById(\"holderjs-style\");\r\n\tif (!holdercss) {\r\n\t\tholdercss = document.createElement(\"style\");\r\n\t\tholdercss.setAttribute(\"id\", \"holderjs-style\");\r\n\t\tholdercss.type = \"text/css\";\r\n\t\tdocument.getElementsByTagName(\"head\")[0].appendChild(holdercss);\r\n\t}\r\n\tif (!options.nocss) {\r\n\t\tif (holdercss.styleSheet) {\r\n\t\t\tholdercss.styleSheet.cssText += options.stylesheet;\r\n\t\t} else {\r\n\t\t\tholdercss.appendChild(document.createTextNode(options.stylesheet));\r\n\t\t}\r\n\t}\r\n\tvar cssregex = new RegExp(options.domain + \"\\/(.*?)\\\"?\\\\)\");\r\n\tfor (var l = bgnodes.length, i = 0; i < l; i++) {\r\n\t\tvar src = window.getComputedStyle(bgnodes[i], null)\r\n\t\t\t.getPropertyValue(\"background-image\");\r\n\t\tvar flags = src.match(cssregex);\r\n\t\tvar bgsrc = bgnodes[i].getAttribute(\"data-background-src\");\r\n\t\tif (flags) {\r\n\t\t\tvar holder = parse_flags(flags[1].split(\"/\"), options);\r\n\t\t\tif (holder) {\r\n\t\t\t\trender(\"background\", bgnodes[i], holder, src);\r\n\t\t\t}\r\n\t\t} else if (bgsrc != null) {\r\n\t\t\tvar holder = parse_flags(bgsrc.substr(bgsrc.lastIndexOf(options.domain) + options.domain.length + 1)\r\n\t\t\t\t.split(\"/\"), options);\r\n\t\t\tif (holder) {\r\n\t\t\t\trender(\"background\", bgnodes[i], holder, src);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor (l = images.length, i = 0; i < l; i++) {\r\n\t\tvar attr_data_src, attr_src;\r\n\t\tattr_src = attr_data_src = src = null;\r\n\t\ttry {\r\n\t\t\tattr_src = images[i].getAttribute(\"src\");\r\n\t\t\tattr_datasrc = images[i].getAttribute(\"data-src\");\r\n\t\t} catch (e) {}\r\n\t\tif (attr_datasrc == null && !! attr_src && attr_src.indexOf(options.domain) >= 0) {\r\n\t\t\tsrc = attr_src;\r\n\t\t} else if ( !! attr_datasrc && attr_datasrc.indexOf(options.domain) >= 0) {\r\n\t\t\tsrc = attr_datasrc;\r\n\t\t}\r\n\t\tif (src) {\r\n\t\t\tvar holder = parse_flags(src.substr(src.lastIndexOf(options.domain) + options.domain.length + 1)\r\n\t\t\t\t.split(\"/\"), options);\r\n\t\t\tif (holder) {\r\n\t\t\t\tif (holder.fluid) {\r\n\t\t\t\t\trender(\"fluid\", images[i], holder, src)\r\n\t\t\t\t} else {\r\n\t\t\t\t\trender(\"image\", images[i], holder, src);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn app;\r\n};\r\ncontentLoaded(win, function () {\r\n\tif (window.addEventListener) {\r\n\t\twindow.addEventListener(\"resize\", resizable_update, false);\r\n\t\twindow.addEventListener(\"orientationchange\", resizable_update, false);\r\n\t} else {\r\n\t\twindow.attachEvent(\"onresize\", resizable_update)\r\n\t}\r\n\tpreempted || app.run();\r\n});\r\nif (typeof define === \"function\" && define.amd) {\r\n\tdefine('holder',[], function () {\r\n\t\treturn app;\r\n\t});\r\n}\r\n\r\n})(Holder, window);"
  ]
}